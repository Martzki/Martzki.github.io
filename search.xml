<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/31/Hello-World/</url>
    <content><![CDATA[<h1 id="About-Hello-World"><a href="#About-Hello-World" class="headerlink" title="About Hello World"></a>About Hello World</h1><ul>
<li>Hello World往往作为很多项目的初始示例程序，我个人把Hello World视为程序员对待“最初”的哲学，所以把它作为这个博客的第一篇博文的标题，用于给这个博客开个头（终于赶在过年前写出来了）。<span id="more"></span></li>
</ul>
<h1 id="About-Lost-Stars"><a href="#About-Lost-Stars" class="headerlink" title="About Lost Stars"></a>About Lost Stars</h1><ul>
<li>Lost Stars是我个人最喜欢的Maroon 5的一首歌，歌词中表现了和“寄蜉蝣于天地，渺沧海之一粟”有着异曲同工之妙的对个体的渺小之感叹，和我个人目前的人生状态较为契合，所以把它作为这个博客的标题；</li>
<li>后续应该主要会发布一些技术相关的主题，主要是作为自己的技术积累和总结，此外应该也会更新一些个人的游记；</li>
<li>你可能是从我的简历或者我的Github主页来到这个博客，请主要关注技术相关的内容🙃；</li>
<li>主页图片使用了之前从Bing首页保存下来的东京塔的照片，我个人很喜欢，如有侵权还请联系我；</li>
<li>博客基于<a href="https://hexo.io/zh-cn/">hexo</a>构建，使用了<a href="https://github.com/Shen-Yu/hexo-theme-ayer">ayer主题</a>，感谢这两个开源项目；</li>
<li>人生不易，随缘更新。</li>
</ul>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>Travel in Hangzhou in 2021</title>
    <url>/2022/02/07/Travel-in-Hangzhou-in-2021/</url>
    <content><![CDATA[<p>2021年的清明节假期，是我的第一次杭州旅行。一是想体验下杭州的清明时节，欣赏下西湖美景；二是亲身感受下杭州作为一线IT城市的氛围。  </p>
<span id="more"></span>
<h1 id="住"><a href="#住" class="headerlink" title="住"></a>住</h1><p>由于假期比较短，所以选择了住在西湖附近。其实最初想选择湖边的酒店或者民宿，不过由于预订的时间和💰的问题，最后选择了南高峰附近的民宿。<br>事后觉得住在西湖附近的决定是正确的，一是本身假期短，主要游玩的地方也是西湖，距离会近一些；二是节假日的杭州，交通真是太堵了，特别是西湖景区附近，打车非常困难。</p>
<h1 id="行"><a href="#行" class="headerlink" title="行"></a>行</h1><p>出行方式主要是打车和公共交通为主。<br>杭州有地铁，但西湖景区附近没有。西湖景区附近，出行方式的便捷度：步行 &gt; 共享单车 &gt; 公交车 &gt; 打车。<br>从我们在西湖景区附近打车的经验来看，较早或较晚的时候还是可以打到车的，但是白天，特别是午晚餐时间，打车十分困难，这个时间点主要选择步行或共享单车，不过高峰期共享单车也是一车难求。<br>PS 杭州的出租车属于比较老旧的燃油汽车，乘坐体验比较差，电动车的普及率比较低。</p>
<h1 id="玩"><a href="#玩" class="headerlink" title="玩"></a>玩</h1><p>西湖附近的主要游玩景点就是“西湖十景”，虽然通常这些官方推荐的景点质量良莠不齐，但西湖附近的游玩基本离不开这些景点。<br>湖边游览的顺序基本上是断桥出发，一路游览景色走到苏堤。</p>
<h2 id="雷峰塔"><a href="#雷峰塔" class="headerlink" title="雷峰塔"></a>雷峰塔</h2><p>西湖十景之一雷峰夕照中的雷峰，指的就是雷峰塔，同时也是白蛇传中白娘子被镇压的宝塔。<br>但实际上，这是一个我个人不推荐的景点。<br>首先，目前的雷峰塔经历了重建，最初的雷峰塔的断壁残垣，保留在目前的雷峰塔的底层，可供游客远程观赏，不过也就是一些砖块罢了；<br>其次，西湖十景的雷峰夕照，指的是夕阳西下时，阳光照在西湖和雷峰塔附近的景色。雷峰塔本身，塔内景色非常普通，登到最高层，可以眺望西湖，不过景色一般（和在黄鹤楼上眺望长江差不多一个意思）；<br>最后，还是人多😑。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_2048.jpeg" width="70%" height="70%"></p>
<center><p>雷峰塔中的白蛇传木雕</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1502.jpeg" width="70%" height="70%">
<center><p>雷峰塔</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_7644.jpeg" width="70%" height="70%">
<center><p>雷峰塔上眺望的西湖景色</p></center>  

<h2 id="断桥"><a href="#断桥" class="headerlink" title="断桥"></a>断桥</h2><p>西湖十景之一的断桥残雪中的断桥，是我们的西湖游览行程的起点，同样也是许多人的起点，所以人很多，如果想要拍照的话，可以选择早一点过去。<br>不过清明假期杭州最低气温只有十度左右，清晨的湖边，特别是阴天，还是非常冷的，需要做好一定的御寒准备。<br>此外，白堤连接着锦带桥和断桥，在桥上拍照时如果断桥人多可以考虑在锦带桥代替下🤡。  </p>
<h2 id="西湖自划船"><a href="#西湖自划船" class="headerlink" title="西湖自划船"></a>西湖自划船</h2><p>西湖边有多个划船的停泊点，需要注意的是至少需要两个人，同时受湖中风浪影响，风浪过大时，是不允许划船的。如果一定要划船的话，需要提前做好准备。</p>
<h2 id="三潭映月"><a href="#三潭映月" class="headerlink" title="三潭映月"></a>三潭映月</h2><p>西湖十景之一，1元人民币背面取景地，位于西湖中央的湖中岛。上下岛需要从西湖边坐船，有多个码头，可以从不同的码头上下。<br>虽然节假日的杭州哪里都人多，但湖中岛的人格外的多，因为岛上面积不大，离开岛也需要排队坐船，所以导致离岛的队伍很长，上岛容易离岛难。<br>本身景点主要是岛上的一些建筑和湖中的三个石塔，景点本身差强人意，但人实在是太多，和人群摩肩接踵大大降低了游览的兴致。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6158.jpeg" width="70%" height="70%"></p>
<center><p>三潭映月中的湖中石塔和雷峰塔</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1452.jpeg" width="70%" height="70%">
<center><p>岛内景色（一）</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1295.jpeg" width="70%" height="70%">
<center><p>岛内景色（二）</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1913.jpeg" width="70%" height="70%">
<center><p>岛内景色（三）</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6983.jpeg" width="70%" height="70%">
<center><p>岛上码头排队的游客</p></center>

<h2 id="灵隐寺"><a href="#灵隐寺" class="headerlink" title="灵隐寺"></a>灵隐寺</h2><p>灵隐寺是西湖景区的比较有名的寺庙了，寺庙本身不小，依山而建。不过我本人对寺庙相关的宗教文化不感冒，并且由于我们去的时候几乎已经走了一天了，随便看了看我就歇菜了🤡，并没有去到最高的庙宇。<br>如果对宗教文化比较感兴趣，或者喜欢到处打卡的话，可以一去；如果像我一样的话就不建议去了。<br>另外，在灵隐寺可以乘坐索道去北高峰，但是索道开放时间有限制，且北高峰不属于灵隐寺的范围，可根据个人情况选择。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6106.jpeg" width="70%" height="70%"></p>
<center><p>灵隐寺</p></center>

<h2 id="杨公堤"><a href="#杨公堤" class="headerlink" title="杨公堤"></a>杨公堤</h2><p>杨公堤说是和苏堤白堤齐名，但实际上游客比热门的那些景点要少多了，我们去的时候甚至没有什么人。这里的树林环境很好，很放松，时间不急的话可以来这里散散步。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1974.jpeg" width="70%" height="70%"></p>
<center><p>杨公堤湖边</p></center>

<h2 id="九溪十八涧"><a href="#九溪十八涧" class="headerlink" title="九溪十八涧"></a>九溪十八涧</h2><p>九溪十八涧是一条漫长的山路，一路上围绕着高耸的树林，时不时的还有一些茶园，路过村落时各家各户也在售卖自家的茶叶。随着交错的溪涧，从龙井一路下山，最终可以直接到达钱塘江边，虽然不在西湖边，不过是一个是一个散步的好地方，游客也不多，同时尽管整个景区有着不计其数的溪涧，得益于景区的工作人员的垃圾打捞，水很干净。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6103.jpeg" width="70%" height="70%"></p>
<center><p>九溪十八涧</p></center>

<h2 id="茶叶博物馆"><a href="#茶叶博物馆" class="headerlink" title="茶叶博物馆"></a>茶叶博物馆</h2><p>茶叶博物馆最初是在行程计划之中的，后来由于时间紧迫，原本不打算去了，但我们在乘坐公交车时，错误地提前了一站下车。不过没想到下车以后发现了一大片茶园，仔细一看居然就是之前计划去的茶叶博物馆。<br>我们到达的时候已经是晚饭时间了，整个茶园几乎没什么人，非常适合拍照。关于博物馆内部，由于是节假日，同时也到了晚饭时间，就没有进去游览了。如果对博物馆内部有兴趣，可以提前咨询下开放时间。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_2259.jpeg" width="70%" height="70%"></p>
<center><p>茶叶博物馆的茶园</p></center>

<h1 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h1><p>在杭州吃了几顿杭帮菜，通常都有东坡肉、龙井秋葵什么的，最不推荐的就是西湖醋鱼，这玩意应该99%的人都不会觉得好吃。<br>杭州有一些全国连锁的杭帮菜的总店，像绿茶和外婆家，如果喜欢这些餐厅也可以去试试它们的总店。</p>
<h2 id="河坊街"><a href="#河坊街" class="headerlink" title="河坊街"></a>河坊街</h2><p>河坊街没什么说的，就是那种每个旅游城市都会有的那种充斥着义乌小商品、坑一波外地游客就走的商业街，类似武汉的户部巷，极不推荐。</p>
<h2 id="春夏秋冬"><a href="#春夏秋冬" class="headerlink" title="春夏秋冬"></a>春夏秋冬</h2><p>去这家餐厅其实是一个巧合，我们当时在茶叶博物馆游览完成后，准备前往民宿老板推荐的一家杭帮菜馆——茶人村，但到了餐厅发现排队非常夸张，还有很多旅游大巴也带着游客在这里就餐。虽然餐厅装修上有一定的特色，但整个餐厅有一股浓浓的网红风，加上过长的等待时间，我们就换到了隔壁的春夏秋冬。<br>餐厅的环境不错，菜式也比较有特色（照片不知道咋的没了🤡），还有室外餐位，不过当时杭州的天气还是比较凉的，也没有人选择室外就餐。整体的服务质量也还不错，最重要的是不怎么需要排队。</p>
<h2 id="Doux-Amour"><a href="#Doux-Amour" class="headerlink" title="Doux Amour"></a>Doux Amour</h2><p>这家其实不是杭帮菜，而是一家网红的动物泡芙店，<a href="https://www.douxamour.com.au/">总店</a>应该是在澳洲，国内似乎只有杭州有分店。<br>店里的所有泡芙都是小动物造型，非常可爱。但是泡芙本身由于保质期问题，不太适合当作伴手礼，去吃个下午茶拍拍照片还是不错的。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6276.jpeg" width="70%" height="70%"></p>
<center><p>Doux Amour的菜单</p></center>
<img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6272.jpeg" width="70%" height="70%">
<center><p>Doux Amour的动物泡芙</p></center>

<h2 id="国宾馆紫薇厅"><a href="#国宾馆紫薇厅" class="headerlink" title="国宾馆紫薇厅"></a>国宾馆紫薇厅</h2><p>知乎上看到的推荐，原文中提到知道的人少，去的人不多，不过这些年估计各种安利种草后，看到推荐慕名而去的人也不少了。<br>紫薇厅不接受预订，开放时间应该是下午四点。我们在四点左右到达紫薇厅门口，被告知已经人满了不再接待，不知道是真满了还是被大佬们预定了🤡，有兴趣的话可以试一试。</p>
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtio feature negotiation from QEMU perspective</title>
    <url>/2022/02/06/Virtio-feature-negotiation-from-QEMU-perspective/</url>
    <content><![CDATA[<h1 id="QEMU中的Virtio-features协商流程"><a href="#QEMU中的Virtio-features协商流程" class="headerlink" title="QEMU中的Virtio features协商流程"></a>QEMU中的Virtio features协商流程</h1><p>下面以virtio-net对接vhost-net（kernel）为例，分析整个Virtio features协商的过程。</p>
<h2 id="vhost-net"><a href="#vhost-net" class="headerlink" title="vhost-net"></a>vhost-net</h2><p>vhost_net作为描述后端的数据结构，与真正使用的后端（vhost_user or vhost_net）对应。<br>每个vhost_net包含一个vhost_dev，vhost_net的features实际就是vhost_dev的features，与features相关的成员有：<code>features</code>，<code>acked_features</code>，<code>backend_features</code>和<code>protocol_features</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_net</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> <span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> <span class="title">vqs</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> backend;</span><br><span class="line">    NetClientState *nc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> &#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> features;</span><br><span class="line">    <span class="keyword">uint64_t</span> acked_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> protocol_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="vhost-dev-features"><a href="#vhost-dev-features" class="headerlink" title="vhost_dev::features"></a>vhost_dev::features</h3><p>在<code>vhost_dev_init</code>中，通过后端对应的接口（ioctl or unix socket），从后端获取到的后端支持的features。</p>
<h3 id="vhost-dev-acked-features"><a href="#vhost-dev-acked-features" class="headerlink" title="vhost_dev::acked_features"></a>vhost_dev::acked_features</h3><p>前端依据从后端获取的host features进行协商，协商完成后真正向后端传递的features（过滤了后端不支持的features），即后端真正工作的features。</p>
<h3 id="vhost-dev-backend-features"><a href="#vhost-dev-backend-features" class="headerlink" title="vhost_dev::backend_features"></a>vhost_dev::backend_features</h3><p>从命名看是描述后端的features，但和features字段重复。vhost-net相关的实际代码调用如下：</p>
<ol>
<li>vhost_net_ack_features: 在设置acked_features之前，用backend_features的值为acked_features初始化。这里acked_features为何不初始化为0，从QEMU开发者的邮件讨论看，之前在初始化0时，acked_features在在某些情况下会被初始化为unexpected value（This will result an unexpected value of acked_features which may fail the features setting of vhost.）。不过初始化为backend_features似乎在vdpa的场景下有新的问题，且问题仍然open中；<a href="https://bugs.launchpad.net/qemu/+bug/1924603">^1</a></li>
<li>vhost_net_init: 在后端为vhost-net的条件下，如果后端对应的tap设备不支持vnet_hdr，则backend_features中的<code>VHOST_NET_F_VIRTIO_NET_HDR</code>被置位，否则为0；</li>
<li>vhost_user_backend_init: 在后端为vhost-user的条件下，如果后端支持<code>VHOST_USER_F_PROTOCOL_FEATURES</code>，则backend_features中的<code>VHOST_USER_F_PROTOCOL_FEATURES</code>被置位。</li>
</ol>
<p>此外，内核vhost代码中定义了<code>VHOST_NET_BACKEND_FEATURES</code>，对应的ioctl操作为<code>VHOST_GET_BACKEND_FEATURES</code>和<code>VHOST_SET_BACKEND_FEATURES</code>，不过目前QEMU代码中没有这两个ioctl操作对应的逻辑。</p>
<h3 id="vhost-dev-protocol-features"><a href="#vhost-dev-protocol-features" class="headerlink" title="vhost_dev::protocol_features"></a>vhost_dev::protocol_features</h3><p>协议的扩展features。为了保持向下兼容性，vhost-user协议新增的features使用protocol_features进行描述，由<code>VHOST_USER_F_PROTOCOL_FEATURES</code>进行控制，标识protocol_features是否使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VHOST_USER_F_PROTOCOL_FEATURES 30</span></span><br></pre></td></tr></table></figure>
<p>在vhost-net场景下，protocol_features被设置为0。</p>
<h2 id="virtio-net"><a href="#virtio-net" class="headerlink" title="virtio-net"></a>virtio-net</h2><p>virtio-net作为描述后端的数据结构，与Guest的前端驱动（virtio_net）对应。在QEMU中，用VirtIONet来描述virtio-net，每个VirtIONet结构中包含了其对应的VirtIODevice。其中与features有关的成员有：VirtIONet的<code>host_features</code>，VirtIODevice的<code>guest_features</code>，<code>host_features</code>和<code>backend_features</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtIONet</span> &#123;</span></span><br><span class="line">    VirtIODevice parent_obj;</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> host_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtIODevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> guest_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> host_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="VirtIONet-host-features"><a href="#VirtIONet-host-features" class="headerlink" title="VirtIONet::host_features"></a>VirtIONet::host_features</h3><p>从virtio设备的角度来看，只区分Guest与Host，并不关心Host的具体实现。所以VirtIONet::host_features代表了Host理论可以支持的所有features。</p>
<p>VirtIONet::host_features在<code>virtio_net_class_init</code>中使用QEMU中virtio-net设备的默认属性<code>virtio_net_properties</code>（其中包含了offload相关的features）来初始化，同时在每个virtio-net设备实例化时，依据后端设备（e.g. tap）的配置，对部分features进行设置。</p>
<p>VirtIONet::host_features唯一的调用处在<code>virtio_net_get_features</code>，即响应Guest前端驱动的get_features请求，VirtIONet::host_features作为初始值，在一系列的过滤动作后，向前端返回Host所支持的features（细节见下文）。</p>
<h3 id="VirtIODevice-host-features"><a href="#VirtIODevice-host-features" class="headerlink" title="VirtIODevice::host_features"></a>VirtIODevice::host_features</h3><p>VirtIODevice::host_features在<code>virtio_bus_device_plugged</code>中调用对应virtio设备的get_features进行初始化，保存的是get_features的返回值，即真正返回给前端驱动的features。</p>
<p><code>virtio_net_get_features</code>向前端返回features的逻辑如下：</p>
<ol>
<li>VirtIONet::host_features作为初始features；</li>
<li>如果后端设备（e.g. tap）不支持vnet_hdr，则将features中对应的offload features取消置位；</li>
<li>QEMU内部预定义了后端支持的feature_bits（kernel_feature_bits or user_feature_bits），将feature_bits支持但vhost_dev::features中不支持的bit在features中取消置位；</li>
<li>对<code>VIRTIO_NET_F_MTU</code>进行特殊处理（和<code>mtu_bypass_backend</code>有关，对整体协商流程不重要）；</li>
<li>将上述流程中处理后的features返回给前端驱动。</li>
</ol>
<p>要注意VirtIODevice::host_features和VirtIONet::host_features的区别，VirtIONet::host_features是Host理论可以支持的所有features，而VirtIODevice::host_features是对VirtIONet::host_features中依据后端、设备的设置进行处理后，真正返回给前端驱动的features。</p>
<h3 id="VirtIODevice-guest-features"><a href="#VirtIODevice-guest-features" class="headerlink" title="VirtIODevice::guest_features"></a>VirtIODevice::guest_features</h3><p>Guest前端驱动用自身features和get_features得到的VirtIODevice::host_features进行协商后，传递给QEMU，与VirtIODevice::host_features取交集，保存得到guest_features。即前后端在Guest协商后得到的features。</p>
<h3 id="VirtIODevice-backend-features"><a href="#VirtIODevice-backend-features" class="headerlink" title="VirtIODevice::backend_features"></a>VirtIODevice::backend_features</h3><p>看代码调用是为了特殊处理<code>mtu_bypass_backend</code>保存的，在<code>virtio_net_get_features</code>处理流程中，特殊处理<code>VIRTIO_NET_F_MTU</code>前保存的features，除了<code>VIRTIO_NET_F_MTU</code>和VirtIODevice::host_features有差异外，其他一致。</p>
<h2 id="QEMU正常启动流程中的features协商"><a href="#QEMU正常启动流程中的features协商" class="headerlink" title="QEMU正常启动流程中的features协商"></a>QEMU正常启动流程中的features协商</h2><p>QEMU正常启动流程中，从开始运行到GuestOS启动的RunState的变化：<code>preconfig</code>-&gt;<code>prelaunch</code>-&gt;<code>running</code>。</p>
<p>上述RunState变化过程中，virtio设备的features相关流程如下：</p>
<ol>
<li>preconfig: <code>qemu_init</code>-&gt;<code>net_init_clients</code>-&gt;……-&gt;<code>net_init_tap</code>-&gt;……-&gt;<code>vhost_net_init</code>，初始化tap和vhost_dev。其中vhost_dev初始化时，调用后端对应的接口，获取后端支持的所有features，用来初始化<code>vhost_dev::features</code>，同时依据对端设备（tap）支持的特性，初始化<code>vhost_dev::backend_features</code>，以及初始化<code>vhost_dev::protocol_features</code>为0；</li>
<li>prelaunch: 调用<code>virtio_bus_device_plugged</code>，通过对应设备类型的get_features，初始化<code>VirtIODevice::host_features</code>；</li>
<li>running: <ul>
<li>GuestOS启动，内部virtio_net驱动被加载，调用<code>virtio_dev_probe</code>-&gt;……-&gt;<code>vp_get_features</code>获取设备的features，即QEMU侧的<code>VirtIODevice::host_features</code>，再与自身驱动支持的features进行协商，协商完成后调用<code>virtio_finalize_features</code>-&gt;……-&gt;<code>vp_set_features</code>将协商好的features传给QEMU；</li>
<li>此时发生VM-EXIT，QEMU侧调用<code>virtio_set_features</code>-&gt;……-&gt;<code>virtio_net_set_features</code>-&gt;……-&gt;<code>vhost_ack_features</code>，把前端驱动传递过来的features和后端对应feature_bits共同支持的bit置位，将结果保存在<code>vhost_dev::acked_features</code>；</li>
<li>GuestOS中<code>virtio_finalize_features</code>-&gt;……-&gt;<code>vp_set_features</code>执行完成后，会设置<code>VIRTIO_CONFIG_S_FEATURES_OK</code>，进而触发QEMU侧的对应调用<code>virtio_set_status</code>-&gt;……-&gt;<code>vhost_dev_start</code>。在<code>vhost_dev_start</code>中，调用<code>vhost_dev_set_features</code>，将前端协商好的<code>vhost_dev::acked_features</code>通过后端对应的接口传递到后端。</li>
</ul>
</li>
</ol>
<h2 id="QEMU热迁移流程中的features协商"><a href="#QEMU热迁移流程中的features协商" class="headerlink" title="QEMU热迁移流程中的features协商"></a>QEMU热迁移流程中的features协商</h2><p>QEMU热迁移流程中，源虚拟机从开始运行到迁移结束的RunState变化：<code>running</code>-&gt;<code>finish_migrate</code>-&gt;<code>postmigrate</code>；目的虚拟机从开始运行到GuestOS启动的RunState的变化：<code>preconfig</code>-&gt;<code>inmigrate</code>-&gt;<code>running</code>。</p>
<h3 id="源端virtio-features在热迁移流程中的变化"><a href="#源端virtio-features在热迁移流程中的变化" class="headerlink" title="源端virtio features在热迁移流程中的变化"></a>源端virtio features在热迁移流程中的变化</h3><ol>
<li>running: 正常运行状态，无相关操作；</li>
<li>finish_migrate: <code>virtio_save</code>中保存<code>VirtIODevice::guest_features</code>的低32bit，迁移到目的端。</li>
</ol>
<h3 id="目的端virtio-features在热迁移流程中的变化"><a href="#目的端virtio-features在热迁移流程中的变化" class="headerlink" title="目的端virtio features在热迁移流程中的变化"></a>目的端virtio features在热迁移流程中的变化</h3><ol>
<li>preconfig: 和正常启动流程一致；</li>
<li>inmigrate: <ul>
<li>调用<code>virtio_bus_device_plugged</code>，通过对应设备类型的get_features，初始化<code>VirtIODevice::host_features</code>；</li>
<li><code>virtio_load</code>-&gt;……-&gt;<code>virtio_net_set_features</code>-&gt;……-&gt;<code>vhost_ack_features</code>，在<code>virtio_load</code>中接收源端协商完成的<code>VirtIODevice::guest_features</code>，在<code>vhost_ack_features</code>中将接收到的<code>VirtIODevice::guest_features</code>和后端对应feature_bits共同支持的bit置位，将结果保存在<code>vhost_dev::acked_features</code>；</li>
</ul>
</li>
<li>running: <code>qemu_main_loop</code>-&gt;<code>main_loop_wait</code>-&gt;……-&gt;<code>vm_start</code>-&gt;……-&gt;<code>virtio_set_features</code>，使用inmigrate过程中设置好的<code>vhost_net::acked_features</code>通过后端对应的接口传递到后端。</li>
</ol>
<h2 id="正常启动流程和热迁移流程对比"><a href="#正常启动流程和热迁移流程对比" class="headerlink" title="正常启动流程和热迁移流程对比"></a>正常启动流程和热迁移流程对比</h2><p>硬件设备的初始化流程都一致，除了PCI设备的一些状态也是通过迁移初始化之外，最主要的区别在于热迁移流程中的features协商过程：协商必须的<code>VirtIODevice::guest_features</code>通过热迁移从源端获取，后端直接和QEMU进行协商流程；协商流程控制不再需要前端驱动修改设备status，而是在QEMU热迁移流程中触发。前端驱动不参与、不感知，避免了重新初始化。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
        <tag>Virtio/Vhost</tag>
      </tags>
  </entry>
  <entry>
    <title>Some attempts to connect to VDI</title>
    <url>/2022/02/06/Some-attempts-to-connect-to-VDI/</url>
    <content><![CDATA[<h1 id="Why-do-I-need-to-do-this"><a href="#Why-do-I-need-to-do-this" class="headerlink" title="Why do I need to do this"></a>Why do I need to do this</h1><p>公司提供VDI作为办公环境，远程办公时，需要通过VPN先连接到公司内网，再从内网连接到办公VDI。<br>公司提供了Mac和Windows的VPN客户端用于连接到内网，按理说安装并使用公司提供的客户端连接内网即可，但是之所以没有这么做有两个主要原因：    </p>
<ul>
<li>公司提供的VPN配套的软件太过臃肿；</li>
<li>公司提供的VDI内置了访问控制软件，会记录IM的聊天记录等信息。担心VPN“附赠”的软件或者VPN本身会做类似的操作🙄。</li>
</ul>
<p>这篇博文主要记录下折腾虚拟桌面环境的一些经历。</p>
<span id="more"></span>

<h1 id="What-attempts-did-I-try"><a href="#What-attempts-did-I-try" class="headerlink" title="What attempts did I try"></a>What attempts did I try</h1><p>由于上面说的原因，需要在个人PC环境之外，提供一个桌面环境用于远程连接到VDI。<br>再去配置一套物理桌面环境显然是不现实的，所以主要向虚拟桌面环境考虑：</p>
<ul>
<li>Windows Sandbox</li>
<li>Cloud Virtual Mechine</li>
<li>Reverse Proxy (frp)</li>
<li>MacOS Container</li>
</ul>
<h2 id="Windows-Sandbox"><a href="#Windows-Sandbox" class="headerlink" title="Windows Sandbox"></a>Windows Sandbox</h2><p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-sandbox/windows-sandbox-overview">Windows Sandbox</a>是一个非常好的选择，它是Windows内置的虚拟化技术，在Windows 10的专业/企业版中打开选项后可以直接启动。<br>该技术和通用的虚拟化技术一样，对CPU的虚拟化特性也有一定要求，不过不是太老的CPU应该都能够满足要求。在我个人的移动端4代i7、8G内存的PC上，Windows 10和Windows 11中，Windows Sandbox都有足够好的表现。因为它只是虚拟了一套运行环境（runtime environment），应该是WIndows自己的容器化技术。相比于直接运行一个虚拟机而言，轻量的多，同时它还支持GPU虚拟化，从实际使用体验上来看，Sandbox的启停都足够快，同时图形性能对于基本办公足够使用了。<br>但它有个明显的弊端：所有在Sandbox中所做修改都不会被保存，将会随Sandbox进程的退出一并被销毁（类似于加了<code>--rm</code>参数的docker容器🤨）。这个特性提供了绝对的Sandbox环境，但和我个人的使用场景上并不是完全契合，每次需要连接VDI时都要全新安装一整套的VPN软件，不过总体来说从使用难度和使用体验上来说，还是相对不错的。<br>没有最终使用这个方案的原因主要是因为我的Windows PC坏了😅。</p>
<h2 id="Cloud-Virtual-Mechine"><a href="#Cloud-Virtual-Mechine" class="headerlink" title="Cloud Virtual Mechine"></a>Cloud Virtual Mechine</h2><p>Windows PC坏了以后，开始转战MacOS。虚拟机是一个常见的能够提供虚拟桌面环境的方式，由于MacOS的软件生态（主要是💰的问题），没有选择直接在MacOS上运行虚拟机，转而考虑公有云提供的虚拟机服务，正好看到腾讯云有轻量应用服务器的优惠，且支持Windows系统，遂马上下单。<br>但当真正使用这个虚拟机时发现，公司提供的VPN客户端不支持在Windows Server安装（垃圾🙃），同时这个轻量应用服务器不支持自行上传镜像安装系统，所以没法直接重装成个人版的Windows。<br>但，买都买了，还是折腾下吧。</p>
<h3 id="Nested-Virtualization"><a href="#Nested-Virtualization" class="headerlink" title="Nested Virtualization"></a>Nested Virtualization</h3><p>第一个尝试是虚拟机，没错，是在1核2G的虚拟机上再跑一个Windows虚拟机。<br>基于如此拉胯的硬件配置，Host必不可能选Windows了，所以重装成了CentOS。然后就是supervisor的选择，工作中用的比较多的是QEMU-KVM，相对比较熟悉了，所以尝试换用Virutal Box。<br>虽然<a href="https://www.virtualbox.org/">Virutal Box</a>是Oracle主导的开源项目，但官网就给人一种贫穷的感觉。它主要运行在桌面环境上，虽然提供了命令行工具VBoxManage，但在命令行环境下仍然需要安装一些如QT相关的依赖库。不幸的是在解决了依赖问题，配置好虚拟机后，仍然无法启动，报错是无法启用硬件加速特性（腾讯云的这个虚拟机不支持嵌套虚拟化），在配置里取消了所有硬件加速的选项后，还是无法解决该问题（MacOS上的Virtual Box也是一堆BUG），无奈只能放弃Virtual Box。<br>于是换用QEMU，直接使用yum安装，使用libvirt进行虚拟机配置，由于不支持嵌套虚拟化，同样没法使用QEMU-KVM，只能通过纯模拟的CPU运行GuestOS，虽然能够运行，但是几乎完全无法正常使用，开机需要15min，开机之后所有的操作都是分钟级别的，就是折腾来玩玩罢了。</p>
<h3 id="Dual-Operation-System"><a href="#Dual-Operation-System" class="headerlink" title="Dual Operation System"></a>Dual Operation System</h3><p>这个配置下的嵌套虚拟化也就图一乐，既然官方给的镜像不包含个人版的Windows，同时也不支持自定义上传镜像，那就采用安装双系统的曲线救国的方式。<br>先使用原有分区的空闲空间创建一个新的分区，再将操作系统镜像下载到硬盘上，直接从硬盘运行安装程序，将操作系统安装到新的分区上。<br>为了在1核2G的拉胯配置上尽可能流畅地运行Windows，使用<a href="https://archive.org/details/Tiny7">Tiny7</a>（精简版的Windows 7）作为使用的操作系统，但镜像内不包含Virtio驱动，无法继续安装。下载了几乎所有版本的Virtio驱动在安装时使用，但全都无法奏效，最后无奈换用了<a href="https://archive.org/details/tiny-10_202105">Tiny10</a>（精简版的Windows 10）。使用Tiny10后，在安装时选择硬盘上已有的Virtio驱动，即可完成正常安装。<br>流畅度上来说和自带的Windows Server相比没有明显差距，在远程连接上VDI后，由于自身配置拉胯，流畅度一般。且由于没有显卡，在需要图形渲染的场景下（如窗口切换），卡顿明显。总的来说属于勉强可用的程度，但好处是无需在自己的PC上运行虚拟机。  </p>
<h3 id="Windows-Container"><a href="#Windows-Container" class="headerlink" title="Windows Container"></a>Windows Container</h3><p><a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/">Windows Container</a>是考虑过的另一个折腾方向，Windows官方提供了<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-base-images">镜像</a>，但在Windows Server安装Docker时，始终有问题无法解决，同时Windows容器只能使用和Host相同的kernel，并且无法提供一个基于容器的桌面环境，遂放弃。</p>
<h2 id="Reverse-Proxy-frp"><a href="#Reverse-Proxy-frp" class="headerlink" title="Reverse Proxy (frp)"></a>Reverse Proxy (frp)</h2><p>使用反向代理（如<a href="https://github.com/fatedier/frp">frp</a>）将Windows远程控制服务暴露到公网也是一个可行方案，但细节上没有那么简单。<br>由于办公VDI是和公网隔离的，所以无法直接使用反向代理直接连接到办公VDI。但公司提供了外网VDI用于在办公时访问公网，可以使用反向代理连接到外网VDI，再在外网VDI中安装运行VPN客户端后反向连接到办公VDI内。<br>这种方案下的外网VDI代替了自购的公有云虚拟机，拥有更高的配置，但同样不支持虚拟显卡，图形性能仍然拉胯。按理说可以替代自购的公有云虚拟机了，但由于安全部门审计到frp流量，告知不允许使用此类反向代理，遂放弃。  </p>
<h2 id="MacOS-Container"><a href="#MacOS-Container" class="headerlink" title="MacOS Container"></a>MacOS Container</h2><p>在考虑虚拟化方案时，觉得虚拟机消耗过大后，很容易想到的就是容器技术。如果使用容器技术能够满足需求，那就能够使用一个轻量化的隔离环境。在我只有MacOS的前提下，开始查找是否有MacOS的容器化方案。<br>幸运的是，还真有个项目<a href="https://github.com/sickcodes/Docker-OSX">Docker-OSX</a>，不幸的是，这个项目基于QEMU-KVM，说白了还是虚拟机那一套，所以也就是看了看而已。</p>
<h1 id="What-did-I-chose-finally"><a href="#What-did-I-chose-finally" class="headerlink" title="What did I chose finally"></a>What did I chose finally</h1><p>由于上述种种原因，最终的使用方案是在公有云自购的虚拟机上安装的双系统中，连接到远程VDI。<br>如果有Windows环境的话，还是推荐使用WIndows Sandbox；MacOS环境下，如果能够容忍虚拟机的性能消耗的话，虚拟机应该是一个比较好的选择。<br>相比之下，在公有云上的拉胯虚拟机中连接到远程VDI的方案并不是什么理想方案了。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2022/01/09/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>God, tell us the reason youth is wasted on the young.</p>
</blockquote>
<p>A coder mainly work on network virtualization dataplane development.<br>Email: <a href="mailto:&#109;&#97;&#x72;&#x73;&#x31;&#52;&#x38;&#x35;&#48;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#109;&#97;&#x72;&#x73;&#x31;&#52;&#x38;&#x35;&#48;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a></p>
<img src="/images/avatar.JPG" width="40%" height="40%">]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
</search>
