<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/31/Hello-World/</url>
    <content><![CDATA[<h1 id="About-Hello-World"><a href="#About-Hello-World" class="headerlink" title="About Hello World"></a>About Hello World</h1><ul>
<li>Hello World往往作为很多项目的初始示例程序，我个人把Hello World视为程序员对待“最初”的哲学，所以把它作为这个博客的第一篇博文的标题，用于给这个博客开个头（终于赶在过年前写出来了）。<span id="more"></span></li>
</ul>
<h1 id="About-Lost-Stars"><a href="#About-Lost-Stars" class="headerlink" title="About Lost Stars"></a>About Lost Stars</h1><ul>
<li>Lost Stars是我个人最喜欢的Maroon 5的一首歌，歌词中表现了和“寄蜉蝣于天地，渺沧海之一粟”有着异曲同工之妙的对个体的渺小之感叹，和我个人目前的人生状态较为契合，所以把它作为这个博客的标题；</li>
<li>后续应该主要会发布一些技术相关的主题，主要是作为自己的技术积累和总结，此外应该也会更新一些个人的游记；</li>
<li>你可能是从我的简历或者我的Github主页来到这个博客，请主要关注技术相关的内容🙃；</li>
<li>主页图片使用了之前从Bing首页保存下来的东京塔的照片，我个人很喜欢，如有侵权还请联系我；</li>
<li>博客基于<a href="https://hexo.io/zh-cn/">hexo</a>构建，使用了<a href="https://github.com/Shen-Yu/hexo-theme-ayer">ayer主题</a>，感谢这两个开源项目；</li>
<li>人生不易，随缘更新。</li>
</ul>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>Mattermost Auto Reply Tool</title>
    <url>/2022/02/17/Mattermost-auto-reply-tool/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p><a href="https://mattermost.org/">Mattermost</a>是一款开源的IM工具，作为Slack的替代产品。</p>
<h2 id="Mattermost-Source-Code"><a href="#Mattermost-Source-Code" class="headerlink" title="Mattermost Source Code"></a>Mattermost Source Code</h2><p>mattermost的github主页上主要有这几个项目：</p>
<ul>
<li>mattermost-server: 用Go开发的服务端代码，也是整体的核心代码；</li>
<li>mattermost-webapp: 基于Web的客户端代码，所有其他类型的客户端，均是基于webapp实现；</li>
<li>desktop: 基于Electron的Windows客户端代码，通过Chromium浏览器内核连接webapp，完成客户端的功能；</li>
<li>mattermost-mobile: iOS和Android的客户端代码，应该也是通过浏览器内核连接webapp进而实现的的客户端功能。</li>
</ul>
<span id="more"></span>

<h2 id="Mattermost-Deployment"><a href="#Mattermost-Deployment" class="headerlink" title="Mattermost Deployment"></a>Mattermost Deployment</h2><p><a href="https://docs.mattermost.com/guides/deployment.html#server-installation">官方文档</a>中提供了各种环境下的部署方式，最便捷的就是直接在本地运行docker容器。不得不说，容器技术极大地简化了应用的部署流程，如果只是需要部署一个基本的服务端，直接按照文档指导，启动容器即可，容器内会自行运行server和webapp，即可通过浏览器连接webapp。</p>
<h1 id="Mattermost-Auto-Reply"><a href="#Mattermost-Auto-Reply" class="headerlink" title="Mattermost Auto Reply"></a>Mattermost Auto Reply</h1><p>关于Mattermost自身的其他功能就不介绍了，有他自己的优缺点。聊天功能中，Mattermost自身提供了一个自动回复的功能，在开启自动回复时，将会把在线状态设置为离开。此时收到所有私聊信息后，会触发自动回复。</p>
<p>这个自带功能的鸡肋的地方在于：会强制将状态设置为离线，此时收到新的消息不再有推送提醒，并且无法设置自动回复间隔，每收到的一条新消息都会触发自动回复。<br>而一个理想的自动回复功能应该包含：</p>
<ul>
<li>可自由开关</li>
<li>和自身账户在线状态无关，不会设置在线状态为离开</li>
<li>功能开启后不影响正常使用，收到新消息后能够正常触发消息推送</li>
<li>可设置消息回复的频率</li>
</ul>
<h2 id="Develop-with-Server"><a href="#Develop-with-Server" class="headerlink" title="Develop with Server"></a>Develop with Server</h2><p>对一款开源产品而言，直接修改源代码是实现功能自定义的最直接的方式。</p>
<p>最初的想法就是直接修改原生的自动回复代码，将其中设置在线状态的代码屏蔽，即可在不做大量修改的情况下，将自动回复功能会将状态设置为离线的问题解决。</p>
<p>在看了对应功能的源码后，发现这部分功能是在server中实现的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动回复功能启停（同时设置用户在线状态）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">SetAutoResponderStatus</span><span class="params">(user *model.User, oldNotifyProps model.StringMap)</span></span> &#123;</span><br><span class="line">	active := user.NotifyProps[model.AutoResponderActiveNotifyProp] == <span class="string">&quot;true&quot;</span></span><br><span class="line">	oldActive := oldNotifyProps[model.AutoResponderActiveNotifyProp] == <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line">	autoResponderEnabled := !oldActive &amp;&amp; active</span><br><span class="line">	autoResponderDisabled := oldActive &amp;&amp; !active</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> autoResponderEnabled &#123;</span><br><span class="line">		a.SetStatusOutOfOffice(user.Id)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> autoResponderDisabled &#123;</span><br><span class="line">		a.SetStatusOnline(user.Id, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动回复功能代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">SendAutoResponse</span><span class="params">(c *request.Context, channel *model.Channel, receiver *model.User, post *model.Post)</span> <span class="params">(<span class="keyword">bool</span>, *model.AppError)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> receiver == <span class="literal">nil</span> || receiver.NotifyProps == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	active := receiver.NotifyProps[model.AutoResponderActiveNotifyProp] == <span class="string">&quot;true&quot;</span></span><br><span class="line">	message := receiver.NotifyProps[model.AutoResponderMessageNotifyProp]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !active || message == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rootID := post.Id</span><br><span class="line">	<span class="keyword">if</span> post.RootId != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		rootID = post.RootId</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	autoResponderPost := &amp;model.Post&#123;</span><br><span class="line">		ChannelId: channel.Id,</span><br><span class="line">		Message:   message,</span><br><span class="line">		RootId:    rootID,</span><br><span class="line">		Type:      model.PostTypeAutoResponder,</span><br><span class="line">		UserId:    receiver.Id,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := a.CreatePost(c, autoResponderPost, channel, <span class="literal">false</span>, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这个功能是通过对服务端用户状态进行相应的设置，启用功能后，服务端在消息处理时自动实现的，整个过程客户端只起到了一个状态设置的作用，不参与实际的回复功能实现。</p>
<p>经过上面的代码分析，如果想要通过修改原生代码实现对应功能的话，则需要修改服务端代码，重新编译部署再上线。其劣势主要有：</p>
<ul>
<li>对服务端代码进行修改需要对应的权限：如果没有服务端的管理权限，单独作为用户，是没有办法修改服务端代码的；</li>
<li>重新部署会引起业务中断：更换服务端代码重新部署会引起业务中断。</li>
</ul>
<p>由于大多数使用者都是单纯的用户，并不具备重新部署服务端的条件，所以这个方案作为理论可行且简单的方案，但并未最终选用。</p>
<h2 id="Develop-with-Client"><a href="#Develop-with-Client" class="headerlink" title="Develop with Client"></a>Develop with Client</h2><p>上面分析了对应代码是在服务端中实现的，在功能调研期间，发现修改服务端实现功能的方式不太现实后，曾考虑过修改客户端代码，在客户端重新实现一个自动回复功能。</p>
<p>但经过更细致的分析后发现，mattermost的客户端核心是mattermost-webapp，客户端的具体的消息收发功能都是在mattermost-webapp中实现的，各个平台上的客户端都只是利用平台特性对mattermost-webapp进行了封装，主要应该是为了平台相关的交互功能实现，比如文件上传下载、以及消息推送功能的实现。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/process-diagram.png" width="70%" height="70%" alt="mattermost-desktop Process Diagram">

<p>如<a href="https://developers.mattermost.com/contribute/desktop/">官方文档</a>描述的那样，mattermost-desktop基于Electron开发，分为main进程和renderer进程，main进程由NodeJS实现，包含了通知管理、窗口布局管理、配置、操作系统集成等功能，同时包含了对rederer进程的生命周期管理等功能；rederer进程基本就是Chromium浏览器内核，通过连接webapp实现对应的功能。</p>
<p>main进程和rederer进程之间通过特定的IPC进行交互。</p>
<p>所以尝试修改客户端代码实现功能的方案也告吹，因为客户端的核心mattermost-webapp通常是和mattermost-server运行在一起的，对其进行修改的难度同样较大。</p>
<h2 id="Develop-an-API-Request-Proxy"><a href="#Develop-an-API-Request-Proxy" class="headerlink" title="Develop an API Request Proxy"></a>Develop an API Request Proxy</h2><p>由于消息的收发都是webapp调用和server的API实现的，所以一种理论可行的方案为：获取客户端的cookie等身份认证信息，监控所有客户端的交互请求。通过对交互请求进行分析，收到消息后，依据自动回复配置和策略，调用对应的API，发送预先设定好的自动回复消息。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/API proxy.drawio.png" width="70%" height="70%" alt="API Request Proxy">

<p>这是一种理论可行的方案，但却不是一个现实的、容易实现的方案，有如下几个原因：</p>
<ul>
<li>认证：不论是server API的认证信息的获取，还是HTTPS（假设服务端使用了HTTPS）的认证信息获取，都需要通过已经完成认证的webapp来获取，实际上是很不容易实现的，而这些认证信息，是分析webapp和server的API请求、通过API完成消息发送的前提；</li>
<li>使用难度：需要以请求代理的方式部署，从而能够在webapp和server交互的过程中获取到交互的具体请求。代理的部署形态增加了用户的使用难度。</li>
</ul>
<p>综上，这是一种理论可行的、从实现方式上看较为原生的（raw）方案，但并不现实。</p>
<h2 id="Develop-with-API-Driver-Finally-Choosed"><a href="#Develop-with-API-Driver-Finally-Choosed" class="headerlink" title="Develop with API Driver (Finally Choosed)"></a>Develop with API Driver (Finally Choosed)</h2><p>关于mattermost的API，除了webapp可以直接访问外，如<a href="https://api.mattermost.com/#tag/introduction">官方文档</a>所描述的，有多种语言的Driver可供开发者使用。使用特定的Driver可以连接server，认证完成后可通过定义好的API调用来实现对应的功能，即可通过API完成第三方应用的开发。</p>
<p>最终选择了Python的<a href="https://github.com/Vaelor/python-mattermost-driver">Driver</a>，感谢作者<a href="https://github.com/Vaelor">@Vaelor</a>。</p>
<p>项目地址：<a href="https://github.com/Martzki/Mattermost-Tools">Mattermost-Tools</a>。</p>
<h3 id="Design-Overview"><a href="#Design-Overview" class="headerlink" title="Design Overview"></a>Design Overview</h3><p>为了完成自动回复的功能，有几个子功能需要实现：</p>
<ul>
<li>Connect to Server：API调用、消息获取等功能都需要在连接到server并完成认证的前提下才能实现；</li>
<li>Events Handle：获取server推送的event，处理处理消息类型的event，在满足自动回复的条件后，调用自动回复的功能；</li>
<li>Auto Reply：依据用户配置，对消息进行自动回复，也是核心功能；</li>
<li>Config Update：自动回复相关的用户配置的更新；</li>
<li>GUI：用户友好的配置交互功能，可在运行过程中动态变更用户配置。</li>
</ul>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/overview.drawio.png" width="70%" height="70%" alt="Overview">

<h3 id="Connect-to-Server"><a href="#Connect-to-Server" class="headerlink" title="Connect to Server"></a>Connect to Server</h3><p>首先就是连接到Server，API提供了WebSocket对应的接口，可以通过用户名密码/Token的方式连接server，认证成功后即可通过WebSocket获取服务端推送的消息，以及调用对应的服务端API。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/connect to server.drawio.png" width="70%" height="70%" alt="Connect to Server">

<h3 id="Event-Handle"><a href="#Event-Handle" class="headerlink" title="Event Handle"></a>Event Handle</h3><p>WebSocket连接后，接收server推送的event，再依据具体业务逻辑选择不同的event处理方式。</p>
<p>这套event机制实际上提供了一个方便的功能开发的框架，对应的功能注册对特定event的handler，当event触发后，调用注册的所有handler即可实现不同的功能。不过目前只有一个自动回复的功能，或者说自动回复只是一个特定的post类型的event handler。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/event handle process.drawio.png" width="70%" height="70%" alt="Event Handle">

<h3 id="Auto-Reply"><a href="#Auto-Reply" class="headerlink" title="Auto Reply"></a>Auto Reply</h3><p>对自动回复而言，只需关注post类型的event即可，完整的event类型参考<a href="https://api.mattermost.com/#tag/WebSocket">API文档</a>。通过对post类型的event注册handler，在event触发后调用对应的实现逻辑完成自动回复功能。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/event handler.drawio.png" width="70%" height="70%" alt="Post Event Handle">

<p>目前对自动回复功能的设计，有如下功能：</p>
<ul>
<li>仅限私聊：通过判断post所在channel中的人数来确定当前post是否是一条私聊消息；</li>
<li>自动回复间隔：减少自动回复的频率，记录每一个会话的自动回复历史，在自动回复间隔期间的多次消息接收不会触发多次自动回复；</li>
<li>自动回复间隔调整：在接收到特定消息后，调整下一次自动回复的间隔为一个预设值，用于延长自动回复间隔。</li>
</ul>
<p>于是，在收到私聊消息，且当前时间与上一次自动回复的间隔时间大于用户配置的自动回复间隔后，触发自动回复的条件，通过API将用户预设好的自动回复消息发送到对应的channel。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/auto reply handler.drawio.png" width="70%" height="70%" alt="Auto Reply Handler">

<p><strong>ps.</strong> mattermost中，如果用户在接收到未读post的channel中发送了新的post，将会把之前的未读状态清除，体现在webapp上就是未读提示被清除了。所以自动回复的post发送后，需要将原来的未读post状态重新设置为未读，避免丢失了用户的未读消息提醒。</p>
<h3 id="Config-Update"><a href="#Config-Update" class="headerlink" title="Config Update"></a>Config Update</h3><p>在自动回复功能中，提供了一些可供用户配置的选项。在实际使用的过程中，用户可能会需要动态的调整配置，最常见的就是调整自动回复的内容。为了避免每一次的配置调整都需要重启程序，设计了配置的更新的功能：</p>
<ol>
<li>建立一个缓存用于接收新的用户配置；</li>
<li>每一次自动回复即将触发时检查缓存，是否有新的用户配置下发，如果有，则先更新配置再进行后续的自动回复；</li>
<li>更新配置时只更新合法存在的字段，跳过对非法字段的更新。</li>
</ol>
<p>使用缓存的目的是为了避免锁的使用，配置涉及多个字段，无法做到原子更新。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/config update.drawio.png" width="70%" height="70%" alt="Config Update">

<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><blockquote>
<p>命令行又不是不能用！</p>
</blockquote>
<p>用户肯定都希望应用是简单易用的，并不是所有人都会使用，或者能接受仅支持命令行的工具的，为此需要为用户提供一个GUI用于交互。</p>
<p>对桌面用户而言，提供GUI，最开始想到的是开发一个桌面应用程序。虽然Python确实有对应的开发包，如<a href="">PyQt</a>、<a href="">Tkinter</a>等，但直接开发桌面应用程序总是有一些各种各样的弊端：</p>
<ul>
<li>开发工具的使用：使用这些对应的开发包有着对应的学习成本，根据我的Qt使用经验而言，Qt的安装十分臃肿，PyQt应该也好不到哪去；</li>
<li>丑：没什么好说的；</li>
<li>前后端耦合：这个其实是我个人的原因，开发GUI时，使用对应语言的GUI工具，总是将前后端代码耦合在一块，不利于扩展。</li>
</ul>
<p>所以，虽然后端是Python，前端未必需要直接使用Python开发。换句话说，你的桌面应用程序，又何必一定是一个桌面应用程序呢？mattermost本身就是一个很好的例子，桌面客户端仅仅是web浏览器内核的一个封装，这种前后端分离的好处是后端可以提供相同的接口，前端可以依靠自身特点去实现，避免了耦合。</p>
<p>所以最终的实现上，使用Python实现了一个web服务器，再使用HTML编写了一个页面用于交互，套用了一些CSS模板后，交互效果还不错。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/web console.png" width="70%" height="70%" alt="Web Console">

<p>除了用户登陆、配置更新等交互，还有一点是，用户如何运行web服务器，如果还是直接通过命令行执行Python的方式，多少还是有点捞。为此，使用<a href="https://github.com/pyinstaller/pyinstaller">PyInstaller</a>将脚本、资源文件和解释器封装成一个可执行文件，并为其设置了一个图标，这样一来用户可以通过直接运行可执行文件的方式去运行工具（不过PyInstaller打包时会依赖一些平台特定的动态库，这部分不是很通用，不同的操作系统上可能需要重新打包）。</p>
<p>同时还使用了<a href="https://github.com/moses-palmer/pystray">PyStray</a>为工具创建了一个托盘图标，用户可以通过点击图标的方式打开web页面进行交互，同时可以通过图标来退出程序。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/tray.png" width="70%" height="70%" alt="Tray Icon">

<h3 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h3><ul>
<li>群聊的自动回复：在群聊收到的post中，依据特定的触发词，如@，触发自动回复；</li>
<li>内存清理：目前为每一个触发过自动回复的channel创建一条记录，每触发一次自动回复将会更新其中的最后一次自动回复的时间。理论上最糟糕的场景是，一直有新的私聊触发自动回复，且触发自动回复后，不再有任何消息。这会导致记录一直增长得不到释放，所以需要有机制去清理理论上可能无限增长的内存记录；</li>
<li>优化自动回复条件：目前使用自动回复间隔来判断是否符合自动回复的条件，但其实可以使用当前channel的历史最后一条post的时间来判断，这样可以减少一定的内存使用，同时将用户自己发出的消息，也加入判断条件中，避免了用户主动发送消息，同时收到回复后，在自动回复间隔满足条件的情况下自动回复的场景（这种主动发起会话，在回复间隔符合条件时也不应该自动回复）；</li>
<li>进程退出的资源回收：目前功能单一，不进行资源回收也没有太大问题，不过合理的代码应该要做好资源回收再退出程序，避免后续因为功能扩展，退出时需要回收资源的时候重新处理；</li>
<li>UI代码优化：精简一些无用的CSS引用。</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>For Fun</tag>
      </tags>
  </entry>
  <entry>
    <title>Travels of Martzki: Travel in Hangzhou in 2021</title>
    <url>/2022/02/07/Travel-in-Hangzhou-in-2021/</url>
    <content><![CDATA[<p>2021年的清明节假期，是我的第一次杭州旅行。一是想体验下杭州的清明时节，欣赏下西湖美景；二是亲身感受下杭州作为一线IT城市的氛围。  </p>
<span id="more"></span>
<h1 id="住"><a href="#住" class="headerlink" title="住"></a>住</h1><p>由于假期比较短，所以选择了住在西湖附近。其实最初想选择湖边的酒店或者民宿，不过由于预订的时间和💰的问题，最后选择了南高峰附近的民宿。<br>事后觉得住在西湖附近的决定是正确的，一是本身假期短，主要游玩的地方也是西湖，距离会近一些；二是节假日的杭州，交通真是太堵了，特别是西湖景区附近，打车非常困难。</p>
<h1 id="行"><a href="#行" class="headerlink" title="行"></a>行</h1><p>出行方式主要是打车和公共交通为主。<br>杭州有地铁，但西湖景区附近没有。西湖景区附近，出行方式的便捷度：步行 &gt; 共享单车 &gt; 公交车 &gt; 打车。<br>从我们在西湖景区附近打车的经验来看，较早或较晚的时候还是可以打到车的，但是白天，特别是午晚餐时间，打车十分困难，这个时间点主要选择步行或共享单车，不过高峰期共享单车也是一车难求。<br>PS 杭州的出租车属于比较老旧的燃油汽车，乘坐体验比较差，电动车的普及率比较低。</p>
<h1 id="玩"><a href="#玩" class="headerlink" title="玩"></a>玩</h1><p>西湖附近的主要游玩景点就是“西湖十景”，虽然通常这些官方推荐的景点质量良莠不齐，但西湖附近的游玩基本离不开这些景点。<br>湖边游览的顺序基本上是断桥出发，一路游览景色走到苏堤。</p>
<h2 id="雷峰塔"><a href="#雷峰塔" class="headerlink" title="雷峰塔"></a>雷峰塔</h2><p>西湖十景之一雷峰夕照中的雷峰，指的就是雷峰塔，同时也是白蛇传中白娘子被镇压的宝塔。<br>但实际上，这是一个我个人不推荐的景点。<br>首先，目前的雷峰塔经历了重建，最初的雷峰塔的断壁残垣，保留在目前的雷峰塔的底层，可供游客远程观赏，不过也就是一些砖块罢了；<br>其次，西湖十景的雷峰夕照，指的是夕阳西下时，阳光照在西湖和雷峰塔附近的景色。雷峰塔本身，塔内景色非常普通，登到最高层，可以眺望西湖，不过景色一般（和在黄鹤楼上眺望长江差不多一个意思）；<br>最后，还是人多😑。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_2048.jpeg" width="70%" height="70%" alt="雷峰塔中的白蛇传木雕"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1502.jpeg" width="70%" height="70%" alt="雷峰塔"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_7644.jpeg" width="70%" height="70%" alt="雷峰塔上眺望的西湖景色"></p>
<h2 id="断桥"><a href="#断桥" class="headerlink" title="断桥"></a>断桥</h2><p>西湖十景之一的断桥残雪中的断桥，是我们的西湖游览行程的起点，同样也是许多人的起点，所以人很多，如果想要拍照的话，可以选择早一点过去。<br>不过清明假期杭州最低气温只有十度左右，清晨的湖边，特别是阴天，还是非常冷的，需要做好一定的御寒准备。<br>此外，白堤连接着锦带桥和断桥，在桥上拍照时如果断桥人多可以考虑在锦带桥代替下🤡。  </p>
<h2 id="西湖自划船"><a href="#西湖自划船" class="headerlink" title="西湖自划船"></a>西湖自划船</h2><p>西湖边有多个划船的停泊点，需要注意的是至少需要两个人，同时受湖中风浪影响，风浪过大时，是不允许划船的。如果一定要划船的话，需要提前做好准备。</p>
<h2 id="三潭映月"><a href="#三潭映月" class="headerlink" title="三潭映月"></a>三潭映月</h2><p>西湖十景之一，1元人民币背面取景地，位于西湖中央的湖中岛。上下岛需要从西湖边坐船，有多个码头，可以从不同的码头上下。<br>虽然节假日的杭州哪里都人多，但湖中岛的人格外的多，因为岛上面积不大，离开岛也需要排队坐船，所以导致离岛的队伍很长，上岛容易离岛难。<br>本身景点主要是岛上的一些建筑和湖中的三个石塔，景点本身差强人意，但人实在是太多，和人群摩肩接踵大大降低了游览的兴致。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6158.jpeg" width="70%" height="70%" alt="三潭映月中的湖中石塔和雷峰塔"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1452.jpeg" width="70%" height="70%" alt="岛内景色（一）"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1295.jpeg" width="70%" height="70%" alt="岛内景色（二）"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1913.jpeg" width="70%" height="70%" alt="岛内景色（三）"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6983.jpeg" width="70%" height="70%" alt="岛上码头排队的游客"></p>
<h2 id="灵隐寺"><a href="#灵隐寺" class="headerlink" title="灵隐寺"></a>灵隐寺</h2><p>灵隐寺是西湖景区的比较有名的寺庙了，寺庙本身不小，依山而建。不过我本人对寺庙相关的宗教文化不感冒，并且由于我们去的时候几乎已经走了一天了，随便看了看我就歇菜了🤡，并没有去到最高的庙宇。<br>如果对宗教文化比较感兴趣，或者喜欢到处打卡的话，可以一去；如果像我一样的话就不建议去了。<br>另外，在灵隐寺可以乘坐索道去北高峰，但是索道开放时间有限制，且北高峰不属于灵隐寺的范围，可根据个人情况选择。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6106.jpeg" width="70%" height="70%" alt="灵隐寺"></p>
<h2 id="杨公堤"><a href="#杨公堤" class="headerlink" title="杨公堤"></a>杨公堤</h2><p>杨公堤说是和苏堤白堤齐名，但实际上游客比热门的那些景点要少多了，我们去的时候甚至没有什么人。这里的树林环境很好，很放松，时间不急的话可以来这里散散步。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1974.jpeg" width="70%" height="70%" alt="杨公堤湖边"></p>
<h2 id="九溪十八涧"><a href="#九溪十八涧" class="headerlink" title="九溪十八涧"></a>九溪十八涧</h2><p>九溪十八涧是一条漫长的山路，一路上围绕着高耸的树林，时不时的还有一些茶园，路过村落时各家各户也在售卖自家的茶叶。随着交错的溪涧，从龙井一路下山，最终可以直接到达钱塘江边，虽然不在西湖边，不过是一个是一个散步的好地方，游客也不多，同时尽管整个景区有着不计其数的溪涧，得益于景区的工作人员的垃圾打捞，水很干净。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6103.jpeg" width="70%" height="70%" alt="九溪十八涧"></p>
<h2 id="茶叶博物馆"><a href="#茶叶博物馆" class="headerlink" title="茶叶博物馆"></a>茶叶博物馆</h2><p>茶叶博物馆最初是在行程计划之中的，后来由于时间紧迫，原本不打算去了，但我们在乘坐公交车时，错误地提前了一站下车。不过没想到下车以后发现了一大片茶园，仔细一看居然就是之前计划去的茶叶博物馆。<br>我们到达的时候已经是晚饭时间了，整个茶园几乎没什么人，非常适合拍照。关于博物馆内部，由于是节假日，同时也到了晚饭时间，就没有进去游览了。如果对博物馆内部有兴趣，可以提前咨询下开放时间。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_2259.jpeg" width="70%" height="70%" alt="茶叶博物馆的茶园"></p>
<h1 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h1><p>在杭州吃了几顿杭帮菜，通常都有东坡肉、龙井秋葵什么的，最不推荐的就是西湖醋鱼，这玩意应该99%的人都不会觉得好吃。<br>杭州有一些全国连锁的杭帮菜的总店，像绿茶和外婆家，如果喜欢这些餐厅也可以去试试它们的总店。</p>
<h2 id="河坊街"><a href="#河坊街" class="headerlink" title="河坊街"></a>河坊街</h2><p>河坊街没什么说的，就是那种每个旅游城市都会有的那种充斥着义乌小商品、坑一波外地游客就走的商业街，类似武汉的户部巷，极不推荐。</p>
<h2 id="春夏秋冬"><a href="#春夏秋冬" class="headerlink" title="春夏秋冬"></a>春夏秋冬</h2><p>去这家餐厅其实是一个巧合，我们当时在茶叶博物馆游览完成后，准备前往民宿老板推荐的一家杭帮菜馆——茶人村，但到了餐厅发现排队非常夸张，还有很多旅游大巴也带着游客在这里就餐。虽然餐厅装修上有一定的特色，但整个餐厅有一股浓浓的网红风，加上过长的等待时间，我们就换到了隔壁的春夏秋冬。<br>餐厅的环境不错，菜式也比较有特色（照片不知道咋的没了🤡），还有室外餐位，不过当时杭州的天气还是比较凉的，也没有人选择室外就餐。整体的服务质量也还不错，最重要的是不怎么需要排队。</p>
<h2 id="Doux-Amour"><a href="#Doux-Amour" class="headerlink" title="Doux Amour"></a>Doux Amour</h2><p>这家其实不是杭帮菜，而是一家网红的动物泡芙店，<a href="https://www.douxamour.com.au/">总店</a>应该是在澳洲，国内似乎只有杭州有分店。<br>店里的所有泡芙都是小动物造型，非常可爱。但是泡芙本身由于保质期问题，不太适合当作伴手礼，去吃个下午茶拍拍照片还是不错的。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6276.jpeg" width="70%" height="70%" alt="Doux Amour的菜单"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6272.jpeg" width="70%" height="70%" alt="Doux Amour的动物泡芙"></p>
<h2 id="国宾馆紫薇厅"><a href="#国宾馆紫薇厅" class="headerlink" title="国宾馆紫薇厅"></a>国宾馆紫薇厅</h2><p>知乎上看到的推荐，原文中提到知道的人少，去的人不多，不过这些年估计各种安利种草后，看到推荐慕名而去的人也不少了。<br>紫薇厅不接受预订，开放时间应该是下午四点。我们在四点左右到达紫薇厅门口，被告知已经人满了不再接待，不知道是真满了还是被大佬们预定了🤡，有兴趣的话可以试一试。</p>
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtio feature negotiation from QEMU perspective</title>
    <url>/2022/02/06/Virtio-feature-negotiation-from-QEMU-perspective/</url>
    <content><![CDATA[<h1 id="QEMU中的Virtio-features协商流程"><a href="#QEMU中的Virtio-features协商流程" class="headerlink" title="QEMU中的Virtio features协商流程"></a>QEMU中的Virtio features协商流程</h1><p>下面以virtio-net对接vhost-net（kernel）为例，分析整个Virtio features协商的过程。</p>
<h2 id="vhost-net"><a href="#vhost-net" class="headerlink" title="vhost-net"></a>vhost-net</h2><p>vhost_net作为描述后端的数据结构，与真正使用的后端（vhost_user or vhost_net）对应。<br>每个vhost_net包含一个vhost_dev，vhost_net的features实际就是vhost_dev的features，与features相关的成员有：<code>features</code>，<code>acked_features</code>，<code>backend_features</code>和<code>protocol_features</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_net</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> <span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> <span class="title">vqs</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> backend;</span><br><span class="line">    NetClientState *nc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> &#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> features;</span><br><span class="line">    <span class="keyword">uint64_t</span> acked_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> protocol_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="vhost-dev-features"><a href="#vhost-dev-features" class="headerlink" title="vhost_dev::features"></a>vhost_dev::features</h3><p>在<code>vhost_dev_init</code>中，通过后端对应的接口（ioctl or unix socket），从后端获取到的后端支持的features。</p>
<h3 id="vhost-dev-acked-features"><a href="#vhost-dev-acked-features" class="headerlink" title="vhost_dev::acked_features"></a>vhost_dev::acked_features</h3><p>前端依据从后端获取的host features进行协商，协商完成后真正向后端传递的features（过滤了后端不支持的features），即后端真正工作的features。</p>
<h3 id="vhost-dev-backend-features"><a href="#vhost-dev-backend-features" class="headerlink" title="vhost_dev::backend_features"></a>vhost_dev::backend_features</h3><p>从命名看是描述后端的features，但和features字段重复。vhost-net相关的实际代码调用如下：</p>
<ol>
<li>vhost_net_ack_features: 在设置acked_features之前，用backend_features的值为acked_features初始化。这里acked_features为何不初始化为0，从QEMU开发者的邮件讨论看，之前在初始化0时，acked_features在在某些情况下会被初始化为unexpected value（This will result an unexpected value of acked_features which may fail the features setting of vhost.）。不过初始化为backend_features似乎在vdpa的场景下有新的问题，且问题仍然open中；<a href="https://bugs.launchpad.net/qemu/+bug/1924603">^1</a></li>
<li>vhost_net_init: 在后端为vhost-net的条件下，如果后端对应的tap设备不支持vnet_hdr，则backend_features中的<code>VHOST_NET_F_VIRTIO_NET_HDR</code>被置位，否则为0；</li>
<li>vhost_user_backend_init: 在后端为vhost-user的条件下，如果后端支持<code>VHOST_USER_F_PROTOCOL_FEATURES</code>，则backend_features中的<code>VHOST_USER_F_PROTOCOL_FEATURES</code>被置位。</li>
</ol>
<p>此外，内核vhost代码中定义了<code>VHOST_NET_BACKEND_FEATURES</code>，对应的ioctl操作为<code>VHOST_GET_BACKEND_FEATURES</code>和<code>VHOST_SET_BACKEND_FEATURES</code>，不过目前QEMU代码中没有这两个ioctl操作对应的逻辑。</p>
<h3 id="vhost-dev-protocol-features"><a href="#vhost-dev-protocol-features" class="headerlink" title="vhost_dev::protocol_features"></a>vhost_dev::protocol_features</h3><p>协议的扩展features。为了保持向下兼容性，vhost-user协议新增的features使用protocol_features进行描述，由<code>VHOST_USER_F_PROTOCOL_FEATURES</code>进行控制，标识protocol_features是否使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VHOST_USER_F_PROTOCOL_FEATURES 30</span></span><br></pre></td></tr></table></figure>
<p>在vhost-net场景下，protocol_features被设置为0。</p>
<h2 id="virtio-net"><a href="#virtio-net" class="headerlink" title="virtio-net"></a>virtio-net</h2><p>virtio-net作为描述后端的数据结构，与Guest的前端驱动（virtio_net）对应。在QEMU中，用VirtIONet来描述virtio-net，每个VirtIONet结构中包含了其对应的VirtIODevice。其中与features有关的成员有：VirtIONet的<code>host_features</code>，VirtIODevice的<code>guest_features</code>，<code>host_features</code>和<code>backend_features</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtIONet</span> &#123;</span></span><br><span class="line">    VirtIODevice parent_obj;</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> host_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtIODevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> guest_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> host_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="VirtIONet-host-features"><a href="#VirtIONet-host-features" class="headerlink" title="VirtIONet::host_features"></a>VirtIONet::host_features</h3><p>从virtio设备的角度来看，只区分Guest与Host，并不关心Host的具体实现。所以VirtIONet::host_features代表了Host理论可以支持的所有features。</p>
<p>VirtIONet::host_features在<code>virtio_net_class_init</code>中使用QEMU中virtio-net设备的默认属性<code>virtio_net_properties</code>（其中包含了offload相关的features）来初始化，同时在每个virtio-net设备实例化时，依据后端设备（e.g. tap）的配置，对部分features进行设置。</p>
<p>VirtIONet::host_features唯一的调用处在<code>virtio_net_get_features</code>，即响应Guest前端驱动的get_features请求，VirtIONet::host_features作为初始值，在一系列的过滤动作后，向前端返回Host所支持的features（细节见下文）。</p>
<h3 id="VirtIODevice-host-features"><a href="#VirtIODevice-host-features" class="headerlink" title="VirtIODevice::host_features"></a>VirtIODevice::host_features</h3><p>VirtIODevice::host_features在<code>virtio_bus_device_plugged</code>中调用对应virtio设备的get_features进行初始化，保存的是get_features的返回值，即真正返回给前端驱动的features。</p>
<p><code>virtio_net_get_features</code>向前端返回features的逻辑如下：</p>
<ol>
<li>VirtIONet::host_features作为初始features；</li>
<li>如果后端设备（e.g. tap）不支持vnet_hdr，则将features中对应的offload features取消置位；</li>
<li>QEMU内部预定义了后端支持的feature_bits（kernel_feature_bits or user_feature_bits），将feature_bits支持但vhost_dev::features中不支持的bit在features中取消置位；</li>
<li>对<code>VIRTIO_NET_F_MTU</code>进行特殊处理（和<code>mtu_bypass_backend</code>有关，对整体协商流程不重要）；</li>
<li>将上述流程中处理后的features返回给前端驱动。</li>
</ol>
<p>要注意VirtIODevice::host_features和VirtIONet::host_features的区别，VirtIONet::host_features是Host理论可以支持的所有features，而VirtIODevice::host_features是对VirtIONet::host_features中依据后端、设备的设置进行处理后，真正返回给前端驱动的features。</p>
<h3 id="VirtIODevice-guest-features"><a href="#VirtIODevice-guest-features" class="headerlink" title="VirtIODevice::guest_features"></a>VirtIODevice::guest_features</h3><p>Guest前端驱动用自身features和get_features得到的VirtIODevice::host_features进行协商后，传递给QEMU，与VirtIODevice::host_features取交集，保存得到guest_features。即前后端在Guest协商后得到的features。</p>
<h3 id="VirtIODevice-backend-features"><a href="#VirtIODevice-backend-features" class="headerlink" title="VirtIODevice::backend_features"></a>VirtIODevice::backend_features</h3><p>看代码调用是为了特殊处理<code>mtu_bypass_backend</code>保存的，在<code>virtio_net_get_features</code>处理流程中，特殊处理<code>VIRTIO_NET_F_MTU</code>前保存的features，除了<code>VIRTIO_NET_F_MTU</code>和VirtIODevice::host_features有差异外，其他一致。</p>
<h2 id="QEMU正常启动流程中的features协商"><a href="#QEMU正常启动流程中的features协商" class="headerlink" title="QEMU正常启动流程中的features协商"></a>QEMU正常启动流程中的features协商</h2><p>QEMU正常启动流程中，从开始运行到GuestOS启动的RunState的变化：<code>preconfig</code>-&gt;<code>prelaunch</code>-&gt;<code>running</code>。</p>
<p>上述RunState变化过程中，virtio设备的features相关流程如下：</p>
<ol>
<li>preconfig: <code>qemu_init</code>-&gt;<code>net_init_clients</code>-&gt;……-&gt;<code>net_init_tap</code>-&gt;……-&gt;<code>vhost_net_init</code>，初始化tap和vhost_dev。其中vhost_dev初始化时，调用后端对应的接口，获取后端支持的所有features，用来初始化<code>vhost_dev::features</code>，同时依据对端设备（tap）支持的特性，初始化<code>vhost_dev::backend_features</code>，以及初始化<code>vhost_dev::protocol_features</code>为0；</li>
<li>prelaunch: 调用<code>virtio_bus_device_plugged</code>，通过对应设备类型的get_features，初始化<code>VirtIODevice::host_features</code>；</li>
<li>running: <ul>
<li>GuestOS启动，内部virtio_net驱动被加载，调用<code>virtio_dev_probe</code>-&gt;……-&gt;<code>vp_get_features</code>获取设备的features，即QEMU侧的<code>VirtIODevice::host_features</code>，再与自身驱动支持的features进行协商，协商完成后调用<code>virtio_finalize_features</code>-&gt;……-&gt;<code>vp_set_features</code>将协商好的features传给QEMU；</li>
<li>此时发生VM-EXIT，QEMU侧调用<code>virtio_set_features</code>-&gt;……-&gt;<code>virtio_net_set_features</code>-&gt;……-&gt;<code>vhost_ack_features</code>，把前端驱动传递过来的features和后端对应feature_bits共同支持的bit置位，将结果保存在<code>vhost_dev::acked_features</code>；</li>
<li>GuestOS中<code>virtio_finalize_features</code>-&gt;……-&gt;<code>vp_set_features</code>执行完成后，会设置<code>VIRTIO_CONFIG_S_FEATURES_OK</code>，进而触发QEMU侧的对应调用<code>virtio_set_status</code>-&gt;……-&gt;<code>vhost_dev_start</code>。在<code>vhost_dev_start</code>中，调用<code>vhost_dev_set_features</code>，将前端协商好的<code>vhost_dev::acked_features</code>通过后端对应的接口传递到后端。</li>
</ul>
</li>
</ol>
<h2 id="QEMU热迁移流程中的features协商"><a href="#QEMU热迁移流程中的features协商" class="headerlink" title="QEMU热迁移流程中的features协商"></a>QEMU热迁移流程中的features协商</h2><p>QEMU热迁移流程中，源虚拟机从开始运行到迁移结束的RunState变化：<code>running</code>-&gt;<code>finish_migrate</code>-&gt;<code>postmigrate</code>；目的虚拟机从开始运行到GuestOS启动的RunState的变化：<code>preconfig</code>-&gt;<code>inmigrate</code>-&gt;<code>running</code>。</p>
<h3 id="源端virtio-features在热迁移流程中的变化"><a href="#源端virtio-features在热迁移流程中的变化" class="headerlink" title="源端virtio features在热迁移流程中的变化"></a>源端virtio features在热迁移流程中的变化</h3><ol>
<li>running: 正常运行状态，无相关操作；</li>
<li>finish_migrate: <code>virtio_save</code>中保存<code>VirtIODevice::guest_features</code>的低32bit，迁移到目的端。</li>
</ol>
<h3 id="目的端virtio-features在热迁移流程中的变化"><a href="#目的端virtio-features在热迁移流程中的变化" class="headerlink" title="目的端virtio features在热迁移流程中的变化"></a>目的端virtio features在热迁移流程中的变化</h3><ol>
<li>preconfig: 和正常启动流程一致；</li>
<li>inmigrate: <ul>
<li>调用<code>virtio_bus_device_plugged</code>，通过对应设备类型的get_features，初始化<code>VirtIODevice::host_features</code>；</li>
<li><code>virtio_load</code>-&gt;……-&gt;<code>virtio_net_set_features</code>-&gt;……-&gt;<code>vhost_ack_features</code>，在<code>virtio_load</code>中接收源端协商完成的<code>VirtIODevice::guest_features</code>，在<code>vhost_ack_features</code>中将接收到的<code>VirtIODevice::guest_features</code>和后端对应feature_bits共同支持的bit置位，将结果保存在<code>vhost_dev::acked_features</code>；</li>
</ul>
</li>
<li>running: <code>qemu_main_loop</code>-&gt;<code>main_loop_wait</code>-&gt;……-&gt;<code>vm_start</code>-&gt;……-&gt;<code>virtio_set_features</code>，使用inmigrate过程中设置好的<code>vhost_net::acked_features</code>通过后端对应的接口传递到后端。</li>
</ol>
<h2 id="正常启动流程和热迁移流程对比"><a href="#正常启动流程和热迁移流程对比" class="headerlink" title="正常启动流程和热迁移流程对比"></a>正常启动流程和热迁移流程对比</h2><p>硬件设备的初始化流程都一致，除了PCI设备的一些状态也是通过迁移初始化之外，最主要的区别在于热迁移流程中的features协商过程：协商必须的<code>VirtIODevice::guest_features</code>通过热迁移从源端获取，后端直接和QEMU进行协商流程；协商流程控制不再需要前端驱动修改设备status，而是在QEMU热迁移流程中触发。前端驱动不参与、不感知，避免了重新初始化。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
        <tag>Virtio/Vhost</tag>
      </tags>
  </entry>
  <entry>
    <title>Some attempts to connect to VDI</title>
    <url>/2022/02/06/Some-attempts-to-connect-to-VDI/</url>
    <content><![CDATA[<h1 id="Why-do-I-need-to-do-this"><a href="#Why-do-I-need-to-do-this" class="headerlink" title="Why do I need to do this"></a>Why do I need to do this</h1><p>公司提供VDI作为办公环境，远程办公时，需要通过VPN先连接到公司内网，再从内网连接到办公VDI。<br>公司提供了Mac和Windows的VPN客户端用于连接到内网，按理说安装并使用公司提供的客户端连接内网即可，但是之所以没有这么做有两个主要原因：    </p>
<ul>
<li>公司提供的VPN配套的软件太过臃肿；</li>
<li>公司提供的VDI内置了访问控制软件，会记录IM的聊天记录等信息。担心VPN“附赠”的软件或者VPN本身会做类似的操作🙄。</li>
</ul>
<p>这篇博文主要记录下折腾虚拟桌面环境的一些经历。</p>
<span id="more"></span>

<h1 id="What-attempts-did-I-try"><a href="#What-attempts-did-I-try" class="headerlink" title="What attempts did I try"></a>What attempts did I try</h1><p>由于上面说的原因，需要在个人PC环境之外，提供一个桌面环境用于远程连接到VDI。<br>再去配置一套物理桌面环境显然是不现实的，所以主要向虚拟桌面环境考虑：</p>
<ul>
<li>Windows Sandbox</li>
<li>Cloud Virtual Mechine</li>
<li>Reverse Proxy (frp)</li>
<li>MacOS Container</li>
</ul>
<h2 id="Windows-Sandbox"><a href="#Windows-Sandbox" class="headerlink" title="Windows Sandbox"></a>Windows Sandbox</h2><p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-sandbox/windows-sandbox-overview">Windows Sandbox</a>是一个非常好的选择，它是Windows内置的虚拟化技术，在Windows 10的专业/企业版中打开选项后可以直接启动。<br>该技术和通用的虚拟化技术一样，对CPU的虚拟化特性也有一定要求，不过不是太老的CPU应该都能够满足要求。在我个人的移动端4代i7、8G内存的PC上，Windows 10和Windows 11中，Windows Sandbox都有足够好的表现。因为它只是虚拟了一套运行环境（runtime environment），应该是WIndows自己的容器化技术。相比于直接运行一个虚拟机而言，轻量的多，同时它还支持GPU虚拟化，从实际使用体验上来看，Sandbox的启停都足够快，同时图形性能对于基本办公足够使用了。<br>但它有个明显的弊端：所有在Sandbox中所做修改都不会被保存，将会随Sandbox进程的退出一并被销毁（类似于加了<code>--rm</code>参数的docker容器🤨）。这个特性提供了绝对的Sandbox环境，但和我个人的使用场景上并不是完全契合，每次需要连接VDI时都要全新安装一整套的VPN软件，不过总体来说从使用难度和使用体验上来说，还是相对不错的。<br>没有最终使用这个方案的原因主要是因为我的Windows PC坏了😅。</p>
<h2 id="Cloud-Virtual-Mechine"><a href="#Cloud-Virtual-Mechine" class="headerlink" title="Cloud Virtual Mechine"></a>Cloud Virtual Mechine</h2><p>Windows PC坏了以后，开始转战MacOS。虚拟机是一个常见的能够提供虚拟桌面环境的方式，由于MacOS的软件生态（主要是💰的问题），没有选择直接在MacOS上运行虚拟机，转而考虑公有云提供的虚拟机服务，正好看到腾讯云有轻量应用服务器的优惠，且支持Windows系统，遂马上下单。<br>但当真正使用这个虚拟机时发现，公司提供的VPN客户端不支持在Windows Server安装（垃圾🙃），同时这个轻量应用服务器不支持自行上传镜像安装系统，所以没法直接重装成个人版的Windows。<br>但，买都买了，还是折腾下吧。</p>
<h3 id="Nested-Virtualization"><a href="#Nested-Virtualization" class="headerlink" title="Nested Virtualization"></a>Nested Virtualization</h3><p>第一个尝试是虚拟机，没错，是在1核2G的虚拟机上再跑一个Windows虚拟机。<br>基于如此拉胯的硬件配置，Host必不可能选Windows了，所以重装成了CentOS。然后就是supervisor的选择，工作中用的比较多的是QEMU-KVM，相对比较熟悉了，所以尝试换用Virutal Box。<br>虽然<a href="https://www.virtualbox.org/">Virutal Box</a>是Oracle主导的开源项目，但官网就给人一种贫穷的感觉。它主要运行在桌面环境上，虽然提供了命令行工具VBoxManage，但在命令行环境下仍然需要安装一些如QT相关的依赖库。不幸的是在解决了依赖问题，配置好虚拟机后，仍然无法启动，报错是无法启用硬件加速特性（腾讯云的这个虚拟机不支持嵌套虚拟化），在配置里取消了所有硬件加速的选项后，还是无法解决该问题（MacOS上的Virtual Box也是一堆BUG），无奈只能放弃Virtual Box。<br>于是换用QEMU，直接使用yum安装，使用libvirt进行虚拟机配置，由于不支持嵌套虚拟化，同样没法使用QEMU-KVM，只能通过纯模拟的CPU运行GuestOS，虽然能够运行，但是几乎完全无法正常使用，开机需要15min，开机之后所有的操作都是分钟级别的，就是折腾来玩玩罢了。</p>
<h3 id="Dual-Operation-System"><a href="#Dual-Operation-System" class="headerlink" title="Dual Operation System"></a>Dual Operation System</h3><p>这个配置下的嵌套虚拟化也就图一乐，既然官方给的镜像不包含个人版的Windows，同时也不支持自定义上传镜像，那就采用安装双系统的曲线救国的方式。<br>先使用原有分区的空闲空间创建一个新的分区，再将操作系统镜像下载到硬盘上，直接从硬盘运行安装程序，将操作系统安装到新的分区上。<br>为了在1核2G的拉胯配置上尽可能流畅地运行Windows，使用<a href="https://archive.org/details/Tiny7">Tiny7</a>（精简版的Windows 7）作为使用的操作系统，但镜像内不包含Virtio驱动，无法继续安装。下载了几乎所有版本的Virtio驱动在安装时使用，但全都无法奏效，最后无奈换用了<a href="https://archive.org/details/tiny-10_202105">Tiny10</a>（精简版的Windows 10）。使用Tiny10后，在安装时选择硬盘上已有的Virtio驱动，即可完成正常安装。<br>流畅度上来说和自带的Windows Server相比没有明显差距，在远程连接上VDI后，由于自身配置拉胯，流畅度一般。且由于没有显卡，在需要图形渲染的场景下（如窗口切换），卡顿明显。总的来说属于勉强可用的程度，但好处是无需在自己的PC上运行虚拟机。  </p>
<h3 id="Windows-Container"><a href="#Windows-Container" class="headerlink" title="Windows Container"></a>Windows Container</h3><p><a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/">Windows Container</a>是考虑过的另一个折腾方向，Windows官方提供了<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-base-images">镜像</a>，但在Windows Server安装Docker时，始终有问题无法解决，同时Windows容器只能使用和Host相同的kernel，并且无法提供一个基于容器的桌面环境，遂放弃。</p>
<h2 id="Reverse-Proxy-frp"><a href="#Reverse-Proxy-frp" class="headerlink" title="Reverse Proxy (frp)"></a>Reverse Proxy (frp)</h2><p>使用反向代理（如<a href="https://github.com/fatedier/frp">frp</a>）将Windows远程控制服务暴露到公网也是一个可行方案，但细节上没有那么简单。<br>由于办公VDI是和公网隔离的，所以无法直接使用反向代理直接连接到办公VDI。但公司提供了外网VDI用于在办公时访问公网，可以使用反向代理连接到外网VDI，再在外网VDI中安装运行VPN客户端后反向连接到办公VDI内。<br>这种方案下的外网VDI代替了自购的公有云虚拟机，拥有更高的配置，但同样不支持虚拟显卡，图形性能仍然拉胯。按理说可以替代自购的公有云虚拟机了，但由于安全部门审计到frp流量，告知不允许使用此类反向代理，遂放弃。  </p>
<h2 id="MacOS-Container"><a href="#MacOS-Container" class="headerlink" title="MacOS Container"></a>MacOS Container</h2><p>在考虑虚拟化方案时，觉得虚拟机消耗过大后，很容易想到的就是容器技术。如果使用容器技术能够满足需求，那就能够使用一个轻量化的隔离环境。在我只有MacOS的前提下，开始查找是否有MacOS的容器化方案。<br>幸运的是，还真有个项目<a href="https://github.com/sickcodes/Docker-OSX">Docker-OSX</a>，不幸的是，这个项目基于QEMU-KVM，说白了还是虚拟机那一套，所以也就是看了看而已。</p>
<h1 id="What-did-I-chose-finally"><a href="#What-did-I-chose-finally" class="headerlink" title="What did I chose finally"></a>What did I chose finally</h1><p>由于上述种种原因，最终的使用方案是在公有云自购的虚拟机上安装的双系统中，连接到远程VDI。<br>如果有Windows环境的话，还是推荐使用WIndows Sandbox；MacOS环境下，如果能够容忍虚拟机的性能消耗的话，虚拟机应该是一个比较好的选择。<br>相比之下，在公有云上的拉胯虚拟机中连接到远程VDI的方案并不是什么理想方案了。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2022/01/09/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>God, tell us the reason youth is wasted on the young.</p>
</blockquote>
<p>A coder mainly work on network virtualization dataplane development.<br>Email: <a href="mailto:&#x6d;&#x61;&#x72;&#115;&#x31;&#x34;&#56;&#53;&#48;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#x6d;&#x61;&#x72;&#115;&#x31;&#x34;&#56;&#53;&#48;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p>
<img src="/images/avatar.JPG" width="40%" height="40%">]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
</search>
