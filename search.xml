<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/31/Hello-World/</url>
    <content><![CDATA[<h1 id="About-Hello-World"><a href="#About-Hello-World" class="headerlink" title="About Hello World"></a>About Hello World</h1><ul>
<li>Hello World往往作为很多项目的初始示例程序，我个人把Hello World视为程序员对待“最初”的哲学，所以把它作为这个博客的第一篇博文的标题，用于给这个博客开个头（终于赶在过年前写出来了）。<span id="more"></span></li>
</ul>
<h1 id="About-Lost-Stars"><a href="#About-Lost-Stars" class="headerlink" title="About Lost Stars"></a>About Lost Stars</h1><ul>
<li>Lost Stars是我个人最喜欢的Maroon 5的一首歌，歌词中表现了和“寄蜉蝣于天地，渺沧海之一粟”有着异曲同工之妙的对个体的渺小之感叹，和我个人目前的人生状态较为契合，所以把它作为这个博客的标题；</li>
<li>后续应该主要会发布一些技术相关的主题，主要是作为自己的技术积累和总结，此外应该也会更新一些个人的游记；</li>
<li>你可能是从我的简历或者我的Github主页来到这个博客，请主要关注技术相关的内容🙃；</li>
<li>主页图片使用了之前从Bing首页保存下来的东京塔的照片，我个人很喜欢，如有侵权还请联系我；</li>
<li>博客基于<a href="https://hexo.io/zh-cn/">hexo</a>构建，使用了<a href="https://github.com/Shen-Yu/hexo-theme-ayer">ayer主题</a>，感谢这两个开源项目；</li>
<li>人生不易，随缘更新。</li>
</ul>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>Record of learning AF_XDP</title>
    <url>/2023/01/21/Record-of-learning-AF-XDP/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>近年eBPF技术大火，在网络方向上最火的大概就是cilium和XDP了，前者是一个前景非常广阔的CNI，后者是内核里基于eBPF的一个包处理框架。</p>
<p>关于eBPF或XDP，网上有很多介绍文章，这里不会去详细介绍其基础原理，只记录下学习过程中遇到的问题以及对应代码。</p>
<p><code>AF_XDP</code>是内核基于XDP的一层socket封装，和<code>AF_INET</code>、<code>AF_PACKET</code>一样，是一种协议族，可以直接通过socket相关调用去使用。</p>
<p>XDP相关实现的封装层次从低到高为：<code>eBPF</code>-&gt;<code>XDP</code>-&gt;<code>AF_XDP</code>-&gt;<code>libbpf</code>-&gt;<code>APP</code>。</p>
<p><code>AF_XDP</code>相关的代码主要分为三部分：</p>
<ul>
<li>内核：内核代码中的对应实现，对应代码路径为<code>kernel/net/xdp</code>。</li>
<li>libbpf：eBPF接口的封装库，eBPF编程基本都依赖这个库，一些关键特性，如CO-RE都是基于libbpf实现的，对应代码路径为<code>kernel/tools/lib/bpf/xdp.c</code>。</li>
<li>用户态应用代码：使用<code>AF_XDP</code>的用户态应用代码，内核示例为<code>kernel/samples/bpf/xsock_user.c</code>，作为DPDK开发者，我主要关注DPDK代码中的<code>PMD_AF_XDP</code>相关代码，代码路径为<code>dpdk/drivers/net/af_xdp</code>。</li>
</ul>
<p>关于<code>AF_XDP</code>可以参考<a href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html">内核文档</a>和<a href="https://rexrock.github.io/post/af_xdp1/">AF_XDP技术详解</a>。</p>
<p>本文的代码分析基于DPDK 19.11，内核版本4.18以及内核版本对应的libbpf。</p>
<h1 id="PMD-AF-XDP"><a href="#PMD-AF-XDP" class="headerlink" title="PMD_AF_XDP"></a>PMD_AF_XDP</h1><p><code>PMD_AF_XDP</code>也是一种DPDK提供的PMD，主要用途和<code>PMD_AF_PACKET</code>相同，从内核驱动管理的网卡设备获取报文。由于两者都是利用内核socket提供的机制，所以实现上也比较相似，基本就是先创建对应协议族的socket，然后bind到对应的网口上，再通过<code>send</code>/<code>recv</code>等调用去进行报文收发（<code>AF_XDP</code>在收包时不需要调用<code>recv</code>）。</p>
<p><code>PMD_AF_XDP</code>对应的<code>rte_vdev_driver</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_vdev_driver</span> <span class="title">pmd_af_xdp_drv</span> =</span> &#123;</span><br><span class="line">	.probe = rte_pmd_af_xdp_probe,</span><br><span class="line">	.remove = rte_pmd_af_xdp_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h2><p>所有PMD的初始化流程都一样，调用PMD对应的probe函数，这里是<code>rte_pmd_af_xdp_probe</code>。</p>
<p>参数解析、合法性检查等通用流程就直接跳过了，看完整个probe函数，发现基本上就是赋值pmd相关的通用成员，<code>dev_ops</code>、<code>rx_pkt_burst</code>和<code>tx_pkt_burst</code>等。</p>
<p>probe流程中，值得注意的点为收发包队列数据结构初始化完之后，设置了收发包队列互为pair：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queue_cnt; i++) &#123;</span><br><span class="line">	internals-&gt;tx_queues[i].<span class="built_in">pair</span> = &amp;internals-&gt;rx_queues[i];</span><br><span class="line">	internals-&gt;rx_queues[i].<span class="built_in">pair</span> = &amp;internals-&gt;tx_queues[i];</span><br><span class="line">	internals-&gt;rx_queues[i].xsk_queue_idx = start_queue_idx + i;</span><br><span class="line">	internals-&gt;tx_queues[i].xsk_queue_idx = start_queue_idx + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，其他都是通用流程，这里就有一个疑惑：socket在哪创建的？</p>
<p>既然probe流程没有，那就接着看初始化流程，<code>probe</code>完成后，通常就是<code>configure</code>、<code>queue setup</code>，再接着就是<code>start</code>。</p>
<p>然而<code>configure</code>流程和<code>start</code>实现都很简单，不涉及socket创建：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">eth_dev_start</span><span class="params">(struct rte_eth_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dev-&gt;data-&gt;dev_link.link_status = ETH_LINK_UP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">eth_dev_configure</span><span class="params">(struct rte_eth_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* rx/tx must be paired */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;nb_rx_queues != dev-&gt;data-&gt;nb_tx_queues)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么唯一可能就是在<code>queue setup</code>中。</p>
<h2 id="RX-queue-setup"><a href="#RX-queue-setup" class="headerlink" title="RX queue setup"></a>RX queue setup</h2><p>先看收包队列<code>eth_rx_queue_setup</code>，其中实现很简单，检查了MBUF空间和XDP帧大小是否匹配后调用了<code>xsk_configure</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">xsk_configure</span><span class="params">(struct pmd_internals *internals, struct pkt_rx_queue *rxq,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">int</span> ring_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Init umem. */</span></span><br><span class="line">	rxq-&gt;umem = xdp_umem_configure(internals, rxq);</span><br><span class="line">	<span class="keyword">if</span> (rxq-&gt;umem == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	txq-&gt;umem = rxq-&gt;umem;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Create xsk. */</span></span><br><span class="line">	ret = xsk_socket__create(&amp;rxq-&gt;xsk, internals-&gt;if_name,</span><br><span class="line">			rxq-&gt;xsk_queue_idx, rxq-&gt;umem-&gt;umem, &amp;rxq-&gt;rx,</span><br><span class="line">			&amp;txq-&gt;tx, &amp;cfg);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		AF_XDP_LOG(ERR, <span class="string">&quot;Failed to create xsk socket.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程包含两个部分，初始化<code>umem</code>、创建<code>xsk</code>（AF_XDP socket）。</p>
<h3 id="UMEM"><a href="#UMEM" class="headerlink" title="UMEM"></a>UMEM</h3><p>关于<code>umem</code>官方说明如下：</p>
<blockquote>
<p>UMEM is a region of virtual contiguous memory, divided into equal-sized frames. An UMEM is associated to a netdev and a specific queue id of that netdev. It is created and configured (chunk size, headroom, start address and size) by using the XDP_UMEM_REG setsockopt system call. A UMEM is bound to a netdev and queue id, via the bind() system call.</p>
<p>An AF_XDP is socket linked to a single UMEM, but one UMEM can have multiple AF_XDP sockets. To share an UMEM created via one socket A, the next socket B can do this by setting the XDP_SHARED_UMEM flag in struct sockaddr_xdp member sxdp_flags, and passing the file descriptor of A to struct sockaddr_xdp member sxdp_shared_umem_fd.</p>
<p>The UMEM has two single-producer/single-consumer rings that are used to transfer ownership of UMEM frames between the kernel and the user-space application.</p>
</blockquote>
<p><code>AF_XDP</code>可以通过mmap在用户态和内核态之间传递数据，这块共享内存就是<code>umem</code>。在用户态应用中先初始化好<code>umem</code>，再作为<code>xsk_socket__create</code>的参数传入，在内部完成内核态内存和用户态内存的map。</p>
<p>需要注意的一点是，<code>umem</code>初始化流程中，收发包队列的<code>umem</code>指向的是同样的内存，这样的好处是在收发包队列之间转换时不需要拷贝：</p>
<blockquote>
<p>RX and TX can share the same UMEM so that a packet does not have to be copied between RX and TX. Moreover, if a packet needs to be kept for a while due to a possible retransmit, the descriptor that points to that packet can be changed to point to another and reused right away. This again avoids copying data.</p>
</blockquote>
<p>在<code>PMD_AF_XDP</code>的实现中，每个<code>umem</code>对应了一个<code>buf_ring</code>，用于缓存具体的<code>umem</code>和批量操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct</span></span><br><span class="line"><span class="function">xsk_umem_info *<span class="title">xdp_umem_configure</span><span class="params">(struct pmd_internals *internals,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct pkt_rx_queue *rxq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="built_in">snprintf</span>(ring_name, <span class="keyword">sizeof</span>(ring_name), <span class="string">&quot;af_xdp_ring_%s_%u&quot;</span>,</span><br><span class="line">		       internals-&gt;if_name, rxq-&gt;xsk_queue_idx);</span><br><span class="line">	umem-&gt;buf_ring = rte_ring_create(ring_name,</span><br><span class="line">					 ETH_AF_XDP_NUM_BUFFERS,</span><br><span class="line">					 rte_socket_id(),</span><br><span class="line">					 <span class="number">0x0</span>);</span><br><span class="line">	<span class="keyword">if</span> (umem-&gt;buf_ring == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		AF_XDP_LOG(ERR, <span class="string">&quot;Failed to create rte_ring\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ETH_AF_XDP_NUM_BUFFERS; i++)</span><br><span class="line">		rte_ring_enqueue(umem-&gt;buf_ring,</span><br><span class="line">				 (<span class="keyword">void</span> *)(i * ETH_AF_XDP_FRAME_SIZE));</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>buf_ring</code>的元素个数为<code>ETH_AF_XDP_NUM_BUFFERS</code>，和<code>umem</code>的元素个数是相同的，且初始化为<code>umem</code>元素的偏移，这也是<code>umem</code>的保存形式，需要访问时再通过<code>xsk_umem__get_data</code>获取真正的<code>umem</code>地址。</p>
<h3 id="XSK"><a href="#XSK" class="headerlink" title="XSK"></a>XSK</h3><p><code>umem</code>初始化完成后，就接着调用<code>xsk_socket__create</code>创建<code>xsk</code>，所有<code>xsk_socket__</code>开头的代码，均为<code>libbpf</code>的封装，声明在<code>xsk.h</code>。使用<code>libbpf</code>封装的API大大减少了<code>XDP</code>/<code>eBPF</code>编码的复杂度。</p>
<p>从这个函数可以看出，和<code>AF_PACKET</code>只创建一个socket不同，对<code>AF_XDP</code>而言，每一个收包队列初始化流程中（实际是收发包队列共用）都会创建一个<code>xsk</code>，并且这里需要传入queue id，和<code>AF_PACKET</code>不同，这个queue id对应具体的硬件队列id，这里指定queue id应该就是将具体的<code>XDP</code>/<code>eBPF</code>程序attach到对应队列上的意思。</p>
<p>同时作为参数传入的不仅有rxq，也有rxq，说明收发包队列使用的是同一个xsk，并且同时初始化。</p>
<h2 id="TX-queue-setup"><a href="#TX-queue-setup" class="headerlink" title="TX queue setup"></a>TX queue setup</h2><p>发包队列的初始化非常简单，在上面也说了，收发包队列共用umem和xsk，在收包队列初始化时，已经完成了初始化，所以发包队列的初始化没有任何动作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">eth_tx_queue_setup</span><span class="params">(struct rte_eth_dev *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">uint16_t</span> tx_queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">uint16_t</span> nb_tx_desc __rte_unused,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id __rte_unused,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct rte_eth_txconf *tx_conf __rte_unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pmd_internals</span> *<span class="title">internals</span> =</span> dev-&gt;data-&gt;dev_private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pkt_tx_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line"></span><br><span class="line">	txq = &amp;internals-&gt;tx_queues[tx_queue_id];</span><br><span class="line"></span><br><span class="line">	dev-&gt;data-&gt;tx_queues[tx_queue_id] = txq;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue-change"><a href="#Queue-change" class="headerlink" title="Queue change?"></a>Queue change?</h2><p>从<code>xsk</code>的初始化流程可以看到，每个<code>xsk</code>对应了一个网卡的硬件队列，那么当<code>XDP</code>程序已经attach到对应网卡队列后，再调整网卡队列数，会发生什么呢？</p>
<p>以<code>ethtool</code>调整队列数的代码<code>ethtool_set_channels</code>为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline_for_stack <span class="keyword">int</span> <span class="title">ethtool_set_channels</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">						   <span class="keyword">void</span> __user *useraddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Disabling channels, query zero-copy AF_XDP sockets */</span></span><br><span class="line">	from_channel = channels.combined_count +</span><br><span class="line">		min(channels.rx_count, channels.tx_count);</span><br><span class="line">	to_channel = curr.combined_count + max(curr.rx_count, curr.tx_count);</span><br><span class="line">	<span class="keyword">for</span> (i = from_channel; i &lt; to_channel; i++)</span><br><span class="line">		<span class="keyword">if</span> (xdp_get_umem_from_qid(dev, i))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;ethtool_ops-&gt;set_channels(dev, &amp;channels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到针对待调整的队列，调用了<code>xdp_get_umem_from_qid</code>进行检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct xdp_umem *<span class="title">xdp_get_umem_from_qid</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">				       u16 queue_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue_id &lt; dev-&gt;real_num_rx_queues)</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;_rx[queue_id].umem;</span><br><span class="line">	<span class="keyword">if</span> (queue_id &lt; dev-&gt;real_num_tx_queues)</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;_tx[queue_id].umem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(xdp_get_umem_from_qid);</span><br></pre></td></tr></table></figure>

<p>可以看到上述前置检查中，如果队列上有对应的<code>umem</code>则返回<code>-EINVAL</code>，即如果网卡队列已经attach了<code>XDP</code>程序，则不允许禁用当前队列。</p>
<p><code>AF_XDP</code>的应用场景和<code>AF_PACKET</code>相似，都是在内核驱动正常使用的前提下，在用户态捕获网卡报文的机制，在概念理解的很多时候会进行类比，其中队列这一块就是一个明显差异了，<code>AF_XDP</code>的队列就是网卡的硬件队列，而<code>AF_PACKET</code>的队列是其自身的抽象软件队列，和网卡硬件队列并不是一一对应的关系。</p>
<h2 id="XDP-mode"><a href="#XDP-mode" class="headerlink" title="XDP mode"></a>XDP mode</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_SKB_MODE		(1U &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_DRV_MODE		(1U &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_HW_MODE		(1U &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_MODES			(XDP_FLAGS_SKB_MODE | \</span></span><br><span class="line"><span class="meta">					 XDP_FLAGS_DRV_MODE | \</span></span><br><span class="line"><span class="meta">					 XDP_FLAGS_HW_MODE)</span></span><br></pre></td></tr></table></figure>

<p><code>XDP</code>支持三种模式，分别对应了不同位置的<code>eBPF</code> hook点，自底向上分别为：<code>XDP_HW</code>、<code>XDP_DRV</code>和<code>XDP_SKB</code>。</p>
<p>在<code>AF_XDP</code>初始化时，通过<code>xsk_socket__create</code>-&gt;<code>xsk_setup_xdp_prog</code>-&gt;<code>xsk_load_xdp_prog</code>-&gt;<code>bpf_set_link_xdp_fd</code>-&gt;<code>rtnl_setlink</code>-&gt;<code>do_setlink</code>-&gt;<code>dev_change_xdp_fd</code>设置<code>XDP mode</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	dev_change_xdp_fd - set or clear a bpf program for a device rx path</span></span><br><span class="line"><span class="comment"> *	@dev: device</span></span><br><span class="line"><span class="comment"> *	@extack: netlink extended ack</span></span><br><span class="line"><span class="comment"> *	@fd: new program fd or negative value to clear</span></span><br><span class="line"><span class="comment"> *	@flags: xdp-related flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Set or clear a bpf program for a device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_change_xdp_fd</span><span class="params">(struct net_device *dev, struct netlink_ext_ack *extack,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">int</span> fd, u32 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">ops</span> =</span> dev-&gt;netdev_ops;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_netdev_command</span> <span class="title">query</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">bpf_op_t</span> bpf_op, bpf_chk;</span><br><span class="line">	<span class="keyword">bool</span> offload;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	ASSERT_RTNL();</span><br><span class="line"></span><br><span class="line">	rh_mark_used_feature(<span class="string">&quot;eBPF/xdp&quot;</span>);</span><br><span class="line"></span><br><span class="line">	offload = flags &amp; XDP_FLAGS_HW_MODE;</span><br><span class="line">	query = offload ? XDP_QUERY_PROG_HW : XDP_QUERY_PROG;</span><br><span class="line"></span><br><span class="line">	bpf_op = bpf_chk = ops-&gt;ndo_bpf;</span><br><span class="line">	<span class="keyword">if</span> (!bpf_op &amp;&amp; (flags &amp; (XDP_FLAGS_DRV_MODE | XDP_FLAGS_HW_MODE))) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;underlying driver does not support XDP in native mode&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!bpf_op || (flags &amp; XDP_FLAGS_SKB_MODE))</span><br><span class="line">		bpf_op = generic_xdp_install;</span><br><span class="line">	<span class="keyword">if</span> (bpf_op == bpf_chk)</span><br><span class="line">		bpf_chk = generic_xdp_install;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!offload &amp;&amp; __dev_xdp_query(dev, bpf_chk, XDP_QUERY_PROG)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;native and generic XDP can&#x27;t be active at the same time&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; XDP_FLAGS_UPDATE_IF_NOEXIST) &amp;&amp;</span><br><span class="line">		    __dev_xdp_query(dev, bpf_op, query)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;XDP program already attached&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		prog = bpf_prog_get_type_dev(fd, BPF_PROG_TYPE_XDP,</span><br><span class="line">					     bpf_op == ops-&gt;ndo_bpf);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prog))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(prog);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!offload &amp;&amp; bpf_prog_is_dev_bound(prog-&gt;aux)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;using device-bound program without HW_MODE flag is not supported&quot;</span>);</span><br><span class="line">			bpf_prog_put(prog);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = dev_xdp_install(dev, bpf_op, extack, flags, prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; prog)</span><br><span class="line">		bpf_prog_put(prog);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用<code>xsk_socket__create</code>时<code>usr_config</code>没有指定<code>xdp_flags</code>的话，默认为<code>0</code>。</p>
<p>可以看到，优先通过<code>dev-&gt;netdev_ops-&gt;ndo_bpf</code>判断对应的设备是否支持<code>XDP_HW</code>或<code>XDP_DRV</code>，对<code>bpf_op</code>赋值后通过<code>dev_xdp_install</code>调用。</p>
<p>所以，对于<code>XDP_SKB</code>模式而言，<code>bpf_op</code>对应的函数为<code>generic_xdp_install</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generic_xdp_install</span><span class="params">(struct net_device *dev, struct netdev_bpf *xdp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">old</span> =</span> rtnl_dereference(dev-&gt;xdp_prog);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">new</span> =</span> xdp-&gt;prog;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (xdp-&gt;command) &#123;</span><br><span class="line">	<span class="keyword">case</span> XDP_SETUP_PROG:</span><br><span class="line">		rcu_assign_pointer(dev-&gt;xdp_prog, <span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (old)</span><br><span class="line">			bpf_prog_put(old);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (old &amp;&amp; !<span class="keyword">new</span>) &#123;</span><br><span class="line">			static_branch_dec(&amp;generic_xdp_needed_key);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span> &amp;&amp; !old) &#123;</span><br><span class="line">			static_branch_inc(&amp;generic_xdp_needed_key);</span><br><span class="line">			dev_disable_lro(dev);</span><br><span class="line">			dev_disable_gro_hw(dev);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> XDP_QUERY_PROG:</span><br><span class="line">		xdp-&gt;prog_id = old ? old-&gt;aux-&gt;id : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到逻辑非常简单，就是设置<code>dev-&gt;xdp_prog</code>，调整<code>generic_xdp_needed_key</code>，如果是初始化的话，再关闭设备的<code>lro</code>和<code>gro</code>。</p>
<p>对<code>PMD_AF_XDP</code>而言，只置位了<code>XDP_FLAGS_UPDATE_IF_NOEXIST</code>，所以和默认行为一样，按照优先顺序使用<code>XDP_HW</code>、<code>XDP_DRV</code>和<code>XDP_SKB</code>。</p>
<h2 id="Where-is-the-XDP-eBPF-program"><a href="#Where-is-the-XDP-eBPF-program" class="headerlink" title="Where is the XDP/eBPF program?"></a>Where is the XDP/eBPF program?</h2><p>至此，<code>PMD_AF_XDP</code>的初始化流程已经结束，上面也分析过了，<code>configure</code>和<code>start</code>中都没有复杂操作，<code>start</code>完成后，PMD就可以正常工作进行收发包了。那么问题来了，<code>XDP</code>/<code>eBPF</code>程序是在哪里被attach上去的呢？这里从<code>xsk_socket__create</code>看起：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xsk_socket__create</span><span class="params">(struct xsk_socket **xsk_ptr, <span class="keyword">const</span> <span class="keyword">char</span> *ifname,</span></span></span><br><span class="line"><span class="params"><span class="function">		       __u32 queue_id, struct xsk_umem *umem,</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct xsk_ring_cons *rx, struct xsk_ring_prod *tx,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">const</span> struct xsk_socket_config *usr_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (!(xsk-&gt;config.libbpf_flags &amp; XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD)) &#123;</span><br><span class="line">		err = xsk_setup_xdp_prog(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_mmap_tx;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_setup_xdp_prog</span><span class="params">(struct xsk_socket *xsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (!prog_id) &#123;</span><br><span class="line">		err = xsk_create_bpf_maps(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		err = xsk_load_xdp_prog(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			xsk_delete_bpf_maps(xsk);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		xsk-&gt;prog_fd = bpf_prog_get_fd_by_id(prog_id);</span><br><span class="line">		<span class="keyword">if</span> (xsk-&gt;prog_fd &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -errno;</span><br><span class="line">		err = xsk_lookup_bpf_maps(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			close(xsk-&gt;prog_fd);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_load_xdp_prog</span><span class="params">(struct xsk_socket *xsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> log_buf_size = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">char</span> log_buf[log_buf_size];</span><br><span class="line">	<span class="keyword">int</span> err, prog_fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is the C-program:</span></span><br><span class="line"><span class="comment">	 * SEC(&quot;xdp_sock&quot;) int xdp_sock_prog(struct xdp_md *ctx)</span></span><br><span class="line"><span class="comment">	 * &#123;</span></span><br><span class="line"><span class="comment">	 *     int ret, index = ctx-&gt;rx_queue_index;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *     // A set entry here means that the correspnding queue_id</span></span><br><span class="line"><span class="comment">	 *     // has an active AF_XDP socket bound to it.</span></span><br><span class="line"><span class="comment">	 *     ret = bpf_redirect_map(&amp;xsks_map, index, XDP_PASS);</span></span><br><span class="line"><span class="comment">	 *     if (ret &gt; 0)</span></span><br><span class="line"><span class="comment">	 *         return ret;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *     // Fallback for pre-5.3 kernels, not supporting default</span></span><br><span class="line"><span class="comment">	 *     // action in the flags parameter.</span></span><br><span class="line"><span class="comment">	 *     if (bpf_map_lookup_elem(&amp;xsks_map, &amp;index))</span></span><br><span class="line"><span class="comment">	 *         return bpf_redirect_map(&amp;xsks_map, index, 0);</span></span><br><span class="line"><span class="comment">	 *     return XDP_PASS;</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">		<span class="comment">/* r2 = *(u32 *)(r1 + 16) */</span></span><br><span class="line">		BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1, <span class="number">16</span>),</span><br><span class="line">		<span class="comment">/* *(u32 *)(r10 - 4) = r2 */</span></span><br><span class="line">		BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">		<span class="comment">/* r1 = xskmap[] */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span><br><span class="line">		<span class="comment">/* r3 = XDP_PASS */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_3, <span class="number">2</span>),</span><br><span class="line">		<span class="comment">/* call bpf_redirect_map */</span></span><br><span class="line">		BPF_EMIT_CALL(BPF_FUNC_redirect_map),</span><br><span class="line">		<span class="comment">/* if w0 != 0 goto pc+13 */</span></span><br><span class="line">		BPF_JMP32_IMM(BPF_JSGT, BPF_REG_0, <span class="number">0</span>, <span class="number">13</span>),</span><br><span class="line">		<span class="comment">/* r2 = r10 */</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">		<span class="comment">/* r2 += -4 */</span></span><br><span class="line">		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">		<span class="comment">/* r1 = xskmap[] */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span><br><span class="line">		<span class="comment">/* call bpf_map_lookup_elem */</span></span><br><span class="line">		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),</span><br><span class="line">		<span class="comment">/* r1 = r0 */</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">		<span class="comment">/* r0 = XDP_PASS */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>),</span><br><span class="line">		<span class="comment">/* if r1 == 0 goto pc+5 */</span></span><br><span class="line">		BPF_JMP_IMM(BPF_JEQ, BPF_REG_1, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">		<span class="comment">/* r2 = *(u32 *)(r10 - 4) */</span></span><br><span class="line">		BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_10, <span class="number">-4</span>),</span><br><span class="line">		<span class="comment">/* r1 = xskmap[] */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span><br><span class="line">		<span class="comment">/* r3 = 0 */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_3, <span class="number">0</span>),</span><br><span class="line">		<span class="comment">/* call bpf_redirect_map */</span></span><br><span class="line">		BPF_EMIT_CALL(BPF_FUNC_redirect_map),</span><br><span class="line">		<span class="comment">/* The jumps are to this instruction */</span></span><br><span class="line">		BPF_EXIT_INSN(),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">size_t</span> insns_cnt = <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(struct bpf_insn);</span><br><span class="line"></span><br><span class="line">	prog_fd = bpf_load_program(BPF_PROG_TYPE_XDP, prog, insns_cnt,</span><br><span class="line">				   <span class="string">&quot;LGPL-2.1 or BSD-2-Clause&quot;</span>, <span class="number">0</span>, log_buf,</span><br><span class="line">				   log_buf_size);</span><br><span class="line">	<span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;BPF log buffer:\n%s&quot;</span>, log_buf);</span><br><span class="line">		<span class="keyword">return</span> prog_fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = bpf_set_link_xdp_fd(xsk-&gt;ifindex, prog_fd, xsk-&gt;config.xdp_flags);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		close(prog_fd);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	xsk-&gt;prog_fd = prog_fd;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是通过调用链<code>xsk_socket__create</code>-&gt;<code>xsk_setup_xdp_prog</code>-&gt;<code>xsk_load_xdp_prog</code>-&gt;<code>bpf_load_program</code>完成的，其中对应的<code>eBPF</code>程序直接硬编码到了<code>xsk_load_xdp_prog</code>中，当然也是由于<code>AF_XDP</code>的功能比较简单，如果是其他功能的<code>XDP</code>/<code>eBPF</code>程序，则会采用其他方式保存源码。</p>
<p>注意<code>xsk_setup_xdp_prog</code>中根据<code>prog_id</code>是否合法，有不同的处理逻辑：</p>
<ul>
<li>当前设备上未attach <code>XDP</code>程序：函数将创建<code>BPF_MAP</code>并进行<code>XDP</code>程序的attach</li>
<li>当前设备上已attach <code>XDP</code>程序：函数查找设备对应的<code>XDP</code>程序id以及对应的<code>BPF_MAP</code>，将其赋值给<code>xsk</code>相应成员</li>
</ul>
<p>由此可见，<code>XDP</code>程序和<code>BPF_MAP</code>是设备级别的，同一个设备只能有一个<code>XDP</code>程序（不支持<code>XDP_ATTACHED_MULTI</code>的场景）和<code>BPF_MAP</code>。这点在<code>net_device</code>的定义中也有体现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* RHEL: while xdp_prog is explicitly removed from the kABI</span></span><br><span class="line"><span class="comment">	 * whitelist, one semantics must be preserved: comparison of</span></span><br><span class="line"><span class="comment">	 * xdp_prog to NULL denotes whether a XDP program is loaded or not.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RH_KABI_EXCLUDE(struct bpf_prog __rcu	*xdp_prog)</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xdp_prog</code>只是一个指针，并非一个数组。</p>
<h2 id="RX-amp-TX"><a href="#RX-amp-TX" class="headerlink" title="RX &amp; TX"></a>RX &amp; TX</h2><p>报文收发是PMD的核心功能，接下来看下收发是怎么实现的。之前已经提到了，内核态<code>XDP</code>和用户态应用之间通过<code>umem</code>进行报文收发，那具体是怎么做的呢？</p>
<h3 id="XDP-ring"><a href="#XDP-ring" class="headerlink" title="XDP ring"></a>XDP ring</h3><blockquote>
<p>The UMEM consists of a number of equally sized chunks. A descriptor in one of the rings references a frame by referencing its addr. The addr is simply an offset within the entire UMEM region. The user space allocates memory for this UMEM using whatever means it feels is most appropriate (malloc, mmap, huge pages, etc). This memory area is then registered with the kernel using the new setsockopt XDP_UMEM_REG. The UMEM also has two rings: the FILL ring and the COMPLETION ring. The FILL ring is used by the application to send down addr for the kernel to fill in with RX packet data. References to these frames will then appear in the RX ring once each packet has been received. The COMPLETION ring, on the other hand, contains frame addr that the kernel has transmitted completely and can now be used again by user space, for either TX or RX. Thus, the frame addrs appearing in the COMPLETION ring are addrs that were previously transmitted using the TX ring. In summary, the RX and FILL rings are used for the RX path and the TX and COMPLETION rings are used for the TX path.</p>
</blockquote>
<p>实际上，除了<code>umem</code>外，报文收发还用到了4种不同的数据结构，分别为：</p>
<ul>
<li><code>fill ring</code>：每一个<code>umem</code>只有一个，用于向内核提供<code>umem</code>。</li>
<li><code>completion ring</code>：每一个<code>umem</code>只有一个，用于从内核获取<code>umem</code>。</li>
<li><code>rx ring</code>：用户态应用从<code>rx ring</code>收取报文，每个<code>xsk</code>可以有多个<code>rx ring</code>，应该是对应<code>XDP_SHARED_UMEM </code>的场景。</li>
<li><code>tx ring</code>：用户态应用向<code>tx ring</code>发送报文，每个<code>xsk</code>可以有多个<code>tx ring</code>，应该是对应<code>XDP_SHARED_UMEM </code>的场景。</li>
</ul>
<h3 id="RX-procedure"><a href="#RX-procedure" class="headerlink" title="RX procedure"></a>RX procedure</h3><p>收包流程使用<code>fill ring</code>和<code>rx ring</code>，用户态应用首先需要向内核提供<code>umem</code>用于接收报文，所以先作为producer向<code>fill ring</code>填入<code>umem</code>，内核<code>XDP</code>作为consumer从<code>fill ring</code>获取到可用<code>umem</code>后将报文填入，再作为producer将这部分<code>umem</code>添加到<code>rx ring</code>，最后用户态应用作为consumer从<code>rx ring</code>获取接收到的报文。</p>
<p>在<code>xsk</code>初始化流程中就已经对初始化好的<code>fill ring</code>填入<code>umem</code>了，这样当<code>XDP</code>/<code>eBPF</code>attach完成后就可以立即用这部分<code>umem</code>收包了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_AF_XDP_DFLT_NUM_DESCS	XSK_RING_CONS__DEFAULT_NUM_DESCS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">xsk_configure</span><span class="params">(struct pmd_internals *internals, struct pkt_rx_queue *rxq,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">int</span> ring_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">int</span> reserve_size = ETH_AF_XDP_DFLT_NUM_DESCS / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">	ret = reserve_fill_queue(rxq-&gt;umem, reserve_size, fq_bufs);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		xsk_socket__delete(rxq-&gt;xsk);</span><br><span class="line">		AF_XDP_LOG(ERR, <span class="string">&quot;Failed to reserve fill queue.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里预留的个数实际上是<code>XSK_RING_CONS__DEFAULT_NUM_DESCS / 2</code>，默认情况下<code>ETH_AF_XDP_NUM_BUFFERS = XSK_RING_CONS__DEFAULT_NUM_DESCS * 2 </code>，即这里初始化了<code>umem</code>总量的四分之一，填入了<code>fill ring</code>。</p>
<p>以<code>af_xdp_rx_cp</code>为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">af_xdp_rx_cp</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">queue</span>, struct rte_mbuf **bufs, <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Step 1: Get recv num. */</span></span><br><span class="line">	rcvd = xsk_ring_cons__peek(rx, nb_pkts, &amp;idx_rx);</span><br><span class="line">	<span class="keyword">if</span> (rcvd == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(XDP_USE_NEED_WAKEUP)</span></span><br><span class="line">		<span class="keyword">if</span> (xsk_ring_prod__needs_wakeup(fq))</span><br><span class="line">			(<span class="keyword">void</span>)poll(rxq-&gt;fds, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Reserve some umem to fill ring if necessary. */</span></span><br><span class="line">	<span class="keyword">if</span> (xsk_prod_nb_free(fq, free_thresh) &gt;= free_thresh)</span><br><span class="line">		(<span class="keyword">void</span>)reserve_fill_queue(umem, ETH_AF_XDP_RX_BATCH_SIZE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rcvd; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdp_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">		<span class="keyword">uint64_t</span> addr;</span><br><span class="line">		<span class="keyword">uint32_t</span> len;</span><br><span class="line">		<span class="keyword">void</span> *pkt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 3: Recieve every packets from rx ring. */</span></span><br><span class="line">		desc = xsk_ring_cons__rx_desc(rx, idx_rx++);</span><br><span class="line">		addr = desc-&gt;addr;</span><br><span class="line">		len = desc-&gt;len;</span><br><span class="line">		pkt = xsk_umem__get_data(rxq-&gt;umem-&gt;mz-&gt;addr, addr);</span><br><span class="line"></span><br><span class="line">		rte_memcpy(rte_pktmbuf_mtod(mbufs[i], <span class="keyword">void</span> *), pkt, len);</span><br><span class="line">        <span class="comment">/* Step 4: Enqueue addr to buf_ring after packet recieved. */</span></span><br><span class="line">		rte_ring_enqueue(umem-&gt;buf_ring, (<span class="keyword">void</span> *)addr);</span><br><span class="line">		rte_pktmbuf_pkt_len(mbufs[i]) = len;</span><br><span class="line">		rte_pktmbuf_data_len(mbufs[i]) = len;</span><br><span class="line">		rx_bytes += len;</span><br><span class="line">		bufs[i] = mbufs[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: Update rx ring consumer index. */</span></span><br><span class="line">	xsk_ring_cons__release(rx, rcvd);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收包流程中各步骤如下：</p>
<ul>
<li>Step 1：依据<code>rx ring</code>的producer和consumer差值，获取当前可收取的报文数量。</li>
<li>Step 2：如果<code>fill ring</code>中剩余<code>umem</code>小于阈值的话，则添加一部分进去。</li>
<li>Step 3：从<code>rx ring</code>获取报文对应的<code>umem</code>并拷贝到<code>mbuf</code>完成每个报文的收取。</li>
<li>Step 4：每个<code>umem</code>处理完后入队<code>buf_ring</code>供下次收包/发包使用。</li>
<li>Step 5：更新<code>rx ring</code>中的consumer。</li>
</ul>
<h3 id="TX-procedure"><a href="#TX-procedure" class="headerlink" title="TX procedure"></a>TX procedure</h3><p>看完收包流程后，我原以为以为内核<code>XDP</code>要相对地提前初始化一部分<code>umem</code>，然后用户态向对应<code>umem</code>填入报文完成发包，但事实上不是这样的。</p>
<p>发包流程中，使用<code>completion ring</code>和<code>tx ring</code>，用户态应用首先将报文填入<code>umem</code>，并作为producer将<code>umem</code>填入<code>tx ring</code>，内核<code>XDP</code>作为consumer从<code>tx ring</code>获取报文并发送。发送完成后，作为producer将发送完成的<code>umem</code>填入<code>completion ring</code>，用户态应用再作为consumer从<code>completion ring</code>中回收已经发送完毕的<code>umem</code>供下一次发包/收包使用。</p>
<p>以<code>af_xdp_tx_cp</code>为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">af_xdp_tx_cp</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">queue</span>, struct rte_mbuf **bufs, <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Step 1: Get free umem in completion ring and enqueue to buf_ring. */</span></span><br><span class="line">	pull_umem_cq(umem, nb_pkts);</span><br><span class="line"></span><br><span class="line">	nb_pkts = rte_ring_dequeue_bulk(umem-&gt;buf_ring, addrs,</span><br><span class="line">					nb_pkts, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (nb_pkts == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Reserve tx ring. */</span></span><br><span class="line">	<span class="keyword">if</span> (xsk_ring_prod__reserve(&amp;txq-&gt;tx, nb_pkts, &amp;idx_tx) != nb_pkts) &#123;</span><br><span class="line">		kick_tx(txq);</span><br><span class="line">		rte_ring_enqueue_bulk(umem-&gt;buf_ring, addrs, nb_pkts, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_pkts; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">xdp_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">		<span class="keyword">void</span> *pkt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 3: Send every packet to umem from tx ring. */</span></span><br><span class="line">		desc = xsk_ring_prod__tx_desc(&amp;txq-&gt;tx, idx_tx + i);</span><br><span class="line">		mbuf = bufs[i];</span><br><span class="line">		desc-&gt;len = mbuf-&gt;pkt_len;</span><br><span class="line"></span><br><span class="line">		desc-&gt;addr = (<span class="keyword">uint64_t</span>)addrs[i];</span><br><span class="line">		pkt = xsk_umem__get_data(umem-&gt;mz-&gt;addr,</span><br><span class="line">					 desc-&gt;addr);</span><br><span class="line">		rte_memcpy(pkt, rte_pktmbuf_mtod(mbuf, <span class="keyword">void</span> *), desc-&gt;len);</span><br><span class="line">		tx_bytes += mbuf-&gt;pkt_len;</span><br><span class="line">		rte_pktmbuf_free(mbuf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Update tx ring producer index. */</span></span><br><span class="line">	xsk_ring_prod__submit(&amp;txq-&gt;tx, nb_pkts);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/* Step 5: Kick XDP. */</span></span><br><span class="line">	kick_tx(txq);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发包流程中各步骤如下：</p>
<ul>
<li>Step 1：从<code>completion ring</code>中检查是否有已经发包完毕的<code>umem</code>，如果有，则将其入队<code>buf_ring</code>，以供下一次发包/收包使用。</li>
<li>Step 2：检查<code>tx ring</code>空闲元素数量是否满足本次发包，如果不足的话，通过<code>kick_tx</code>的方式让内核<code>XDP</code>再发包，以释放一些可用<code>tx ring</code>，同时将上一步出队的<code>buf_ring</code>中的<code>umem</code>再入队。</li>
<li>Step 3：将<code>mbuf</code>拷贝到<code>tx ring</code>中对应的<code>umem</code>完成发包。</li>
<li>Step 4：更新<code>tx ring</code>的producer。</li>
<li>Step 5：调用<code>kick_tx</code>通知内核<code>XDP</code>有报文待发送。之前提到了<code>AF_XDP</code>的发包过程还是有<code>send</code>调用的，原因就在这里，更新了<code>tx ring</code>后通过<code>send</code>通知内核。收包流程没有<code>recv</code>调用，因为收包流程是轮询的，不需要收到来自内核<code>XDP</code>的通知。</li>
</ul>
<p>这里的<code>kick_tx</code>实际上就是调用<code>xsk</code>对应的<code>sendmsg</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kick_tx</span><span class="params">(struct pkt_tx_queue *txq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xsk_umem_info</span> *<span class="title">umem</span> =</span> txq-&gt;umem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(XDP_USE_NEED_WAKEUP)</span></span><br><span class="line">	<span class="keyword">if</span> (xsk_ring_prod__needs_wakeup(&amp;txq-&gt;tx))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">while</span> (send(xsk_socket__fd(txq-&gt;<span class="built_in">pair</span>-&gt;xsk), <span class="literal">NULL</span>,</span><br><span class="line">			    <span class="number">0</span>, MSG_DONTWAIT) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* some thing unexpected */</span></span><br><span class="line">			<span class="keyword">if</span> (errno != EBUSY &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* pull from completion queue to leave more space */</span></span><br><span class="line">			<span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">				pull_umem_cq(umem, ETH_AF_XDP_TX_BATCH_SIZE);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XDP_UMEM_UNALIGNED_CHUNK_FLAG</span></span><br><span class="line">	pull_umem_cq(umem, ETH_AF_XDP_TX_BATCH_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>xsk</code>的代码中，以<code>xsk_generic_xmit</code>为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_generic_xmit</span><span class="params">(struct sock *sk, struct msghdr *m,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">size_t</span> total_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">		skb = sock_alloc_send_skb(sk, len, <span class="number">1</span>, &amp;err);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb)) &#123;</span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skb_put(skb, len);</span><br><span class="line">		addr = desc.addr;</span><br><span class="line">		buffer = xdp_umem_get_data(xs-&gt;umem, addr);</span><br><span class="line">		err = skb_store_bits(skb, <span class="number">0</span>, buffer, len);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(err) || xskq_reserve_addr(xs-&gt;umem-&gt;cq)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skb-&gt;dev = xs-&gt;dev;</span><br><span class="line">		skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">		skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line">		skb_shinfo(skb)-&gt;destructor_arg = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)addr;</span><br><span class="line">		skb-&gt;destructor = xsk_destruct_skb;</span><br><span class="line"></span><br><span class="line">		err = dev_direct_xmit(skb, xs-&gt;queue_id);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其逻辑就是从<code>tx_ring</code>中获取报文，构造<code>skb</code>，再调用<code>dev_direct_xmit</code>最终通过网卡驱动的发包函数发送出去。</p>
<p>可以看到整个发包流程，是和<code>XDP</code>程序毫无关系的，这也是为什么很多地方会说<code>XDP</code>只工作于收包路径。<code>AF_XDP</code>的发包能力是利用了<code>umem</code>实现的，<code>AF_XDP</code>将收发包功能封装整合，最终向上层提供了一种协议族。</p>
<h3 id="Comparison-with-virtio-ring"><a href="#Comparison-with-virtio-ring" class="headerlink" title="Comparison with virtio ring"></a>Comparison with virtio ring</h3><p>ring这块的话和<code>virtio</code>还是有一定的相似性的，相同的地方在于前后端都是各通过一个ring来通知对端本端的处理进度，以及通过相对的ring来获取对端的处理进度，ring中都是存放了真实描述符（<code>umem</code>/<code>desc ring</code>）的索引。不同的地方在于<code>virtio</code>对于收发包队列，各有一个<code>desc ring</code>用来存储<code>desc</code>。<code>desc ring</code>对应到<code>XDP</code>就是<code>umem</code>，然而所有的收发包队列使用同一个<code>umem</code>。</p>
<h2 id="eBPF-map-in-AF-XDP"><a href="#eBPF-map-in-AF-XDP" class="headerlink" title="eBPF map in AF_XDP"></a>eBPF map in AF_XDP</h2><p><code>eBPF</code>程序可以通过<code>BPF_MAP</code>和用户态程序进行运行时的数据交换。<code>BPF_MAP</code>支持的类型定义在枚举类型<code>bpf_map_type</code>中。对<code>XDP</code>而言，每一个<code>xsk</code>创建时，都会创建一个<code>BPF_MAP_TYPE_XSKMAP</code>类型的<code>BPF_MAP</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_create_bpf_maps</span><span class="params">(struct xsk_socket *xsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max_queues;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">	max_queues = xsk_get_max_queues(xsk);</span><br><span class="line">	<span class="keyword">if</span> (max_queues &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> max_queues;</span><br><span class="line"></span><br><span class="line">	fd = bpf_create_map_name(BPF_MAP_TYPE_XSKMAP, <span class="string">&quot;xsks_map&quot;</span>,</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), max_queues, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">	xsk-&gt;xsks_map_fd = fd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的<code>BPF_MAP</code>名称都固定为<code>xsks_map</code>，<code>key_size</code>和<code>value_size</code>都为<code>sizeof(int)</code>，因为这里实际逻辑上的key为<code>queue_id</code>，而value为<code>xsk-&gt;fd</code>，其数据大小都是<code>int</code>。该<code>BPF_MAP</code>的意义在于指导<code>XDP</code>程序，在key对应的queue上收到报文后，将报文重定向到value对应的<code>xsk</code>。</p>
<p>这里要稍微说一下<code>BPF_MAP</code>的创建，<code>libbpf</code>封装的接口<code>bpf_create_map_name</code>最终使用<code>BPF_MAP_CREATE</code>系统调用来创建对应的<code>BPF_MAP</code>，从上述传参可以看到，并没有设备或<code>xsk</code>的相关信息传入，可以想到，所有的<code>BPF_MAP</code>都属于一个统一的namespace，创建使用都依据最终返回的fd进行，只要能够获取fd，就可以访问。所以<code>BPF_MAP</code>本身不和设备、<code>xsk</code>或特定资源绑定，而是由创建<code>BPF_MAP</code>的调用者保存创建后的fd以便于后续的访问和管理。对<code>AF_XDP</code>而言，保存在了<code>xsk-&gt;xsks_map_fd</code>。</p>
<p>注意这里所有的<code>xsk</code>对应的<code>BPF_MAP</code>的名字都相同，但是每一个<code>xsk</code>唯一对应一个<code>xsks_map_fd</code>、<code>xsk-&gt;fd</code>和<code>prog_fd</code>，并且都保存在<code>xsk</code>结构体中。这里要和<code>XDP</code>程序attach的流程结合起来看，一个设备对应一个<code>XDP</code>程序和<code>BPF_MAP</code>，但一个<code>XDP</code>程序和<code>BPF_MAP</code>可能对应多个<code>xsk</code>。当对同一个设备的不同队列创建多个<code>xsk</code>时，实际上是通过在<code>BPF_MAP</code>中增加<code>queue_id</code>和<code>xsk-&gt;fd</code>的映射。</p>
<p>对<code>AF_XDP</code>而言，在后续收包流程中执行<code>XDP</code>程序时，从<code>BPF_MAP</code>中查找到对应的<code>xsk</code>，并将报文拷贝到<code>xsk</code>对应的<code>umem</code>中。所以<code>AF_XDP</code>的<code>BPF_MAP</code>实现了<code>queue_id</code>和<code>xsk-&gt;fd</code>的映射，用于指导<code>XDP</code>程序进行重定向，而实现内核态与用户态之间进行数据交互的机制是<code>umem</code>。</p>
<h2 id="Does-XDP-support-offload"><a href="#Does-XDP-support-offload" class="headerlink" title="Does XDP support offload?"></a>Does XDP support offload?</h2><p>内核协议栈实现了很多卸载功能，如<code>GRO</code>/<code>GSO</code>，在分片场景能极大提升性能，那<code>XDP</code>是否支持这些卸载能力呢？</p>
<h3 id="GRO-LRO-with-XDP"><a href="#GRO-LRO-with-XDP" class="headerlink" title="GRO/LRO with XDP?"></a>GRO/LRO with XDP?</h3><p>首先看<code>GRO</code>，也就是接收方向，以hook点最晚的<code>SKB MODE</code>来说，其调用路径为：<code>napi_gro_complete</code>-&gt;<code>netif_receive_skb_internal</code>-&gt;<code>__netif_receive_skb</code>-&gt;<code>__netif_receive_skb_core</code>-&gt;<code>do_xdp_generic</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;generic_xdp_needed_key)) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret2;</span><br><span class="line"></span><br><span class="line">		preempt_disable();</span><br><span class="line">		ret2 = do_xdp_generic(rcu_dereference(skb-&gt;dev-&gt;xdp_prog), skb);</span><br><span class="line">		preempt_enable();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret2 != XDP_PASS)</span><br><span class="line">			<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">		skb_reset_mac_len(skb);</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从调用路径可以知道，在<code>skb</code>接收的早期，<code>GRO</code>完成之前就已经执行<code>XDP</code>程序了。所以，除非<code>XDP</code>程序不对该报文进行处理，也就是<code>XDP</code>程序返回了<code>XDP_PASS</code>，报文才可能接着进入<code>GRO</code>处理流程。也就是说，<code>XDP</code>处理的报文，是未经<code>GRO</code>处理的，对<code>AF_XDP</code>而言，就意味着不支持<code>GRO</code>。</p>
<p>那有没有可能支持<code>LRO</code>呢？毕竟<code>LRO</code>不需要进入协议栈就可以完成。假设支持<code>LRO</code>，则<code>xsk</code>就需要处理可能出现的巨帧。从上面收发包流程可以知道，报文是由<code>umem</code>承载的，而<code>umem</code>最大支持<code>PAGE_SIZE</code>的帧大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xdp_umem_reg</span><span class="params">(struct xdp_umem *umem, struct xdp_umem_reg *mr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (chunk_size &lt; XDP_UMEM_MIN_CHUNK_SIZE || chunk_size &gt; PAGE_SIZE) &#123;</span><br><span class="line">		<span class="comment">/* Strictly speaking we could support this, if:</span></span><br><span class="line"><span class="comment">		 * - huge pages, or*</span></span><br><span class="line"><span class="comment">		 * - using an IOMMU, or</span></span><br><span class="line"><span class="comment">		 * - making sure the memory area is consecutive</span></span><br><span class="line"><span class="comment">		 * but for now, we simply say &quot;computer says no&quot;.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而普通页大小在X86架构下通常为4K，也就是通常<code>XDP</code>只支持最大4K的帧大小，这个大小不足以用于<code>LRO</code>。</p>
<p>关于<code>LRO</code>，也可以参考下<code>virtio_net</code>中的<code>virtnet_xdp_set</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">virtnet_xdp_set</span><span class="params">(struct net_device *dev, struct bpf_prog *prog,</span></span></span><br><span class="line"><span class="params"><span class="function">			   struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (!virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS)</span><br><span class="line">	    &amp;&amp; (virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_TSO4) ||</span><br><span class="line">	        virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_TSO6) ||</span><br><span class="line">	        virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_ECN) ||</span><br><span class="line">		virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_UFO))) &#123;</span><br><span class="line">		NL_SET_ERR_MSG_MOD(extack, <span class="string">&quot;Can&#x27;t set XDP while host is implementing LRO, disable LRO first&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>virtio_net</code>开启了<code>LRO</code>时，也是不支持attach的，原因也是上面提的，目前<code>XDP</code>尚不支持<code>LRO</code>，后续理论上可以支持。</p>
<h3 id="GSO-TSO-with-XDP"><a href="#GSO-TSO-with-XDP" class="headerlink" title="GSO/TSO with XDP?"></a>GSO/TSO with XDP?</h3><p>再看发包方向<code>GSO</code>，在上面发包流程的分析中已经描述了<code>AF_XDP</code>的发包原理：直接将从<code>umem</code>获取到的原始报文，调用<code>dev_direct_xmit</code>直接通过网卡驱动的发包函数发出，所以很明显，<code>XDP</code>也不支持<code>GSO</code>。</p>
<p>那是否支持<code>TSO</code>呢？发包流程中调用驱动的发包函数，报文是由<code>skb</code>承载的，而构造<code>skb</code>的流程中，并没有设置<code>skb-&gt;gso_size</code>等卸载相关的字段（参考<code>xsk_generic_xmit</code>），所以<code>XDP</code>目前尚不支持<code>TSO</code>，后续理论上可以支持。</p>
<h1 id="libxdp-amp-libbpf"><a href="#libxdp-amp-libbpf" class="headerlink" title="libxdp &amp; libbpf"></a>libxdp &amp; libbpf</h1><p>上面已经介绍过<code>PMD_AF_XDP</code>使用了<code>libbpf</code><a href="https://github.com/libbpf/libbpf">^1</a>提供的<code>xsk</code>相关接口了，但上述代码基于4.18版本的内核，在这之后<code>libbpf</code>进行了很多改动，其中包括使用一个新的库<code>libxdp</code><a href="https://github.com/xdp-project/xdp-tools">^2</a>来维护<code>XDP</code>相关的接口。</p>
<p><code>XDP</code>应用对不同版本的<code>libbpf</code>可以参考<code>PMD_AF_XDP</code>的处理，根据不同版本引用不同的头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTE_NET_AF_XDP_LIBXDP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdp/xsk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/xsk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>network</tag>
        <tag>eBPF</tag>
        <tag>XDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux kernel checksum calculation and skb-&gt;ip_summed</title>
    <url>/2023/01/21/Linux-kernel-checksum-calculation-and-skb-ip-summed/</url>
    <content><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>最近在看内核相关的checksum代码，起因是往虚拟机virtio-net发包时，想通过<code>VIRTIO_NET_HDR_F_DATA_VALID</code>这个flag减少GuestOS的校验和计算开销。关于这个flag，以及<code>virtio_net_hdr</code>这个结构体相关的内容，值得单独说明，所以在这里只是简单提一下。</p>
<p>最初的疑问是<code>VIRTIO_NET_HDR_F_DATA_VALID</code>到底对应几层校验和？</p>
<p>从其定义（DPDK 19.11）可以看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the first element of the scatter-gather list.  If you don&#x27;t</span></span><br><span class="line"><span class="comment"> * specify GSO or CSUM features, you can simply ignore the header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_hdr</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_F_NEEDS_CSUM 1    <span class="comment">/**&lt; Use csum_start,csum_offset*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_F_DATA_VALID 2    <span class="comment">/**&lt; Checksum is valid */</span></span></span><br><span class="line">	<span class="keyword">uint8_t</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_NONE     0    <span class="comment">/**&lt; Not a GSO frame */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_TCPV4    1    <span class="comment">/**&lt; GSO frame, IPv4 TCP (TSO) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_UDP      3    <span class="comment">/**&lt; GSO frame, IPv4 UDP (UFO) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_TCPV6    4    <span class="comment">/**&lt; GSO frame, IPv6 TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_ECN      0x80 <span class="comment">/**&lt; TCP has ECN set */</span></span></span><br><span class="line">	<span class="keyword">uint8_t</span> gso_type;</span><br><span class="line">	<span class="keyword">uint16_t</span> hdr_len;     <span class="comment">/**&lt; Ethernet + IP + tcp/udp hdrs */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> gso_size;    <span class="comment">/**&lt; Bytes to append to hdr_len per frame */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> csum_start;  <span class="comment">/**&lt; Position to start checksumming from */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> csum_offset; <span class="comment">/**&lt; Offset after that to place checksum */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>virtio_net_hdr</code>包含了报文的<code>csum_start</code>和<code>csum_offset</code>，且包含了gso相关字段，从这里可以猜测，它就是描述L4的卸载相关属性的。</p>
<p>为此再接着看<code>VIRTIO_NET_HDR_F_DATA_VALID</code>相关的处理逻辑。</p>
<p>首先看内核（4.18）相关实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">virtio_net_hdr_from_skb</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">					  struct virtio_net_hdr *hdr,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> little_endian,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> has_data_valid,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">int</span> vlan_hlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL) &#123;</span><br><span class="line">		hdr-&gt;flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;</span><br><span class="line">		hdr-&gt;csum_start = __cpu_to_virtio16(little_endian,</span><br><span class="line">			skb_checksum_start_offset(skb) + vlan_hlen);</span><br><span class="line">		hdr-&gt;csum_offset = __cpu_to_virtio16(little_endian,</span><br><span class="line">				skb-&gt;csum_offset);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_data_valid &amp;&amp;</span><br><span class="line">		   skb-&gt;ip_summed == CHECKSUM_UNNECESSARY) &#123;</span><br><span class="line">		hdr-&gt;flags = VIRTIO_NET_HDR_F_DATA_VALID;</span><br><span class="line">	&#125; <span class="comment">/* else everything is zero */</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive_buf</span><span class="params">(struct virtnet_info *vi, struct receive_queue *rq,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">void</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> len, <span class="keyword">void</span> **ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">int</span> *xdp_xmit, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (hdr-&gt;hdr.flags &amp; VIRTIO_NET_HDR_F_DATA_VALID)</span><br><span class="line">		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看DPDK pmd_virtio中的相关实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Optionally fill offload information in structure */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">virtio_rx_offload</span><span class="params">(struct rte_mbuf *m, struct virtio_net_hdr *hdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;flags &amp; VIRTIO_NET_HDR_F_DATA_VALID &amp;&amp; l4_supported) &#123;</span><br><span class="line">		m-&gt;ol_flags |= PKT_RX_L4_CKSUM_GOOD;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从DPDK的代码中可以直观地确认，当PMD收到有<code>VIRTIO_NET_HDR_F_DATA_VALID</code>置位的报文时，为mbuf置上<code>PKT_RX_L4_CKSUM_GOOD</code>以标识L4校验和正确；内核对应的情况是<code>skb-&gt;ip_summed == CHECKSUM_UNNECESSARY</code>。</p>
<p>这里就是比较疑惑的地方了：既然从结构体本身成员，以及DPDK代码中大致确认，<code>VIRTIO_NET_HDR_F_DATA_VALID</code>是描述的L4校验和状态，为何内核中的代码对应的是<code>skb-&gt;ip_summed</code>这个成员呢？从其命名上看应该描述的是L3/IP的校验和才对呀？</p>
<h1 id="skb-gt-ip-summed"><a href="#skb-gt-ip-summed" class="headerlink" title="skb-&gt;ip_summed"></a>skb-&gt;ip_summed</h1><p>首先关注这个令人疑惑的成员，在<code>skbuff.h</code>中，有大段的注释对其进行了详细的描述。</p>
<p>下面对接收方向进行说明，<code>skb-&gt;ip_summed</code>可能的取值有<code>CHECKSUM_NONE</code>、<code>CHECKSUM_UNNECESSARY</code>、<code>CHECKSUM_COMPLETE</code>和<code>CHECKSUM_PARTIAL</code>。</p>
<h2 id="CHECKSUM-NONE"><a href="#CHECKSUM-NONE" class="headerlink" title="CHECKSUM_NONE"></a>CHECKSUM_NONE</h2><p>这种情况很好理解，注释上解释的也比较清楚，当硬件没有对报文进行校验（如硬件不支持校验特性）时，会将<code>skb-&gt;ip_summed</code>置为<code>CHECKSUM_NONE</code>，并且此时的<code>skb-&gt;csum</code>也是无意义的。软件针对此种场景需要完整计算校验和。</p>
<h2 id="CHECKSUM-COMPLETE"><a href="#CHECKSUM-COMPLETE" class="headerlink" title="CHECKSUM_COMPLETE"></a>CHECKSUM_COMPLETE</h2><p>这是最通用的一种场景，硬件计算了报文从L4头部开始的数据的1的补码和并且保存到了<code>skb-&gt;csum</code>。</p>
<p>需要注意的是，硬件不需要对L3/L4进行协议解析即可做到这一点。因为整个IP协议族（IPv4、TCP、UDP等）的校验和计算方式都是一样的，即1的反码和的16bit 1的补码，所以这种情况下硬件只需从L4头部开始计算剩余的1的补码和即可。</p>
<p>在软件计算特定的L4校验和时，可以通过硬件计算的完整结果<code>skb-&gt;csum</code>，进行进一步计算获得最终结果。如：TCP通过<code>skb-&gt;csum</code>加上伪校验和来计算TCP校验和。</p>
<h2 id="CHECKSUM-UNNECESSARY"><a href="#CHECKSUM-UNNECESSARY" class="headerlink" title="CHECKSUM_UNNECESSARY"></a>CHECKSUM_UNNECESSARY</h2><p>这种场景下，硬件已经确认了特定类型（TCP、UDP、GRE、SCP和FCoE）的L4协议的校验和正确，软件无需再进行校验和的验证。</p>
<p>需要注意的是，尽管已经确定了特定类型的L4校验和正确，<code>skb-&gt;csum</code>还是未定义的，且后续流程也不应该修改<code>skb-&gt;csum</code>。</p>
<h2 id="CHECKSUM-PARTIAL"><a href="#CHECKSUM-PARTIAL" class="headerlink" title="CHECKSUM_PARTIAL"></a>CHECKSUM_PARTIAL</h2><p>这种场景硬件计算从<code>skb-&gt;csum_start</code>开始的数据的校验和，并保存到<code>skb-&gt;csum_start + skb-&gt;csum_offset</code>的位置上。</p>
<h2 id="Why-is-it-named-as-ip-summed"><a href="#Why-is-it-named-as-ip-summed" class="headerlink" title="Why is it named as ip_summed?"></a>Why is it named as ip_summed?</h2><p>从上面的取值场景可以发现，<code>skb-&gt;ip_summed</code>描述的是L4的校验和状态，这和对DPDK代码，以及<code>virtio_net_hdr</code>的分析的结论是一致的，但是为什么用了一个这么令人费解的命名呢？</p>
<p>为此我向Linux netdev的mailing list发送了一封邮件询问这件事，有幸得到了大佬的解答，大意是：<strong>虽然命名确实很令人费解，但<code>skb-&gt;ip_summed</code>描述的是L4的校验和状态。</strong>主要原因是整个IP协议族的校验和计算方式都是一样的，所以命名里的ip不是专指IP协议，而是指IP协议族使用的校验和计算方式。其实不仅仅是<code>ip_summed</code>，内核里应该也有一些地方的ip并不是特指IPv4协议，如<code>ip_compute_csum </code>。</p>
<p>同时关于L3/IP校验和，由于L3/IP校验和只需要计算首部，计算量不大，并且在报文接收，解析报文首部时，首部的内容已经被缓存到cache中去了，所以软件计算的开销会很小，由内核进行L3/IP的校验和计算。</p>
<p>完整邮件见：<a href="https://www.spinics.net/lists/netdev/msg854092.html">Confused about ip_summed member in sk_buff</a>。</p>
<h1 id="How-does-kernel-calculate-the-checksum"><a href="#How-does-kernel-calculate-the-checksum" class="headerlink" title="How does kernel calculate the checksum?"></a>How does kernel calculate the checksum?</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header Checksum:  16 bits</span><br><span class="line"></span><br><span class="line">  A checksum on the header only.  Since some header fields change</span><br><span class="line">  (e.g., time to live), this is recomputed and verified at each point</span><br><span class="line">  that the internet header is processed.</span><br><span class="line"></span><br><span class="line">  The checksum algorithm is:</span><br><span class="line"></span><br><span class="line">    The checksum field is the 16 bit one&#x27;s complement of the one&#x27;s</span><br><span class="line">    complement sum of all 16 bit words in the header.  For purposes of</span><br><span class="line">    computing the checksum, the value of the checksum field is zero.</span><br><span class="line">														——RFC791</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从IPv4校验和的定义可以知道，它的值就是首部所有16bit字的1的补码和的1的补码，计算时，校验和字段以0计算。</p>
<p>以如下报文为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:31:34.953256 00:50:56:97:d1:f3 &gt; a8:0c:ca:5f:8c:5c, ethertype IPv4 (0x0800), length 32174: (tos 0x0, ttl 64, id 5604, offset 0, flags [DF], proto TCP (6), length 32160)</span><br><span class="line">    10.103.240.223.22 &gt; 172.23.9.13.12036: Flags [.], cksum 0x2dfe (incorrect -&gt; 0x18ca), seq 74390940:74423060, ack 4837, win 64512, length 32120</span><br><span class="line">        0x0000:  a80c ca5f 8c5c 0050 5697 d1f3 0800 4500  ..._.\.PV.....E.</span><br><span class="line">        0x0010:  7da0 15e4 4000 4006 f708 0a67 f0df ac17  &#125;...@.@....g....</span><br><span class="line">        0x0020:  090d 0016 2f04 fb22 4704 23c3 2b20 5010  ..../..&quot;G.#.+.P.</span><br><span class="line">        0x0030:  fc00 2dfe 0000 33cd 52ed 85f9 888f b0aa  ..-...3.R.......</span><br><span class="line">        0x0040:  7d4e 3cd0 db58 27eb bb87 a09e ea81 c61a  &#125;N&lt;..X&#x27;.........</span><br><span class="line">        0x0050:  9119 23bd 0fa0 dd44 cae2 e84f 4c31 0241  ..#....D...OL1.A</span><br><span class="line">        0x0060:  54ee 860e 3feb 6d4e 1bd1 2ef5 faeb e2e4  T...?.mN........</span><br><span class="line">        0x0070:  6421 7c4d 3ec6 1e5f 0bd9 88ea 4776 3a5d  d!|M&gt;.._....Gv:]</span><br><span class="line">        0x0080:  0a05 abf7 fbd4 69f6 c1d9 74c9 fefc 2fc7  ......i...t.../.</span><br><span class="line">        0x0090:  c8b0 b447 ccb9 6148 9480 d78a c3e9 8e95  ...G..aH........</span><br><span class="line">        0x00a0:  1d04 c8fd 66ab 993e ecf3 7ceb 5443 adfb  ....f..&gt;..|.TC..</span><br><span class="line">        0x00b0:  a6e9 1e55 49d2 b86e 238d bac6 24aa 1b27  ...UI..n#...$..&#x27;</span><br></pre></td></tr></table></figure>

<p>IPv4首部为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4500 7da0 15e4 4000 4006 f708 0a67 f0df ac17 090d</span><br></pre></td></tr></table></figure>

<p>其中校验和为：<code>f708</code>。</p>
<p>下面来实际算一遍。根据校验和定义，先将校验和字段置零，所以IPv4首部在未计算校验和时为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4500 7da0 15e4 4000 4006 0000 0a67 f0df ac17 090d</span><br></pre></td></tr></table></figure>

<p>先将首部所有16bit字相加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(32bit integer) = 0x4500 + 0x7da0 + 0x15e4 + 0x4000 + 0x4006 + 0x0000 + 0x0a67 + 0xf0df + 0xac17 + 0x090d</span><br><span class="line">sum(32bit integer) = 0x308f4</span><br></pre></td></tr></table></figure>

<p>再根据1的补码的加法原则，将进位加回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(one&#x27;s complement) = 0x08f4 + 0x3 (sum + carry)</span><br><span class="line">sum(one&#x27;s complement) = 0x08f7</span><br></pre></td></tr></table></figure>

<p>再对和求16bit 1的补码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csum = 16bit one’s complement(0x08f7) = 0xf708</span><br></pre></td></tr></table></figure>

<p>可以看到，计算出的结果正好就和报文内原始的值相同，证明报文内的校验和字段是正确的。</p>
<p>当然还有另一种验证方式，在计算16bit 1的补码和时，将校验和的值也加入计算，然后判断最终值是否为0xffff（16bit 1的补码中的-0）。</p>
<p>再看看内核中通用的、非内联汇编版本的IPv4校验和实现<code>ip_fast_csum</code>，调用路径为<code>ip_rcv</code>-&gt;<code>ip_fast_csum</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __sum16 <span class="title">ip_fast_csum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *iph, <span class="keyword">unsigned</span> <span class="keyword">int</span> ihl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *word = iph;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *stop = word + ihl;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> csum;</span><br><span class="line">	<span class="keyword">int</span> carry;</span><br><span class="line"></span><br><span class="line">	csum = word[<span class="number">0</span>];</span><br><span class="line">	csum += word[<span class="number">1</span>];</span><br><span class="line">	carry = (csum &lt; word[<span class="number">1</span>]);</span><br><span class="line">	csum += carry;</span><br><span class="line"></span><br><span class="line">	csum += word[<span class="number">2</span>];</span><br><span class="line">	carry = (csum &lt; word[<span class="number">2</span>]);</span><br><span class="line">	csum += carry;</span><br><span class="line"></span><br><span class="line">	csum += word[<span class="number">3</span>];</span><br><span class="line">	carry = (csum &lt; word[<span class="number">3</span>]);</span><br><span class="line">	csum += carry;</span><br><span class="line"></span><br><span class="line">	word += <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		csum += *word;</span><br><span class="line">		carry = (csum &lt; *word);</span><br><span class="line">		csum += carry;</span><br><span class="line">		word++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (word != stop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> csum_fold(csum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这个函数内，单次计算数据单位为32bit，并没有完全按照RFC的定义进行16bit累加，原因是32bit累加性能更好。</p>
<p>可以很容易想到，16bit累加的结果在32bit累加中是等效的，当低16bit累加发生进位后，会加到高16bit上去，高16bit再发生进位的话，再加回低16bit。这里可以看到代码里通过累加和与加数之间的大小比较，来确定是否发生了进位，如果进位加回累加和。</p>
<p>还有一点需要注意的是，IPv4协议首部是可变长度，最短20字节，为什么这个版本的实现中，先计算了前16字节，而不是20字节呢？这一点我个人的理解是16字节是2的幂，考虑指令、cache等因素下，应该性能会更好。</p>
<p>累加和计算完成后，调用<code>csum_fold</code>对结果进行折叠取反：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __sum16 <span class="title">csum_fold</span><span class="params">(__wsum csum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 sum = (__force u32)csum;</span><br><span class="line">	sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> (__force __sum16)~sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为前面计算的累加和是32bit的，根据1的补码加法定义，高低16bit需要再加在一起，才是最后的结果。从形式上看，就像对累加和进行了折叠（fold）一样。折叠完了以后，就是完整了1的补码和了，再对结果求16bit 1的补码（取反），就得到了最终的校验和。这也是为什么很多地方把校验和计算的过程描述成“累加取反”，但光从这个描述很难和原始定义对应上。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Checksum:  16 bits</span><br><span class="line"></span><br><span class="line">  The checksum field is the 16 bit one&#x27;s complement of the one&#x27;s</span><br><span class="line">  complement sum of all 16 bit words in the header and text.  If a</span><br><span class="line">  segment contains an odd number of header and text octets to be</span><br><span class="line">  checksummed, the last octet is padded on the right with zeros to</span><br><span class="line">  form a 16 bit word for checksum purposes.  The pad is not</span><br><span class="line">  transmitted as part of the segment.  While computing the checksum,</span><br><span class="line">  the checksum field itself is replaced with zeros.</span><br><span class="line"></span><br><span class="line">  The checksum also covers a 96 bit pseudo header conceptually </span><br><span class="line">  prefixed to the TCP header.  This pseudo header contains the Source</span><br><span class="line">  Address, the Destination Address, the Protocol, and TCP length.</span><br><span class="line">  This gives the TCP protection against misrouted segments.  This</span><br><span class="line">  information is carried in the Internet Protocol and is transferred</span><br><span class="line">  across the TCP/Network interface in the arguments or results of</span><br><span class="line">  calls by the TCP on the IP.</span><br><span class="line"></span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line">                   |           Source Address          |</span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line">                   |         Destination Address       |</span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line">                   |  zero  |  PTCL  |    TCP Length   |</span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">    The TCP Length is the TCP header length plus the data length in</span><br><span class="line">    octets (this is not an explicitly transmitted quantity, but is</span><br><span class="line">    computed), and it does not count the 12 octets of the pseudo</span><br><span class="line">    header.</span><br><span class="line">                                                           --RFC793</span><br></pre></td></tr></table></figure>
</blockquote>
<p>和IPv4相比，TCP校验和除了还要计算payload（text）以外，还加上了伪头部（pseudo header），用于验证IPv4的信息是否匹配。伪头部是一个抽象的头部，只是为了在四层头部额外保存三层信息，一定程度上用于确认三层正确性，并不存在于实际报文中。同时，计算校验和时如果总数据不能整除16bit，则在末尾补0计算，这部分0同样只用来计算，也不存在于实际报文中。</p>
<p>以如下报文为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:12:51.140861 a8:0c:ca:5f:8c:5c &gt; 00:50:56:97:d1:f3, ethertype IPv4 (0x0800), length 106: (tos 0x0, ttl 125, id 4094, offset 0, flags [DF], proto TCP (6), length 92)</span><br><span class="line">    172.23.9.13.2774 &gt; 10.103.240.223.22: Flags [P.], cksum 0xccb7 (correct), seq 0:52, ack 46045, win 32544, length 52</span><br><span class="line">        0x0000:  0050 5697 d1f3 a80c ca5f 8c5c 0800 4500  .PV......_.\..E.</span><br><span class="line">        0x0010:  005c 0ffe 4000 7d06 3d33 ac17 090d 0a67  .\..@.&#125;.=3.....g</span><br><span class="line">        0x0020:  f0df 0ad6 0016 6749 d568 1ba4 a329 5018  ......gI.h...)P.</span><br><span class="line">        0x0030:  7f20 ccb7 0000 0000 0010 f43e bdd1 e11e  ...........&gt;....</span><br><span class="line">        0x0040:  e612 f35a d406 61c9 6ed5 5f47 a7e5 5d56  ...Z..a.n._G..]V</span><br><span class="line">        0x0050:  9906 ce6e 15ac af67 e2a6 ffc8 8724 cdff  ...n...g.....$..</span><br><span class="line">        0x0060:  3d3f b304 5838 1883 71f6                 =?..X8..q.</span><br></pre></td></tr></table></figure>

<p>伪头部（src addr + dst addr + zero + protocol + l4 length）为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ac17 090d 0a67 f0df 0000 0006 0000 0048</span><br></pre></td></tr></table></figure>

<p>TCP首部为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0ad6 0016 6749 d568 1ba4 a329 5018 7f20 ccb7 0000</span><br></pre></td></tr></table></figure>

<p>其中校验和为：<code>ccb7</code>，计算校验和时将其置0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0ad6 0016 6749 d568 1ba4 a329 5018 7f20 0000 0000</span><br></pre></td></tr></table></figure>

<p>payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0010 f43e bdd1 e11e e612 f35a d406 61c9 6ed5 5f47 a7e5 5d56 9906 ce6e 15ac af67 e2a6 ffc8 8724 cdff 3d3f b304 5838 1883 71f6</span><br></pre></td></tr></table></figure>

<p>将所有16bit字相加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(32bit integer) = 0xac17 + 0x090d + 0x0a67 + 0xf0df + 0x0000 + 0x0006 + 0x0000 + 0x0048 + 0x0ad6 + 0x0016 + 0x6749 + 0xd568 + 0x1ba4 + 0xa329 + 0x5018 + 0x7f20 + 0x0000 + 0x0000 + 0x0000 + 0x0010 + 0xf43e + 0xbdd1 + 0xe11e + 0xe612 + 0xf35a + 0xd406 + 0x61c9 + 0x6ed5 + 0x5f47 + 0xa7e5 + 0x5d56 + 0x9906 + 0xce6e + 0x15ac + 0xaf67 + 0xe2a6 + 0xffc8 + 0x8724 + 0xcdff + 0x3d3f + 0xb304 + 0x5838 + 0x1883 + 0x71f6</span><br><span class="line">sum(32bit integer) = 0x133335</span><br></pre></td></tr></table></figure>

<p>再根据1的补码的加法原则，将进位加回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(one&#x27;s complement) = 0x3335 + 0x13 (sum + carry)</span><br><span class="line">sum(one&#x27;s complement) = 0x3348</span><br></pre></td></tr></table></figure>

<p>再对和求16bit 1的补码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csum = 16bit one’s complement(0x3348) = 0xccb7</span><br></pre></td></tr></table></figure>

<p>可以看到，计算出的结果正好就和TCP首部的值相同。</p>
<p>内核中使用<code>csum_tcpudp_nofold</code>计算TCP的伪头部和，调用路径：<code>tcp_v4_rcv</code>-&gt;<code>skb_checksum_init</code>-&gt;<code>__skb_checksum_validate</code>-&gt;<code>inet_compute_pseudo</code>-&gt;<code>csum_tcpudp_nofold</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">from64to32</span><span class="params">(u64 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* add up 32-bit and 32-bit for 32+c bit */</span></span><br><span class="line">	x = (x &amp; <span class="number">0xffffffff</span>) + (x &gt;&gt; <span class="number">32</span>);</span><br><span class="line">	<span class="comment">/* add up carry.. */</span></span><br><span class="line">	x = (x &amp; <span class="number">0xffffffff</span>) + (x &gt;&gt; <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">return</span> (u32)x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__wsum <span class="title">csum_tcpudp_nofold</span><span class="params">(__be32 saddr, __be32 daddr,</span></span></span><br><span class="line"><span class="params"><span class="function">			  __u32 len, __u8 proto, __wsum sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> s = (__force u32)sum;</span><br><span class="line"></span><br><span class="line">	s += (__force u32)saddr;</span><br><span class="line">	s += (__force u32)daddr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BIG_ENDIAN</span></span><br><span class="line">	s += proto + len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	s += (proto + len) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> (__force __wsum)from64to32(s);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(csum_tcpudp_nofold);</span><br></pre></td></tr></table></figure>

<p>可以看到除了也是用32bit相加的方式以外，整体流程符合伪头部和计算的定义。还需要注意的一点是，上述调用链中，<code>csum_tcpudp_nofold</code>的参数中<code>len</code>的值为<code>skb-&gt;len</code>，<code>skb-&gt;len</code>代表当前协议层次的数据长度，当前为TCP协议处理流程，所以对应了TCP首部加TCP payload的总长；<code>sum</code>的值为0。</p>
<p>再看<code>skb_checksum_init</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Perform checksum validate (init). Note that this is a macro since we only</span></span><br><span class="line"><span class="comment"> * want to calculate the pseudo header which is an input function if necessary.</span></span><br><span class="line"><span class="comment"> * First we try to validate without any computation (checksum unnecessary) and</span></span><br><span class="line"><span class="comment"> * then calculate based on checksum complete calling the function to compute</span></span><br><span class="line"><span class="comment"> * pseudo header.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *   0: checksum is validated or try to in skb_checksum_complete</span></span><br><span class="line"><span class="comment"> *   non-zero: value of invalid checksum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __skb_checksum_validate(skb, proto, complete,			\</span></span><br><span class="line"><span class="meta">				zero_okay, check, compute_pseudo)	\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">	__sum16 __ret = 0;						\</span></span><br><span class="line"><span class="meta">	skb-&gt;csum_valid = 0;						\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> (__skb_checksum_validate_needed(skb, zero_okay, check))	\</span></span><br><span class="line"><span class="meta">		__ret = __skb_checksum_validate_complete(skb,		\</span></span><br><span class="line"><span class="meta">				complete, compute_pseudo(skb, proto));	\</span></span><br><span class="line"><span class="meta">	__ret;								\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> skb_checksum_init(skb, proto, compute_pseudo)			\</span></span><br><span class="line"><span class="meta">	__skb_checksum_validate(skb, proto, false, false, 0, compute_pseudo)</span></span><br></pre></td></tr></table></figure>

<p><code>skb_checksum_init</code>直接调用了<code>__skb_checksum_validate</code>，可以看到里面逻辑先将<code>skb-&gt;csum_valid</code>初始化，再调用<code>__skb_checksum_validate_needed</code>判断是否需要计算校验和，如果需要的话，再调用<code>__skb_checksum_validate_complete</code>进行具体计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">skb_csum_unnecessary</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((skb-&gt;ip_summed == CHECKSUM_UNNECESSARY) ||</span><br><span class="line">		skb-&gt;csum_valid ||</span><br><span class="line">		(skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">		 skb_checksum_start_offset(skb) &gt;= <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we need to perform checksum complete validation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true if checksum complete is needed, false otherwise</span></span><br><span class="line"><span class="comment"> * (either checksum is unnecessary or zero checksum is allowed).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> __skb_checksum_validate_needed(struct sk_buff *skb,</span><br><span class="line">						  <span class="keyword">bool</span> zero_okay,</span><br><span class="line">						  __sum16 check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb_csum_unnecessary(skb) || (zero_okay &amp;&amp; !check)) &#123;</span><br><span class="line">		skb-&gt;csum_valid = <span class="number">1</span>;</span><br><span class="line">		__skb_decr_checksum_unnecessary(skb);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__skb_checksum_validate_needed</code>中逻辑较为简单，当<code>skb_csum_unnecessary</code>返回<code>true</code>或当前校验和<code>check</code>为<code>0</code>并且为0的校验和是合法值时，将<code>skb-&gt;csum_valid</code>置1，并且调整skb中<code>CHECKSUM_UNNECESSARY</code>相关成员的值，返回<code>false</code>，否则返回<code>true</code>。</p>
<p><code>skb_csum_unnecessary</code>中则是根据<code>skb-&gt;ip_summed</code>以及其他skb的信息判断是否有必要计算校验和：</p>
<ul>
<li><code>skb-&gt;ip_summed == CHECKSUM_UNNECESSARY</code>：无需计算，和上面对<code>CHECKSUM_UNNECESSARY</code>的分析一致，这种情况下硬件已经确认校验和正确，协议栈不需要任何计算。</li>
<li><code>skb-&gt;csum_valid == 1</code>：无需计算，当前协议层次的校验和已被确认为合法值。</li>
<li><code>skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp; skb_checksum_start_offset(skb) &gt;= 0</code>：无需计算，<code>CHECKSUM_PARTIAL</code>代表部分校验和已被硬件计算，<code>skb_checksum_start_offset(skb)</code>代表<code>skb-&gt;csum_start</code>合法，即已被计算的那部分校验和是合法的。</li>
<li>其他情况：需要计算。</li>
</ul>
<p>需要计算校验和的场景，调用<code>__skb_checksum_validate_complete</code>进行计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Validate (init) checksum based on checksum complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *   0: checksum is validated or try to in skb_checksum_complete. In the latter</span></span><br><span class="line"><span class="comment"> *	case the ip_summed will not be CHECKSUM_UNNECESSARY and the pseudo</span></span><br><span class="line"><span class="comment"> *	checksum is stored in skb-&gt;csum for use in __skb_checksum_complete</span></span><br><span class="line"><span class="comment"> *   non-zero: value of invalid checksum</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __sum16 __skb_checksum_validate_complete(struct sk_buff *skb,</span><br><span class="line">						       <span class="keyword">bool</span> complete,</span><br><span class="line">						       __wsum psum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_COMPLETE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!csum_fold(csum_add(psum, skb-&gt;csum))) &#123;</span><br><span class="line">			skb-&gt;csum_valid = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skb-&gt;csum = psum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (complete || skb-&gt;len &lt;= CHECKSUM_BREAK) &#123;</span><br><span class="line">		__sum16 csum;</span><br><span class="line"></span><br><span class="line">		csum = __skb_checksum_complete(skb);</span><br><span class="line">		skb-&gt;csum_valid = !csum;</span><br><span class="line">		<span class="keyword">return</span> csum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准确来说，<code>__skb_checksum_validate_complete</code>只处理<code>CHECKSUM_COMPLETE</code>相关的场景。</p>
<p>特别地，当<code>skb-&gt;ip_summed == CHECKSUM_COMPLETE</code>时，根据前面对<code>CHECKSUM_COMPLETE</code>场景的分析，此时<code>skb-&gt;csum</code>保存的是L4开始的1的补码和，直接将<code>skb-&gt;csum</code>和<code>psum</code>累加取反即可得到TCP校验和。</p>
<p>对于特殊场景，如下面的分支中，会直接调用<code>__skb_checksum_complete</code>进行完整计算，否则只保存伪头部和，在后续流程中（如<code>tcp_v4_rcv</code>-&gt;<code>tcp_v4_do_rcv</code>-&gt;<code>tcp_checksum_complete</code>）再进行完整计算。</p>
<p><code>tcp_checksum_complete</code>最终也是调用<code>__skb_checksum_complete</code>进行计算，其中逻辑大概也是求补码和，然后取反。求补码和的地方相对比较复杂，涉及skb链的场景，就不细说了。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Checksum is the 16-bit one&#x27;s complement of the one&#x27;s complement sum of a</span><br><span class="line">pseudo header of information from the IP header, the UDP header, and the</span><br><span class="line">data,  padded  with zero octets  at the end (if  necessary)  to  make  a</span><br><span class="line">multiple of two octets.</span><br><span class="line">                                                               --RFC 768</span><br></pre></td></tr></table></figure>
</blockquote>
<p>UDP首部校验和与TCP校验和的计算方式基本一致，也需要计算伪头部，但不需要计算payload，具体流程就不展开细说了。</p>
<p>一个典型的调用链：<code>udp_rcv</code>-&gt;<code>__udp4_lib_rcv</code>-&gt;<code>udp4_csum_init</code>-&gt;<code>skb_checksum_init_zero_check</code>。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Record of using kprobe</title>
    <url>/2023/01/21/Record-of-using-kprobe/</url>
    <content><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>之前在生产环境排查了一个TCP的ACK无法被正确接收，导致发送端一直重传，最终接收端keepalive超时后关闭连接的问题（<a href="https://patchwork.ozlabs.org/project/netfilter-devel/patch/20220818224231.11583-1-fw@strlen.de/">[nf] netfilter: conntrack: work around exceeded receive window</a>）。排查过程中主要用到了kprobe这个动态调试手段去分析内核代码执行的情况，这里简单记录下。</p>
<h1 id="Kprobe"><a href="#Kprobe" class="headerlink" title="Kprobe"></a>Kprobe</h1><p>kprobe是一种内核的动态调试机制，可以在几乎所有内核代码上进行插桩，当执行到对应的代码时，先执行插桩函数，执行完毕后，在继续运行后续逻辑。它的实现逻辑基本上就是指令替换，将运行指令跳转到用户定义好的kprobe handler。</p>
<p>上面说了是几乎所有内核代码，有几种场景无法正常kprobe：</p>
<ul>
<li>kprobe自身相关的代码：没法嵌套kprobe自身</li>
<li>内联函数：内联函数在编译时会被展开到所有的调用处，kprobe实际上是根据符号对应的地址进行的，不能确认所有内联函数展开后的地址，这种情况需要计算内联函数的调用地址来进行kprobe</li>
<li>一些被优化后的静态函数</li>
</ul>
<p>同时kprobe有两种实现形式：</p>
<ul>
<li>基于debugfs/ftrace的简易实现：对于一些简单场景，如获取函数参数，或者函数返回值的场景，可以直接使用</li>
<li>基于内核模块的实现：可以实现一些复杂功能和逻辑，适用于复杂的场景</li>
</ul>
<h2 id="kprobe-based-on-ftrace"><a href="#kprobe-based-on-ftrace" class="headerlink" title="kprobe based on ftrace"></a>kprobe based on ftrace</h2><p>用户可以直接通过<code>/sys/kernel/debug/tracing/kprobe_events</code>添加kprobe，语法如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> p[:[GRP/][EVENT]] [MOD:]SYM[+offs]|MEMADDR [FETCHARGS]        : Set a probe</span><br><span class="line"> r[MAXACTIVE][:[GRP/][EVENT]] [MOD:]SYM[+0] [FETCHARGS]        : Set a return probe</span><br><span class="line"> p[:[GRP/][EVENT]] [MOD:]SYM[+0]%return [FETCHARGS]    : Set a return probe</span><br><span class="line"> -:[GRP/][EVENT]                                               : Clear a probe</span><br><span class="line"></span><br><span class="line">GRP            : Group name. If omitted, use &quot;kprobes&quot; for it.</span><br><span class="line">EVENT          : Event name. If omitted, the event name is generated</span><br><span class="line">                 based on SYM+offs or MEMADDR.</span><br><span class="line">MOD            : Module name which has given SYM.</span><br><span class="line">SYM[+offs]     : Symbol+offset where the probe is inserted.</span><br><span class="line">SYM%return     : Return address of the symbol</span><br><span class="line">MEMADDR        : Address where the probe is inserted.</span><br><span class="line">MAXACTIVE      : Maximum number of instances of the specified function that</span><br><span class="line">                 can be probed simultaneously, or 0 for the default value</span><br><span class="line">                 as defined in Documentation/trace/kprobes.rst section 1.3.1.</span><br><span class="line"></span><br><span class="line">FETCHARGS      : Arguments. Each probe can have up to 128 args.</span><br><span class="line"> %REG          : Fetch register REG</span><br><span class="line"> @ADDR         : Fetch memory at ADDR (ADDR should be in kernel)</span><br><span class="line"> @SYM[+|-offs] : Fetch memory at SYM +|- offs (SYM should be a data symbol)</span><br><span class="line"> $stackN       : Fetch Nth entry of stack (N &gt;= 0)</span><br><span class="line"> $stack        : Fetch stack address.</span><br><span class="line"> $argN         : Fetch the Nth function argument. (N &gt;= 1) (\*1)</span><br><span class="line"> $retval       : Fetch return value.(\*2)</span><br><span class="line"> $comm         : Fetch current task comm.</span><br><span class="line"> +|-[u]OFFS(FETCHARG) : Fetch memory at FETCHARG +|- OFFS address.(\*3)(\*4)</span><br><span class="line"> \IMM          : Store an immediate value to the argument.</span><br><span class="line"> NAME=FETCHARG : Set NAME as the argument name of FETCHARG.</span><br><span class="line"> FETCHARG:TYPE : Set TYPE as the type of FETCHARG. Currently, basic types</span><br><span class="line">                 (u8/u16/u32/u64/s8/s16/s32/s64), hexadecimal types</span><br><span class="line">                 (x8/x16/x32/x64), &quot;string&quot;, &quot;ustring&quot; and bitfield</span><br><span class="line">                 are supported.</span><br><span class="line"></span><br><span class="line"> (\*1) only for the probe on function entry (offs == 0).</span><br><span class="line"> (\*2) only for return probe.</span><br><span class="line"> (\*3) this is useful for fetching a field of data structures.</span><br><span class="line"> (\*4) &quot;u&quot; means user-space dereference. See :ref:`user_mem_access`.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当kprobe添加完成后，会生成对应的kprobe目录：<code>/sys/kernel/debug/tracing/events/kprobes/&lt;EVENT&gt;</code>，可以通过<code>/sys/kernel/debug/tracing/events/kprobes/&lt;EVENT&gt;/enable</code>去控制对应kprobe的启用禁用。</p>
<p>官方示例（应该是32位的x86），对<code>do_sys_open</code>，可通过如下kprobe获取其参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)&#x27;</span> &gt; /sys/kernel/debug/tracing/kprobe_events</span><br></pre></td></tr></table></figure>

<p>各个参数含义如下：</p>
<ul>
<li><code>p</code>：kprobe类型为kprobe</li>
<li><code>myprobe</code>：event名称</li>
<li><code>do_sys_open</code>：进行kprobe的函数名</li>
<li><code>dfd=%ax filename=%dx flags=%cx mode=+4($stack)</code>：获取参数并输出，<code>%ax</code>、<code>%dx</code>、<code>%cx</code>和<code>+4($stack)</code>分别为寄存器名字和栈上偏移</li>
</ul>
<p>可通过如下kprobe获取返回值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r:myretprobe do_sys_open $retval&#x27;</span> &gt;&gt; /sys/kernel/debug/tracing/kprobe_events</span><br></pre></td></tr></table></figure>

<p>各个参数含义如下：</p>
<ul>
<li><code>r</code>：kprobe类型为kretprobe</li>
<li><code>myretprobe</code>：event名称</li>
<li><code>do_sys_open</code>：进行kprobe的函数名</li>
<li><code>$retval</code>：获取返回值并输出</li>
</ul>
<p>启用这两个kprobe：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myprobe/<span class="built_in">enable</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myretprobe/<span class="built_in">enable</span></span><br></pre></td></tr></table></figure>

<p>开启ftrace：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure>

<p>查看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace</span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286875: myprobe: (do_sys_open+0x0/0xd6) dfd=3 filename=7fffd1ec4440 flags=8000 mode=0</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286878: myretprobe: (sys_openat+0xc/0xe &lt;- do_sys_open) <span class="variable">$retval</span>=fffffffffffffffe</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286885: myprobe: (do_sys_open+0x0/0xd6) dfd=ffffff9c filename=40413c flags=8000 mode=1b6</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286915: myretprobe: (sys_open+0x1b/0x1d &lt;- do_sys_open) <span class="variable">$retval</span>=3</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286969: myprobe: (do_sys_open+0x0/0xd6) dfd=ffffff9c filename=4041c6 flags=98800 mode=10</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286976: myretprobe: (sys_open+0x1b/0x1d &lt;- do_sys_open) <span class="variable">$retval</span>=3</span><br></pre></td></tr></table></figure>

<p>详细使用方式可以参考：<a href="https://www.kernel.org/doc/html/latest/trace/kprobetrace.html">Kprobe-based Event Tracing</a></p>
<p>上面为直接在debugfs下操作，操作比较繁琐，也有一些现成的工具<a href="https://github.com/iovisor/bpftrace">bpftrace</a>和<a href="https://github.com/brendangregg/perf-tools/blob/master/kernel/kprobe">perf-tools</a>对debugfs下的操作进行了封装，可以简化操作步骤。</p>
<h2 id="kprobe-module"><a href="#kprobe-module" class="headerlink" title="kprobe module"></a>kprobe module</h2><p>kprobe最原始的使用方式是编译一个内核模块，在模块内部进行kprobe的注册handler，在handler实现所需要的逻辑。</p>
<p>这种方式提供了很强大的自由度，缺点就是使用难度较高，在一些需要复杂一点的逻辑的地方可以使用，<a href="https://www.kernel.org/doc/Documentation/kprobes.txt">内核文档</a>对这种方式进行了详细说明。</p>
<p>以上述排查ACK是否有被正常接收的问题为例，通过看代码可以确认，对应ACK处理函数为<code>tcp_ack</code>，参数中包含了<code>skb</code>，基于ftrace的kprobe可以获取到<code>skb</code>，甚至可以通过偏移获取到<code>skb</code>的成员，但问题在于，在一个正常的Linux环境，每秒处理的ACK太多了，这种kprobe没法精确过滤所需内容，所以需要自行编写过滤逻辑，并输出期望的内容。</p>
<p>排查过程中用到的部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre_tcp_ack</span><span class="params">(struct kprobe *p, struct pt_regs *regs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> <span class="title">kp_tcp_ack</span> =</span> &#123;</span><br><span class="line">	.symbol_name = <span class="string">&quot;tcp_ack&quot;</span>,</span><br><span class="line">	.pre_handler = pre_tcp_ack,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre_tcp_ack</span><span class="params">(struct kprobe *p, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">	skb = (struct sk_buff *)regs-&gt;si;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_hdr(skb)-&gt;source != htons(<span class="number">7001</span>) &amp;&amp; tcp_hdr(skb)-&gt;dest != htons(<span class="number">7001</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flag = (<span class="keyword">int</span>)regs-&gt;dx;</span><br><span class="line">	printk(<span class="string">&quot;Get ACK: %u(%x) in tcp_ack(flag: %d).\n&quot;</span>, TCP_SKB_CB(skb)-&gt;ack_seq, TCP_SKB_CB(skb)-&gt;ack_seq, flag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (register_kprobe(&amp;kp_tcp_ack)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;trace-ack loaded.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fini</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unregister_kprobe(&amp;kp_tcp_ack);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;trace-ack unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init);</span><br><span class="line">module_exit(fini);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到整体逻辑非常简单，在<code>module_init</code>中通过<code>register_kprobe</code>注册kprobe，在<code>module_exit</code>中通过<code>unregister_kprobe</code>取消kprobe的注册。</p>
<p><code>struct kprobe</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* list of kprobes for multi-handler support */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*count the number of times this probe was temporarily disarmed */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nmissed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* location of the probe point */</span></span><br><span class="line">	<span class="keyword">kprobe_opcode_t</span> *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow user to indicate symbol name of the probe point */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *symbol_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Offset into the symbol */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called before addr is executed. */</span></span><br><span class="line">	<span class="keyword">kprobe_pre_handler_t</span> pre_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called after addr is executed, unless... */</span></span><br><span class="line">	<span class="keyword">kprobe_post_handler_t</span> post_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ... called if executing addr causes a fault (eg. page fault).</span></span><br><span class="line"><span class="comment">	 * Return 1 if it handled fault, otherwise kernel will see it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">kprobe_fault_handler_t</span> fault_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ... called if breakpoint trap occurs in probe handler.</span></span><br><span class="line"><span class="comment">	 * Return 1 if it handled break, otherwise kernel will see it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">kprobe_break_handler_t</span> break_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Saved opcode (which has been replaced with breakpoint) */</span></span><br><span class="line">	<span class="keyword">kprobe_opcode_t</span> opcode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy of the original instruction */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_specific_insn</span> <span class="title">ainsn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Indicates various status flags.</span></span><br><span class="line"><span class="comment">	 * Protected by kprobe_mutex after this kprobe is registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员很多，通常只需关注<code>handler</code>和<code>symbol</code>：</p>
<ul>
<li>handler：对应事件发生时，所执行的函数</li>
<li>symbol：需要probe的符号名，即函数名</li>
</ul>
<p>根据<code>symbol</code>在完成对应类型的<code>handler</code>编写，最后将kprobe注册到内核，即可正常工作。</p>
<p>可以看到上面的例子中的<code>pre_handler</code>为<code>pre_tcp_ack</code>，在其内部先是获取到了<code>skb</code>，再根据端口号过滤掉不需要的<code>skb</code>，再输出TCP的<code>seq</code>和<code>ack</code>。</p>
<p>使用<code>symbol</code>注册的kprobe只能在特定函数的入口/出口执行，<code>struct kprobe</code>还有成员<code>addr</code>和<code>offset</code>，可以用于精确指定probe的地址，但这种使用方式难度很大，获取所需参数时需要通过汇编代码确认对应的寄存器，再获取。而在函数入口的kprobe可以根据对应架构的传参规范通过对应寄存器直接获取，关于通过寄存器获取函数参数的方式，也可以参考<code>bpf_tracing.h</code>中的<code>PT_REGS_PARAM1</code>类似宏。</p>
<h1 id="Systemtap"><a href="#Systemtap" class="headerlink" title="Systemtap"></a>Systemtap</h1><p><a href="https://sourceware.org/systemtap/index.html">systemtap</a>是一个基于kprobe开发的动态调试工具，功能非常强大，有自己的脚本语言（完整语法规范参考<a href="https://sourceware.org/systemtap/langref.pdf">SystemTap Language Reference</a>），可以通过编写systemtap脚本的方式，由systemtap生成对应的kprobe代码并加载到内核运行。这样用户的开发难度就大大降低了，不再需要懂内核编程，也不需要有内核编译环境。</p>
<p>systemtap的安装使用在大多数的Linux发行版上都比较容易，直接通过对应的包管理工具安装即可，需要注意的是同时需要安装对应内核debuginfo，因为systemtap是通过vmlinux和debuginfo去确定probe点的。</p>
<h2 id="无debuginfo使用systemtap"><a href="#无debuginfo使用systemtap" class="headerlink" title="无debuginfo使用systemtap"></a>无debuginfo使用systemtap</h2><p>对于没有debuginfo的生产环境是否可以使用systemtap呢？答案是可以的，但是要有目标环境对应的内核编译环境。</p>
<p>因为systemtap的工作原理就是先生成内核模块再加载执行，我们可以把这两步分开，在编译环境上生成对应的内核模块，在目标环境上加载模块进行调试。</p>
<p>以内核模块<code>xt_state</code>中的函数<code>state_mt</code>为例，首先查看对应的probe点，以及局部变量，注意使用<code>-r</code>指定内核代码路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8/ -L &#x27;module(&quot;xt_state&quot;).function(&quot;state_mt@net/netfilter/xt_state.c&quot;)&#x27;</span></span><br><span class="line">module(<span class="string">&quot;xt_state&quot;</span>).<span class="keyword">function</span>(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:24&quot;</span>) <span class="variable">$skb</span>:struct sk_buff const* <span class="variable">$par</span>:struct xt_action_param* <span class="variable">$sinfo</span>:struct xt_state_info const*</span><br></pre></td></tr></table></figure>

<p>可以将<code>function</code>换成<code>statement</code>，以将probe点指定到具体行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#sed -n &#x27;23, 39p&#x27; /home/kernel.rh8/net/netfilter/xt_state.c</span></span><br><span class="line">static bool</span><br><span class="line">state_mt(const struct sk_buff *skb, struct xt_action_param *par)</span><br><span class="line">&#123;</span><br><span class="line">        const struct xt_state_info *sinfo = par-&gt;matchinfo;</span><br><span class="line">        enum ip_conntrack_info ctinfo;</span><br><span class="line">        unsigned int statebit;</span><br><span class="line">        struct nf_conn *ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ct) /* line 31 */</span><br><span class="line">                statebit = XT_STATE_BIT(ctinfo);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctinfo == IP_CT_UNTRACKED)</span><br><span class="line">                statebit = XT_STATE_UNTRACKED;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                statebit = XT_STATE_INVALID;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> (sinfo-&gt;statemask &amp; statebit);</span><br><span class="line">&#125;</span><br><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8/ -L &#x27;module(&quot;xt_state&quot;).statement(&quot;*@net/netfilter/xt_state.c:31&quot;)&#x27;</span></span><br><span class="line">module(<span class="string">&quot;xt_state&quot;</span>).statement(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:31&quot;</span>) <span class="variable">$skb</span>:struct sk_buff const* <span class="variable">$par</span>:struct xt_action_param* <span class="variable">$sinfo</span>:struct xt_state_info const* <span class="variable">$ctinfo</span>:enum ip_conntrack_info</span><br><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8/ -L &#x27;module(&quot;xt_state&quot;).statement(&quot;*@net/netfilter/xt_state.c:38&quot;)&#x27;</span></span><br><span class="line">module(<span class="string">&quot;xt_state&quot;</span>).statement(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:38&quot;</span>) <span class="variable">$skb</span>:struct sk_buff const* <span class="variable">$par</span>:struct xt_action_param* <span class="variable">$sinfo</span>:struct xt_state_info const* <span class="variable">$statebit</span>:unsigned int</span><br></pre></td></tr></table></figure>

<p>可以看到在不同的probe点，可以访问的局部变量也是不一样的，但是关于局部变量还有一点疑惑：以31行为例，其实应该是还能访问<code>statebit</code>和<code>ct</code>这两个变量的，但probe显示出来的变量并不包含这两个，可能是对变量做了一些优化，一些还没赋值的变量（<code>statebit</code>）和一些变量可以间接通过其他变量获取（<code>ct</code>）被优化掉了。</p>
<p>编写如下systemtap脚本用于在<code>state_mt</code>内部输出<code>ctinfo</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Part 1: Global embedded C include */</span></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/x_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/xt_state.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netfilter/nf_conntrack_core.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">/* Part 1 end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Part2: Embedded C function */</span></span><br><span class="line"><span class="function">function <span class="title">print_ctinfo</span> <span class="params">(skb, ctinfo)</span></span></span><br><span class="line"><span class="function">%</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ip_conntrack_info</span> <span class="title">ctinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	skb = (struct sk_buff *)STAP_ARG_skb;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;protocol != htons(ETH_P_IP)) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	<span class="keyword">if</span> (!iph) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	th = tcp_hdr(skb);</span><br><span class="line">	<span class="keyword">if</span> (!th) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;dest != htons(<span class="number">22</span>)) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctinfo = STAP_ARG_ctinfo;</span><br><span class="line">	<span class="keyword">if</span> (printk_ratelimit()) &#123;</span><br><span class="line">		printk(<span class="string">&quot;[%s] Capture TCP packet: %hu.%hu.%hu.%hu:%hu-&gt;%hu.%hu.%hu.%hu:%hu with ctinfo: %d.\n&quot;</span>,</span><br><span class="line">			   __func__,</span><br><span class="line">			   iph-&gt;saddr &amp; <span class="number">0xff</span>, (iph-&gt;saddr &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, (iph-&gt;saddr &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, (iph-&gt;saddr &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>,</span><br><span class="line">			   ntohs(th-&gt;source),</span><br><span class="line">			   iph-&gt;daddr &amp; <span class="number">0xff</span>, (iph-&gt;daddr &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, (iph-&gt;daddr &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, (iph-&gt;daddr &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>,</span><br><span class="line">			   ntohs(th-&gt;dest),</span><br><span class="line">			   ctinfo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	STAP_RETURN();</span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">/* Part 2 end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Part 3: Probes */</span></span><br><span class="line"><span class="function">probe <span class="title">module</span><span class="params">(<span class="string">&quot;xt_state&quot;</span>)</span>.<span class="title">statement</span><span class="params">(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:31&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	print_ctinfo($skb, $ctinfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">&quot;probe start.\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">probe end</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">&quot;probe end.\n&quot;</span>)</span><br><span class="line">	<span class="built_in">exit</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Part3 end */</span></span><br></pre></td></tr></table></figure>

<p>脚本分为3部分：</p>
<ul>
<li>Part 1：嵌入的C代码的全局include，因为后续嵌入的C函数需要一些头文件，所以在开头定义好。</li>
<li>Part 2：功能函数<code>print_ctinfo</code>，接受两个参数<code>skb</code>和<code>ctinfo</code>。</li>
<li>Part 3：声明探测点probe</li>
</ul>
<p>Part 1和Part 2使用了嵌入C代码，关于嵌入C代码，有如下几个特点：</p>
<ul>
<li>最外层使用<code>%&#123;...%&#125;</code>这样的括号</li>
<li>获取函数参数通过<code>STAP_ARG_</code>前缀加上参数名获取，如<code>STAP_ARG_skb</code></li>
<li>函数内部使用<code>STAP_RETURN()</code>进行返回，参数不为空时可以为字符串或整数，和函数定义时的返回类型相同。</li>
<li>函数内部使用<code>STAP_RETVALUE</code>作为返回值，可以为整数或字符串，字符串返回时需使用<code>snprintf</code>类似的函数为其赋值。</li>
</ul>
<p>Part 2中<code>print_ctinfo</code>内部通过参数获取到<code>skb</code>和<code>ctinfo</code>，并进行合法性检查，通过合法性检查后，直接通过<code>printk</code>输出<code>skb</code>和<code>ctinfo</code>相关的信息。</p>
<p>Part 3中定义了3个probe，分别为<code>xt_state.c</code>第31行对应地址的probe，以及两个内建probe start 和end，分别在运行的开始和结束处调用。</p>
<p>systemtap脚本编写完成后，即可使用<code>stap</code>命令编译对应的模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8 -DSTP_NO_OVERLOAD -DSTP_NO_VERREL_CHECK  -DSTP_NO_BUILDID_CHECK -v -p4 -m print_ctinfo.ko -g print_ctinfo.stp </span></span><br><span class="line">Truncating module name to <span class="string">&#x27;print_ctinfo&#x27;</span></span><br><span class="line">Pass 1: parsed user script and 484 library scripts using 155264virt/96900res/2956shr/93944data kb, <span class="keyword">in</span> 290usr/50sys/337real ms.</span><br><span class="line">Pass 2: analyzed script: 3 probes, 4 <span class="built_in">functions</span>, 1 embed, 0 globals using 157656virt/100236res/3944shr/96336data kb, <span class="keyword">in</span> 50usr/380sys/431real ms.</span><br><span class="line">Pass 3: translated to C into <span class="string">&quot;/tmp/stap7rcpFZ/print_ctinfo_src.c&quot;</span> using 157920virt/100756res/4216shr/96600data kb, <span class="keyword">in</span> 30usr/380sys/414real ms.</span><br><span class="line">print_ctinfo.ko</span><br><span class="line">Pass 4: compiled C into <span class="string">&quot;print_ctinfo.ko&quot;</span> <span class="keyword">in</span> 2270usr/760sys/2612real ms.</span><br><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#file print_ctinfo.ko </span></span><br><span class="line">print_ctinfo.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=0xd1741342db5acb8c31f82e5684273aae24125c82, not stripped</span><br></pre></td></tr></table></figure>

<p><code>stap</code>的执行一共有5个阶段，分别为：<code>parse</code>、<code>elaborate</code>、<code>translate</code>、<code>compile</code>和<code>run</code>，可以通过<code>-p</code>指定执行阶段。上述指定了<code>-p4</code>的命令最终编译出了可用的内核模块<code>print_ctinfo.ko</code>。</p>
<p>在运行环境上，则可以直接通过<code>staprun</code>命令进行probe，该命令会自动加载模块，命令执行完成后，会自动卸载模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./staprun print_ctinfo.ko</span></span><br><span class="line">probe start.</span><br></pre></td></tr></table></figure>

<p>此时观察内核日志，可以找到期望的输出，可以看到成功过滤了经过<code>state_mt</code>的SSH报文并且输出了相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-12-08 17:37:07.614013 warning [kernel:] [171938.274058] [function___global_print_ctinfo__overload_0] Capture TCP packet: 172.23.9.13:7037-&gt;10.103.240.223:22 with ctinfo: 0.</span><br><span class="line">2022-12-08 17:37:07.623029 warning [kernel:] [171938.283066] [function___global_print_ctinfo__overload_0] Capture TCP packet: 10.103.241.85:51515-&gt;10.103.240.223:22 with ctinfo: 0.</span><br><span class="line">2022-12-08 17:37:07.623997 warning [kernel:] [171938.284053] [function___global_print_ctinfo__overload_0] Capture TCP packet: 172.23.9.13:7037-&gt;10.103.240.223:22 with ctinfo: 0.</span><br></pre></td></tr></table></figure>

<p><code>stap</code>在运行过程中，会将生成的C代码放在临时目录，可以通过<code>-k</code>选项保留临时目录，然后查看对应的C代码。上述自定义函数<code>print_ctinfo</code>生成的目标C代码部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function___global_print_ctinfo__overload_0</span> <span class="params">(struct context* __restrict__ c)</span> </span>&#123;</span><br><span class="line">  __label__ deref_fault;</span><br><span class="line">  __label__ out;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">function___global_print_ctinfo__overload_0_locals</span> *  __<span class="title">restrict__</span> <span class="title">l</span> =</span> &amp; c-&gt;locals[c-&gt;nesting+<span class="number">1</span>].function___global_print_ctinfo__overload_0;</span><br><span class="line">  (<span class="keyword">void</span>) l;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> CONTEXT c</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> THIS l</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_ARG_skb THIS-&gt;l_skb</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_ARG_ctinfo THIS-&gt;l_ctinfo</span></span><br><span class="line">  c-&gt;last_stmt = <span class="string">&quot;identifier &#x27;print_ctinfo&#x27; at print_ctinfo.stp:8:10&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (unlikely (c-&gt;nesting+<span class="number">1</span> &gt;= MAXNESTING)) &#123;</span><br><span class="line">    c-&gt;last_error = <span class="string">&quot;MAXNESTING exceeded&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c-&gt;nesting ++;</span><br><span class="line">  &#125;</span><br><span class="line">  c-&gt;next = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_NEXT do &#123; c-&gt;next = 1; goto out; &#125; while(0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_RETURN() do &#123; goto out; &#125; while(0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_PRINTF(fmt, ...) do &#123; _stp_printf(fmt, ##__VA_ARGS__); &#125; while (0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_ERROR(...) do &#123; snprintf(CONTEXT-&gt;error_buffer, MAXSTRINGLEN, __VA_ARGS__); CONTEXT-&gt;last_error = CONTEXT-&gt;error_buffer; goto out; &#125; while (0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> return goto out</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;actionremaining &lt; <span class="number">0</span>) &#123; c-&gt;last_error = <span class="string">&quot;MAXACTION exceeded&quot;</span>;<span class="keyword">goto</span> out; &#125;</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">ip_conntrack_info</span> <span class="title">ctinfo</span>;</span></span><br><span class="line"></span><br><span class="line">        skb = (struct sk_buff *)STAP_ARG_skb;</span><br><span class="line">        <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">                STAP_RETURN();</span><br></pre></td></tr></table></figure>

<p>可以看到一些在函数体内部使用的宏，如<code>STAP_RETURN</code>，在函数开头都有定义，生成的函数名<code>function___global_print_ctinfo__overload_0</code>也和内核日志中一致。</p>
<p>除了内核函数的probe，systemtap还支持许多其他类型的probe，可通过<code>stap --dump-probe-types</code>查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8 --dump-probe-types</span></span><br><span class="line">......</span><br><span class="line">netfilter.hook(string).pf(string)</span><br><span class="line">netfilter.hook(string).pf(string).priority(string)</span><br><span class="line">netfilter.pf(string).hook(string)</span><br><span class="line">netfilter.pf(string).hook(string).priority(string)</span><br><span class="line">......</span><br><span class="line">process(string).begin</span><br><span class="line">process(string).end</span><br><span class="line">......</span><br><span class="line">procfs(string).<span class="built_in">read</span></span><br><span class="line">procfs(string).read.maxsize(number)</span><br><span class="line">......</span><br><span class="line">python2.module(string).<span class="keyword">function</span>(string)</span><br><span class="line">python2.module(string).<span class="keyword">function</span>(string).call</span><br><span class="line">python2.module(string).<span class="keyword">function</span>(string).<span class="built_in">return</span></span><br><span class="line">python3.module(string).<span class="keyword">function</span>(string)</span><br><span class="line">python3.module(string).<span class="keyword">function</span>(string).call</span><br><span class="line">python3.module(string).<span class="keyword">function</span>(string).<span class="built_in">return</span></span><br><span class="line">......</span><br><span class="line">timer.hz(number)</span><br><span class="line">timer.jiffies(number)</span><br><span class="line">timer.jiffies(number).randomize(number)</span><br></pre></td></tr></table></figure>

<p>包含了许多针对特定场景的probe，包括对用户态的进程、python模块等。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>A multiplication overflow problem</title>
    <url>/2023/01/21/A-multiplication-overflow-problem/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>我司产品从内核ct抄了一份ip解析的代码在应用层使用，在客户跑业务的时候coredump掉了，从堆栈分析看是做乘法过程中整数溢出abort了，在这里简单记录下。</p>
<h1 id="in4-pton"><a href="#in4-pton" class="headerlink" title="in4_pton"></a>in4_pton</h1><p>问题函数为<code>in4_pton</code>，用于将字符串ip转换成二进制ip，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * in4_pton - convert an IPv4 address from literal to binary representation</span></span><br><span class="line"><span class="comment"> * @src: the start of the IPv4 address string</span></span><br><span class="line"><span class="comment"> * @srclen: the length of the string, -1 means strlen(src)</span></span><br><span class="line"><span class="comment"> * @dst: the binary (u8[4] array) representation of the IPv4 address</span></span><br><span class="line"><span class="comment"> * @delim: the delimiter of the IPv4 address in @src, -1 means no delimiter</span></span><br><span class="line"><span class="comment"> * @end: A pointer to the end of the parsed string will be placed here</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return one on success, return zero when any error occurs</span></span><br><span class="line"><span class="comment"> * and @end will point to the end of the parsed string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in4_pton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">int</span> srclen,</span></span></span><br><span class="line"><span class="params"><span class="function">	     u8 *dst,</span></span></span><br><span class="line"><span class="params"><span class="function">	     <span class="keyword">int</span> delim, <span class="keyword">const</span> <span class="keyword">char</span> **end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line">	u8 *d;</span><br><span class="line">	u8 dbuf[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (srclen &lt; <span class="number">0</span>)</span><br><span class="line">		srclen = <span class="built_in">strlen</span>(src);</span><br><span class="line">	s = src;</span><br><span class="line">	d = dbuf;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> c;</span><br><span class="line">		c = xdigit2bin(srclen &gt; <span class="number">0</span> ? *s : <span class="string">&#x27;\0&#x27;</span>, delim);</span><br><span class="line">		<span class="keyword">if</span> (!(c &amp; (IN6PTON_DIGIT | IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK))) &#123;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c &amp; (IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (w == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			*d++ = w &amp; <span class="number">0xff</span>;</span><br><span class="line">			w = <span class="number">0</span>;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (c &amp; (IN6PTON_DELIM | IN6PTON_COLON_MASK)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">4</span>)</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> cont;</span><br><span class="line">		&#125;</span><br><span class="line">		w = (w * <span class="number">10</span>) + c; <span class="comment">/* Coredump here. */</span></span><br><span class="line">		<span class="keyword">if</span> ((w &amp; <span class="number">0xffff</span>) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">cont:</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		s++;</span><br><span class="line">		srclen--;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, dbuf, <span class="keyword">sizeof</span>(dbuf));</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (end)</span><br><span class="line">		*end = s;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(in4_pton);</span><br></pre></td></tr></table></figure>

<p>导致coredump的代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w = (w * <span class="number">10</span>) + c;</span><br></pre></td></tr></table></figure>

<p>coredump堆栈为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  0x00007f9563a35428 in raise () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">#1  0x00007f9563a3702a in abort () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">#2  0x000056378c35c332 in __mulvsi3 ()</span><br><span class="line">#3  0x000056378bdcec16 in in4_pton (delim=-1, end=&lt;synthetic pointer&gt;, dst=0x7f95355e9a44 &quot;&quot;, srclen=566, </span><br><span class="line">    src=0x50005e1169ba &lt;error: Cannot access memory at address 0x50005e1169ba&gt;)</span><br></pre></td></tr></table></figure>

<p>这里<code>src</code>是<code>mbuf</code>的L4数据起始地址，由于环境上没有打开大页内存的coredump，导致<code>src</code>的内容无法获取，提高了一点分析难度，不过影响也不是很大。</p>
<p>接着分析下整体函数流程，从<code>src</code>的起始地址<code>s</code>开始读取每个字符并作相应转换，保存到<code>c</code>中，然后累加到<code>w</code>中去，等于逐位读取十进制整数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">		<span class="keyword">int</span> c;</span><br><span class="line">		c = xdigit2bin(srclen &gt; <span class="number">0</span> ? *s : <span class="string">&#x27;\0&#x27;</span>, delim);</span><br><span class="line">......</span><br><span class="line">		w = (w * <span class="number">10</span>) + c; <span class="comment">/* Coredump here. */</span></span><br><span class="line">		<span class="keyword">if</span> ((w &amp; <span class="number">0xffff</span>) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>很明显，这一段是为了将字符形式的点分十进制的IP的数字部分转换成十进制数字并保存，这里通过累计值是否大于255判断数值是否溢出/格式是否正确。</p>
<p>这里要注意的一点是，从<code>xdigit2bin</code>定义中可以发现，<code>c</code>的高16bit代表了<code>c</code>字符的类型，低16bit代表了对应的数值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_XDIGIT		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_DIGIT		0x00020000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_MASK	0x00700000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_1		0x00100000	<span class="comment">/* single : requested */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_2		0x00200000	<span class="comment">/* second : requested */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_1_2	0x00400000	<span class="comment">/* :: requested */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_DOT		0x00800000	<span class="comment">/* . */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_DELIM		0x10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_NULL		0x20000000	<span class="comment">/* first/tail */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_UNKNOWN		0x40000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">xdigit2bin</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> delim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (c == delim || c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_DELIM;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_COLON_MASK;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_DOT;</span><br><span class="line"></span><br><span class="line">	val = hex_to_bin(c);</span><br><span class="line">	<span class="keyword">if</span> (val &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> val | IN6PTON_XDIGIT | (val &lt; <span class="number">10</span> ? IN6PTON_DIGIT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (delim == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_DELIM;</span><br><span class="line">	<span class="keyword">return</span> IN6PTON_UNKNOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也正是这一点导致了最终的溢出：如果<code>c</code>只表示数值的话，通过和<code>255</code>比较可以确保不溢出，但每个数字的高16bit都有置位，当起始字符串的以若干<code>0</code>开头时，高16bit一直被累加，而低16bit的值一直是<code>0</code>，始终小于<code>255</code>，最终整体超过了<code>int</code>的上界，结果溢出。</p>
<h1 id="How-about-kernel"><a href="#How-about-kernel" class="headerlink" title="How about kernel?"></a>How about kernel?</h1><p>单单看溢出原因好像已经很明确了，但这段代码是从内核抄出来的，为什么内核正常运行安稳无恙呢？</p>
<p>所以在内核上构造一下对应场景验证，函数调用顺序为：<code>nf_nat_sip</code>-&gt;<code>ct_sip_parse_request</code>-&gt;<code>skp_epaddr_len</code>-&gt;<code>epaddr_len</code>-&gt;<code>sip_parse_addr</code>-&gt;<code>in4_pton</code>。</p>
<p>顶层调用入口<code>nf_nat_sip</code>位于内核模块<code>nf_nat_sip</code>，在模块初始化的时候被注册到<code>netfilter</code>的<code>NAT</code>模块中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_sip_hooks</span> <span class="title">sip_hooks</span> =</span> &#123;</span><br><span class="line">	.msg		= nf_nat_sip,</span><br><span class="line">	.seq_adjust	= nf_nat_sip_seq_adjust,</span><br><span class="line">	.expect		= nf_nat_sip_expect,</span><br><span class="line">	.sdp_addr	= nf_nat_sdp_addr,</span><br><span class="line">	.sdp_port	= nf_nat_sdp_port,</span><br><span class="line">	.sdp_session	= nf_nat_sdp_session,</span><br><span class="line">	.sdp_media	= nf_nat_sdp_media,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nf_nat_sip_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BUG_ON(nf_nat_sip_hooks != <span class="literal">NULL</span>);</span><br><span class="line">	nf_nat_helper_register(&amp;nat_helper_sip);</span><br><span class="line">	RCU_INIT_POINTER(nf_nat_sip_hooks, &amp;sip_hooks);</span><br><span class="line">	nf_ct_helper_expectfn_register(&amp;sip_nat);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以要进入这个函数，首先添加一条DNAT规则，用户态直接通过iptables操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -A PREROUTING -p udp -s 10.103.240.222 --dport 5060 -j DNAT --to-destination 1.2.3.4</span></span><br></pre></td></tr></table></figure>

<p><code>iptable</code>指定<code>-t nat</code>选项查看添加完成后的NAT规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -nvL -t nat</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 18234 packets, 3134K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 DNAT       udp  --  *      *       10.103.240.222       0.0.0.0/0            udp dpt:5060 to:1.2.3.4</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 16998 packets, 2947K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 269 packets, 109K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 277 packets, 110K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>

<p>加载<code>nf_nat_sip</code>模块，打开内核报文转发以及<code>netfilter</code>对应的<code>helper</code>功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe nf_nat_sip</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_helper</span></span><br></pre></td></tr></table></figure>

<p>使用<code>scapy</code>构造异常报文发送：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = <span class="string">&#x27;425945207369703a736572766963654030303937302e312e312e313a35303630205349502f322e300d0a5669613a205349502f322e302f5544502031302e3130332e3234302e3233323a353036303b6272616e63683d7a39684734624b2d313032373537382d313835392d390d0a46726f6d3a2073697070203c7369703a736970704031302e3130332e3234302e3233323a353036303e3b7461673d313835390d0a546f3a20737574203c7369703a736572766963654030303937302e312e312e313a353036303e3b7461673d3132393736534950705461673031313835390d0a43616c6c2d49443a20313835392d313032373537384031302e3130332e3234302e3233320d0a435365713a2032204259450d0a436f6e746163743a207369703a736970704031302e3130332e3234302e3233323a353036300d0a4d61782d466f7277617264733a2037300d0a5375626a6563743a20506572666f726d616e636520546573740d0a436f6e74656e742d4c656e6774683a20300d0a0d0a&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>send(IP(dst=<span class="string">&quot;10.103.241.233&quot;</span>)/UDP(sport=<span class="number">5060</span>,dport=<span class="number">5060</span>)/payload)</span><br><span class="line">.</span><br><span class="line">Sent <span class="number">1</span> packets.</span><br></pre></td></tr></table></figure>

<p>再通过<code>kprobe</code>输出<code>in4_pton</code>的参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./kprobe &#x27;p:in4_pton src=+0(%di):string&#x27;</span></span><br><span class="line">				&lt;idle&gt;-0     [002] ..s. 858059.345971: in4_pton: (in4_pton+0x0/0x170) src=<span class="string">&quot;00970.1.1.1:5060 SIP/2.0</span></span><br><span class="line"><span class="string">Via: SIP/2.0/UDP 10.103.240.232:5060;branch=z9hG4bK-1027578-1859-9</span></span><br><span class="line"><span class="string">From: sipp &lt;sip:sipp@10.103.240.232:5060&gt;;tag=1859</span></span><br><span class="line"><span class="string">To: sut &lt;sip:service@00970.1.1.1:5060&gt;;tag=12976SIPpTag011859</span></span><br><span class="line"><span class="string">Call-ID: 1859-1027578@10.103.240.232</span></span><br><span class="line"><span class="string">CSeq: 2 BYE</span></span><br><span class="line"><span class="string">Contact: sip:sipp@10.103.240.232:5060</span></span><br><span class="line"><span class="string">Max-Forwards: 70</span></span><br><span class="line"><span class="string">Subject: Performance Test</span></span><br><span class="line"><span class="string">Content-Length: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>从<code>kprobe</code>输出中可以看到，内核<code>in4_pton</code>的参数<code>src</code>也是若干<code>0</code>开头的字符串，按照对代码的分析会溢出，但为啥内核还是好好的？是不是内核溢出不会导致coredump？</p>
<p>据此，编写一个溢出的内核模块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, w, c;</span><br><span class="line"></span><br><span class="line">        printk(<span class="string">&quot;mo loaded.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">        c = <span class="number">0x30000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                w = w * <span class="number">10</span> + c;</span><br><span class="line">                printk(<span class="string">&quot;w = 0x%08x\n&quot;</span>, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fini</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;mo unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init);</span><br><span class="line">module_exit(fini);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载模块后观察日志输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346619</span> warning [kernel:] [<span class="number">195343.614466</span>] mo loaded.</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346629</span> warning [kernel:] [<span class="number">195343.614467</span>] w = <span class="number">0x00030000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346630</span> warning [kernel:] [<span class="number">195343.614468</span>] w = <span class="number">0x00210000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346631</span> warning [kernel:] [<span class="number">195343.614468</span>] w = <span class="number">0x014d0000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346631</span> warning [kernel:] [<span class="number">195343.614468</span>] w = <span class="number">0x0d050000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346631</span> warning [kernel:] [<span class="number">195343.614469</span>] w = <span class="number">0x82350000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346632</span> warning [kernel:] [<span class="number">195343.614469</span>] w = <span class="number">0x16150000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346632</span> warning [kernel:] [<span class="number">195343.614469</span>] w = <span class="number">0xdcd50000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346639</span> warning [kernel:] [<span class="number">195343.614470</span>] w = <span class="number">0xa0550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346639</span> warning [kernel:] [<span class="number">195343.614470</span>] w = <span class="number">0x43550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346639</span> warning [kernel:] [<span class="number">195343.614470</span>] w = <span class="number">0xa1550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346640</span> warning [kernel:] [<span class="number">195343.614471</span>] w = <span class="number">0x4d550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346640</span> warning [kernel:] [<span class="number">195343.614471</span>] w = <span class="number">0x05550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346640</span> warning [kernel:] [<span class="number">195343.614471</span>] w = <span class="number">0x35550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346641</span> warning [kernel:] [<span class="number">195343.614472</span>] w = <span class="number">0x15550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346641</span> warning [kernel:] [<span class="number">195343.614472</span>] w = <span class="number">0xd5550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346642</span> warning [kernel:] [<span class="number">195343.614472</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346642</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346643</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346643</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346643</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346644</span> warning [kernel:] [<span class="number">195343.614474</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346644</span> warning [kernel:] [<span class="number">195343.614474</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346645</span> warning [kernel:] [<span class="number">195343.614474</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346645</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346646</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346646</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346647</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346647</span> warning [kernel:] [<span class="number">195343.614476</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346648</span> warning [kernel:] [<span class="number">195343.614476</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346648</span> warning [kernel:] [<span class="number">195343.614476</span>] w = <span class="number">0x55550000</span></span><br></pre></td></tr></table></figure>

<p>结果看上去确实溢出了，但没有造成coredump。</p>
<h1 id="mulvsi3"><a href="#mulvsi3" class="headerlink" title="__mulvsi3"></a>__mulvsi3</h1><p>回过头看最初造成coredump的函数<code>__mulvsi3</code>，该函数是GCC内置函数，对应的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004005f0 &lt;__mulvsi3&gt;:</span><br><span class="line">  4005f0:       48 63 c7                movslq %edi,%rax</span><br><span class="line">  4005f3:       48 63 f6                movslq %esi,%rsi</span><br><span class="line">  4005f6:       48 0f af c6             imul   %rsi,%rax /* rax = rax * rsi */</span><br><span class="line">  4005fa:       48 89 c2                mov    %rax,%rdx</span><br><span class="line">  4005fd:       89 c1                   mov    %eax,%ecx</span><br><span class="line">  4005ff:       48 c1 fa 20             sar    $0x20,%rdx</span><br><span class="line">  400603:       c1 f9 1f                sar    $0x1f,%ecx</span><br><span class="line">  400606:       39 d1                   cmp    %edx,%ecx /* rdx &gt;&gt; 0x20 == ecx &gt;&gt; 0x1f */</span><br><span class="line">  400608:       75 02                   jne    40060c &lt;__mulvsi3+0x1c&gt;</span><br><span class="line">  40060a:       f3 c3                   repz retq </span><br><span class="line">  40060c:       50                      push   %rax</span><br><span class="line">  40060d:       e8 1e fe ff ff          callq  400430 &lt;abort@plt&gt;</span><br><span class="line">  400612:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  400619:       00 00 00 </span><br><span class="line">  40061c:       0f 1f 40 00             nopl   0x0(%rax)</span><br></pre></td></tr></table></figure>

<p>可以看到在计算完乘积后，通过最高位的进位和次高位的进位情况进行溢出判断（双高位判断法，原理没搞懂），如果发生溢出则跳转，并且最终执行<code>abort</code>。</p>
<p>为什么内核没有发生coredump，大概因为内核的乘法对应的实现没有做溢出检测。应用层也是同理，如果对应的乘法实现没有溢出检测的话也不会出现coredump。</p>
<p>通常来说，整数溢出的问题主要可能影响一些条件判断，进而造成死循环等问题，这种导致coredump的比较少，但总的来说还是应该尽量避免。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>How does QEMU notify Guest the nic link status changed</title>
    <url>/2022/05/22/How-does-QEMU-notify-Guest-the-nic-link-status-changed/</url>
    <content><![CDATA[<p>事情的起因是同事问到，Guest内部virtio网卡的链路状态是如何改变的，于是从virtio网卡入手，梳理了一下QEMU的网卡链路状态的相关代码。</p>
<span id="more"></span>

<h1 id="virtio-net-set-link-status"><a href="#virtio-net-set-link-status" class="headerlink" title="virtio_net_set_link_status"></a>virtio_net_set_link_status</h1><p>搜索相关代码，能够找到设置virtio-net链路状态的函数<code>virtio_net_set_link_status</code>，该函数会判断如果链路状态发生了改变，则调用<code>virtio_notify_config</code>通知Guest内部。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_net_set_link_status</span><span class="params">(NetClientState *nc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIONet *n = qemu_get_nic_opaque(nc);</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(n);</span><br><span class="line">    <span class="keyword">uint16_t</span> old_status = n-&gt;status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nc-&gt;link_down)</span><br><span class="line">        n-&gt;status &amp;= ~VIRTIO_NET_S_LINK_UP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n-&gt;status |= VIRTIO_NET_S_LINK_UP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;status != old_status)</span><br><span class="line">        virtio_notify_config(vdev);</span><br><span class="line"></span><br><span class="line">    virtio_net_set_status(vdev, vdev-&gt;status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化virtio-net的<code>NetClientInfo</code>的时候<code>link_status_changed</code>函数设置为<code>virtio_net_set_link_status</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> NetClientInfo net_virtio_info = &#123;</span><br><span class="line">    .type = NET_CLIENT_DRIVER_NIC,</span><br><span class="line">    .size = <span class="keyword">sizeof</span>(NICState),</span><br><span class="line">    .can_receive = virtio_net_can_receive,</span><br><span class="line">    .receive = virtio_net_receive,</span><br><span class="line">    .link_status_changed = virtio_net_set_link_status,</span><br><span class="line">    .query_rx_filter = virtio_net_query_rxfilter,</span><br><span class="line">    .announce = virtio_net_announce,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="link-status-changed"><a href="#link-status-changed" class="headerlink" title="link_status_changed"></a>link_status_changed</h1><p>从函数命名上可以看出，该函数在链路状态发生改变后被调用。</p>
<p>该函数有2个调用处：<code>qmp_set_link</code>和<code>qemu_del_net_client</code>。</p>
<h2 id="qmp-set-link"><a href="#qmp-set-link" class="headerlink" title="qmp_set_link"></a>qmp_set_link</h2><p>qmp开头的函数很明显，都是QMP(<a href="https://wiki.qemu.org/Documentation/QMP">QEMU Machine Protocol</a>）相关的命令对应的实现函数，一般场景下都是用户通过HMP（<a href="https://wiki.qemu.org/ToDo/HMP">Human Monitor Interface</a>）接口去手动设置的。</p>
<p>所以，一种显然的调用方式为：通过QMP，主动设置链路状态。</p>
<p>除此之外，在后端为vhost-user的场景下，QEMU代码有特殊处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_vhost_user_event</span><span class="params">(<span class="keyword">void</span> *opaque, QEMUChrEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHR_EVENT_OPENED:</span><br><span class="line">......</span><br><span class="line">        qmp_set_link(name, <span class="literal">true</span>, &amp;err);</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CHR_EVENT_CLOSED:</span><br><span class="line">        <span class="comment">/* a close event may happen during a read/write, but vhost</span></span><br><span class="line"><span class="comment">         * code assumes the vhost_dev remains setup, so delay the</span></span><br><span class="line"><span class="comment">         * stop &amp; clear to idle.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">FIXME:</span> better handle failure in vhost code, remove bh</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;watch) &#123;</span><br><span class="line">......</span><br><span class="line">            aio_bh_schedule_oneshot(ctx, chr_closed_bh, opaque);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CHR_EVENT_BREAK:</span><br><span class="line">    <span class="keyword">case</span> CHR_EVENT_MUX_IN:</span><br><span class="line">    <span class="keyword">case</span> CHR_EVENT_MUX_OUT:</span><br><span class="line">        <span class="comment">/* Ignore */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        error_report_err(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即后端为vhost-user时，当对应的socket连接事件发生，主动从代码中调用<code>qmp_set_link</code>，设置网卡的链路状态为UP；当对应socket断开事件发生，异步调用一次<code>chr_closed_bh</code>，该函数中进行后端断开对应的清理操作，包括调用<code>qmp_set_link</code>将网卡的链路状态设置为DOWN。</p>
<h2 id="qemu-del-net-client"><a href="#qemu-del-net-client" class="headerlink" title="qemu_del_net_client"></a>qemu_del_net_client</h2><p>这个函数主要是清理NetClientState的相关联资源，需要注意的是，这里调用<code>link_status_changed</code>并不是设置当前被清理的NetClientState对应设备的状态，而是设置peer的状态（QEMU网络虚拟化中对虚拟网络设备抽象为device和backend，如virtio-net/vhost-net、e1000/tap都是device/backend的对应关系，两者互为peer，详细可参考<a href="https://wiki.qemu.org/Documentation/Networking">Wiki</a>）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qemu_del_net_client</span><span class="params">(NetClientState *nc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* If there is a peer NIC, delete and cleanup client, but do not free. */</span></span><br><span class="line">    <span class="keyword">if</span> (nc-&gt;peer &amp;&amp; nc-&gt;peer-&gt;info-&gt;type == NET_CLIENT_DRIVER_NIC) &#123;</span><br><span class="line">        NICState *nic = qemu_get_nic(nc-&gt;peer);</span><br><span class="line">        <span class="keyword">if</span> (nic-&gt;peer_deleted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nic-&gt;peer_deleted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queues; i++) &#123;</span><br><span class="line">            ncs[i]-&gt;peer-&gt;link_down = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nc-&gt;peer-&gt;info-&gt;link_status_changed) &#123;</span><br><span class="line">            nc-&gt;peer-&gt;info-&gt;link_status_changed(nc-&gt;peer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queues; i++) &#123;</span><br><span class="line">            qemu_cleanup_net_client(ncs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，当backend对应的NetClientState被删除时，会调用<code>qemu_del_net_client</code>，通知peer网卡链路状态发生了改变。</p>
<p>该函数的调用处，除了各类型网卡的初始化异常处理逻辑，和关机流程，就只有<code>qmp_netdev_del</code>（又是一处QMP的接口调用😅），也就说明，只有通过QMP删除netdev时，会走到这个逻辑。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>上述代码分析中，除了入手点从virtio-net，其余都是对<code>link_status_changed</code>的调用分析，即该流程对QEMU的其他类型网卡同样适用。</p>
<p>正常运行过程中会引起Guest内部链路状态改变的场景如下：</p>
<ul>
<li>virtio-net网卡的backend为vhost-user时，对应的unix socket发生断开、连接事件；</li>
<li>通过qmp，主动设置对应网卡的链路状态；</li>
<li>通过qmp，删除backend，通知peer网卡链路状态发生改变。</li>
</ul>
<p><code>qemu_del_net_client</code>本身还有其他调用处，如关机流程、backend初始化失败的异常处理逻辑，但不属于正常运行过程中的场景，场景也比较简单，所以就不作分析了。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
        <tag>Virtio/Vhost</tag>
      </tags>
  </entry>
  <entry>
    <title>Travels of Martzki: Travel in Gansu and Qinghai in 2020</title>
    <url>/2022/03/06/Travel-in-Gansu-and-Qinghai-in-2020/</url>
    <content><![CDATA[<p>在2020年的9月，我参加了公司组织的旅行团，目的地是青海和甘肃，开启了第一次的西北之旅。</p>
<p>首先说下旅行本身，由于是跟团游，甚至是跟公司的团，所以行程上面没有什么可自由安排的余地，也没法把青甘大环线上的所有景点都游览一遍。虽然目的地是青海甘肃，但实际上6天行程，最后只有2天在青海，加上一路的奔波，其实体验上来说还是非常辛苦的。</p>
<span id="more"></span>

<h1 id="兰州市区"><a href="#兰州市区" class="headerlink" title="兰州市区"></a>兰州市区</h1><p>我们是从兰州开始整个行程的。兰州作为一个二线城市，给人整体的感受就是发达程度不高，不过生活节奏比较悠闲。给我印象比较深的一点就是，刚到兰州的第一顿午餐，导游带着一大巴的人，从没有斑马线红绿灯的双实线道路横穿马路到对面的餐厅，着实震撼了一番😅。整个过程除了没有斑马线红绿灯，和小学老师领着一大群小学生过马路的场景不能说很像，只能说一模一样。</p>
<p>在兰州市区，唯一组织我们一起游览的景点是中山桥。在吃完午餐后到中山桥的一路上，导游一路上滔滔不绝地渲染黄河第一桥的建筑历史和解放战争历史，真正到达后，其实在我个人看来就是一座有着历史背景的铁桥而已，上面挤满了游客在拍照打卡。从景点本身而言，如果不是对相关历史有兴趣的话，只是一个单纯的打卡景点罢了，并不值得推荐。不过如果像我一样，之前没有见过黄河的话，也是值得一去的，虽然不是壶口瀑布那样壮观的黄河，但也是黄河，很黄的🤡。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4101.jpeg" width="70%" height="70%" alt="中山桥（一）"> 

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_1106.jpeg" width="70%" height="70%" alt="中山桥（二）"> 

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4212.jpeg" width="70%" height="70%" alt="摄于中山桥的兰州傍晚">

<p>虽然是跟团游，吃饭都是旅行社安排的团餐，但在晚上我们还是从网上找了一家评分还ok的兰州牛肉面去打卡。尽管不像《舌尖上的中国》中的那样，连面的粗细都可以选择，只是一家普普通通的牛肉面馆，但至少从卖相上来看，应该也是能符合兰州牛肉面“一清二白三红四绿五黄”的特点的。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_0453.jpeg" width="70%" height="70%" alt="兰州牛肉面">

<h1 id="七彩丹霞"><a href="#七彩丹霞" class="headerlink" title="七彩丹霞"></a>七彩丹霞</h1><p>七彩丹霞也是导游浓墨重彩极力推荐的景点，对之前没有了解过这个景点的我来说，一路上听着导游洗脑的宣传，以及抱着对5A景点的敬仰，还是产生了不小的期待值。不过真正到了景点以后，客观的来说还是和我的预期产生了亿点点的误差的🤡。</p>
<p>首先景点名里的丹霞，指的是丹霞地貌，用我个人的、通俗一点的说法就是：红土🤡。虽然在地理学和矿物学上可能由于若干稀有的条件，最终呈现出了红色为主的外貌特征，但在外行游客看来，可能体会不到其中的价值。景区里的丹霞地貌，主要是若干的小型丘陵，有的丘陵由于其自身形状，加上人为的艺术加工，为其冠以特殊的名称。比如这个形似一个卧姿的人的小山，应该是有个名字的（I really can’t recall🤡）。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_0639.jpeg" width="70%" height="70%" alt="卧姿小山">

<p>其次名称里的七彩，指的是丘陵表层除了红色为主的矿物以外，还有许多种类的矿物，在阳光的照射下（perhaps）会显示出七彩的颜色，very incredible。不过客观来说，我们去的当天确实是阴天，所以呈现在眼前的基本上也就是红色为主的丘陵。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4262.jpeg" width="70%" height="70%" alt="阴天的七彩丹霞（一）">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4263.jpeg" width="70%" height="70%" alt="阴天的七彩丹霞（二）">

<p>作为5A级景区，从卖家秀上看来，确实是有点东西的，或许晴天去会有一个更好的体验。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/W020210514653355246570.jpeg" width="70%" height="70%" alt="七彩丹霞卖家秀（图源：http://www.zhangye.gov.cn/yzzy/jdtj/lzx/202105/t20210514_637807.html）">

<h1 id="嘉峪关"><a href="#嘉峪关" class="headerlink" title="嘉峪关"></a>嘉峪关</h1><blockquote>
<p>长城西起嘉峪关，冬至山海关。</p>
</blockquote>
<p>这便是我从书本上得到的对嘉峪关的最初印象。作为长城最西的关口，嘉峪关也被世人称作“天下第一雄关”。</p>
<p>虽然现在的嘉峪关，已经不再是当年河西走廊上的军事要塞，但当人真真正正地来到嘉峪关门前，走进内城，登上城楼远眺祁连山和戈壁荒漠时，身旁城墙上历经风霜的砖石，就像久经沙场的老兵一样，似乎还在诉说着当年的金戈铁马。闭上双眼，感受着西北的风沙吹过脸庞，也感受着历史的流逝。“哀吾生之须臾,羡长江之无穷。”说的可能也就是这样的感受吧。</p>
<p>我想，对于嘉峪关，无须多言。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_2809.jpeg" width="70%" alt="嘉峪关光化门">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_1192.jpeg" width="70%" alt="嘉峪关内">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4271.jpeg" width="70%" alt="嘉峪关练兵场">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_8297.jpeg" width="70%" alt="嘉峪关城墙和远处的祁连山">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_3004.jpeg" width="70%" alt="嘉峪关城楼">

<h1 id="鸣沙山-amp-月牙泉"><a href="#鸣沙山-amp-月牙泉" class="headerlink" title="鸣沙山 &amp; 月牙泉"></a>鸣沙山 &amp; 月牙泉</h1><p>鸣沙山和月牙泉，是敦煌著名的沙漠景区。</p>
<p>所谓鸣沙山，指的是整个沙漠景区中的沙丘，在人们向上攀爬时，会随着脚掌踩入沙地，发出特殊的响声；而月牙泉，指的则是在整个沙漠中的一片小小绿洲，由于泉水从上空俯视形似月牙而得名。</p>
<p>整个景点对于第一次见到沙漠的我来说，吸引力十足，可以说是整个旅行中最值得推荐的景点了。就像没有见过雪的南方人第一次见到下雪一样，我相信对所有没有亲眼见到沙漠的人而言都是一样的，无法拒绝沙漠的自然魅力。甚至还在景区外，看到远处的沙丘后的大家都难掩兴奋之情。</p>
<p>在沙漠中，可以爬上山顶，眺望整个沙漠，看着由大风吹出的沙丘棱角，和远处在沙丘行走的行人。总之，只要脚在沙子上，整个人都是兴奋的。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4316.jpeg" width="70%" alt="棱角分明的沙丘">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_9787.jpeg" width="70%" alt="沙丘和旅人">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4332.jpeg" width="70%" alt="夕阳和月牙泉">

<p>除了自然景色的观赏外，这里还有非常多的自费项目，主要有骆驼骑行、沙漠越野摩托、滑翔机等。</p>
<h2 id="骆驼骑行"><a href="#骆驼骑行" class="headerlink" title="骆驼骑行"></a>骆驼骑行</h2><p>其实骑骆驼这个项目，全国各地应该都有，甚至不需要和沙漠有啥关系，只要骆驼能活应该都能开展🤡。</p>
<p>但是在沙漠中，跟随驼队，可能多少能有一点当年穿越丝绸之路的商人们的骑行体验吧。</p>
<p>值得一提的是，在景区官方售票处，售出的骆驼票，只是包含骑行，同时在骑行路途上设置了一些放着小喇叭播放着音乐的自动拍照点。在离开景区的时候，可以选择去冲印出相片作为留念，当然，是自费的🤡（景区创收经典操作了）。</p>
<p>除了官方的拍照服务以外，每一支驼队，会有一两个饲养员负责牵着骆驼指引方向，虽然景区说了不允许私自收费，但他们还是会向你提供有偿的拍照服务。虽然从结果上来看，拍照水平相当拉胯，胜在能拍到骑行的角度。毕竟坐在骆驼上不管是用手机还是自拍杆，都还是挺抖的。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4389.jpeg" width="70%" alt="沙漠驼队">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_9700.jpeg" width="70%" alt="沙漠驼队和拍照技术巨烂的饲养员">

<h2 id="沙漠越野摩托"><a href="#沙漠越野摩托" class="headerlink" title="沙漠越野摩托"></a>沙漠越野摩托</h2><p>越野摩托是有着四个粗犷越野轮胎的越野摩托，一身的柴油味和磨的锃亮的刹车把手仿佛在诉说着它的久经风霜。</p>
<p>摩托主要由驾驶员驾驶，有着固定路线，基本上是一个上坡的路线，到达折返点后返回。在到达折返点之前，驾驶员还会让游客自行驾驶一段路程。自行驾驶的过程中，不需要换挡，只需要加油和控制方向，但在沙漠上由于地形起伏不平，能够感受到把手上传来的巨大扭转力，所以还是需要驾驶员在后座辅助把控方向的。在自行驾驶结束后，基本就到了折返点了。</p>
<p>重点来了，趁着你刚刚到达折返点，自行驾驶的兴奋劲儿还没过，驾驶员们就会开始推销“增值服务”，额外付费带你进入沙漠深处领会真正的沙漠景色。即便被拒绝了之后还是安利不停，大概就是：你们玩的都不是真正的沙漠，真正的沙漠好玩着呢，给钱就带你去🤡。</p>
<p>当他推销失败后，返程过程可能一个是因为想赶紧回去接下一单，另一个可能因为不满没有赚到钱，驾驶过程非常激烈，下坡过程都是全程轰着油门。我坐在后座双手抓着车架，几乎屁股离地全程飞着回去的，到达以后双手几乎脱力了🤡。</p>
<p>总之还是值得体验的，至于是否要额外付钱让他带你去沙漠深处就见仁见智了，如果遇到报复性激烈驾驶可以要求他减速，安全第一。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4289.jpeg" width="70%" alt="越野摩托">

<h2 id="滑翔机"><a href="#滑翔机" class="headerlink" title="滑翔机"></a>滑翔机</h2><p>景区有小型的螺旋桨滑翔机，当然不可能是游客驾驶，游客乘坐滑翔机从上空游览整个景区，体验应该还是不错的。不过不知道是不是所有人都像我一样，嘴上说着“会不会不安全”、“感觉可能也没多大意思”，但心里想着卧槽好贵然后没去🤡。</p>
<h1 id="莫高窟"><a href="#莫高窟" class="headerlink" title="莫高窟"></a>莫高窟</h1><p>就像一提到西安，人们首先想到的就是兵马俑一样，一提到敦煌，人们肯定首先想到的也是莫高窟，因为莫高窟实在是太有名了，应该是一个甘肃必去的景点。</p>
<p>莫高窟的宗教、历史、艺术价值，完全不必描述，那些洞窟内历经千年却依然色彩艳丽的壁画和栩栩如生的雕像，毋庸置疑是世界第一档的水平。</p>
<p>所以这里就写一下其他方面的东西：</p>
<ul>
<li>游览票别：为了保护莫高窟，门票分为A类票和B类票，需要网上预约，两类票的区别，主要是可以游览的洞窟不同，A类票可以游览的洞窟更加精美；</li>
<li>游览路程：莫高窟内不允许自行游览，都是由专业的解说员兼导游负责带领游览。值得一提的是解说员的专业水平非常之高，从语言表达到解说内容都是无可挑剔的，不愧是世界文化遗产的解说员，点赞；</li>
<li>游览规范：洞窟内不允许拍照、使用闪光灯、手电等，一个是为了文化保护，另一个是避免光线加速壁画的氧化，整个浏览过程中只能跟随解说员的手电光去游览；</li>
<li>介绍短片：正式游览之前，会在一个电影院，播放莫高窟相关历史文化的介绍短片，但是由于光线比较暗，内容解说也相对枯燥，还是比较无聊的；</li>
<li>电子保护：据解说员介绍，莫高窟已经启动了将洞窟内的壁画、雕像等艺术瑰宝通过信息化手段保存的工程，好让莫高窟在人类历史上永远保留下去。</li>
</ul>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_2670.jpeg" width="70%" alt="莫高窟（一）">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_4341.jpeg" width="70%" alt="莫高窟（二）">

<h1 id="茶卡盐湖"><a href="#茶卡盐湖" class="headerlink" title="茶卡盐湖"></a>茶卡盐湖</h1><p>此次旅行唯二的青海景点之一，也是一个网红景点，被称作“天空之镜”。</p>
<p>茶卡盐湖除了作为一个旅游景点外，还是一个重要的制盐基地。我们的游览路线就是从制盐基地开始的，制盐基地能够看到从采集用的工业设备和堆积成山的白色盐堆，此外也是一个码头。在粗略游览了制盐基地后，我们就从码头坐船，直接到达有着“天空之镜”之称的景区中心。</p>
<p>“天空之镜”茶卡盐湖的特点就是湖中有很多的白色结晶盐，从湖面肉眼可见都是白色的一片，晴天的时候，阳光、湖水、结晶盐的共同作用下，湖面倒映的天空镜像，宛如天空本身一样。在湖面平静的时候，更有水天一色的感觉。</p>
<p>湖中有许多地方的结晶盐生长的很高，导致水深很浅，游客可以直接下水拍照。景区也提供防水鞋套租赁，可以穿着直接下水，不过好多女孩儿都是直接穿着长裙光脚下水拍照的，即便9月的青海气温很低，即便在车上还是长裙外面裹着羽绒服，即便不仅水温低盐浓度还很高，但，那又怎么样呢？好看可是一辈子的事🤡。</p>
<p>离开时我们乘坐了网红小火车，从景点返回入口。说是网红小火车，其实这个铁路最初就是茶卡的制盐工业用来运送盐的货运铁路。后来旅游业发展起来，将货运车厢换成了开放的客运车厢，用于客流运输。小火车行驶速度不快，坐在上面可以很好地欣赏盐湖风景。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_7801.jpeg" width="70%" alt="茶卡盐湖（一）">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_2132.jpeg" width="70%" alt="茶卡盐湖（二）">

<h1 id="青海湖"><a href="#青海湖" class="headerlink" title="青海湖"></a>青海湖</h1><p>青海湖作为青海最知名的旅游景点，可惜的是这次旅行里面只呆了一个下午（这里不得不吐槽下行程安排🙄），而且当天连轮船也没有，就在湖边散步打了下卡，基本就结束了。说实话青海湖作为自行车环湖赛的场地和房车自由行的热门选择地，要是好好玩一周可能都不够，但我们只有一个下午🤷。</p>
<p>其次晚上就住在湖边的酒店，虽然叫酒店，但其实就是招待所水平，是整个旅行中住宿条件最差的，且没有空调（不过青海好像酒店都没有空调，包括在西宁市中心的酒店也没有），自由行是否选择住在湖边可以根据实际情况选择。同时虽然深处青海湖边，导游嘱咐注意高原反应，但海拔也就2000多米，基本不用担心高反。</p>
<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_2844.jpeg" width="70%" alt="青海湖（一）">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_2865.jpeg" width="70%" alt="青海湖（二）">

<img src="/images/2022-03-06-Travel-in-Gansu-and-Qinghai-in-2020/IMG_2871 2.jpeg" width="70%" alt="青海湖（三）">
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Mattermost Auto Reply Tool</title>
    <url>/2022/02/17/Mattermost-auto-reply-tool/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p><a href="https://mattermost.org/">Mattermost</a>是一款开源的IM工具，作为Slack的替代产品。</p>
<h2 id="Mattermost-Source-Code"><a href="#Mattermost-Source-Code" class="headerlink" title="Mattermost Source Code"></a>Mattermost Source Code</h2><p>mattermost的github主页上主要有这几个项目：</p>
<ul>
<li>mattermost-server: 用Go开发的服务端代码，也是整体的核心代码；</li>
<li>mattermost-webapp: 基于Web的客户端代码，所有其他类型的客户端，均是基于webapp实现；</li>
<li>desktop: 基于Electron的Windows客户端代码，通过Chromium浏览器内核连接webapp，完成客户端的功能；</li>
<li>mattermost-mobile: iOS和Android的客户端代码，应该也是通过浏览器内核连接webapp进而实现的的客户端功能。</li>
</ul>
<span id="more"></span>

<h2 id="Mattermost-Deployment"><a href="#Mattermost-Deployment" class="headerlink" title="Mattermost Deployment"></a>Mattermost Deployment</h2><p><a href="https://docs.mattermost.com/guides/deployment.html#server-installation">官方文档</a>中提供了各种环境下的部署方式，最便捷的就是直接在本地运行docker容器。不得不说，容器技术极大地简化了应用的部署流程，如果只是需要部署一个基本的服务端，直接按照文档指导，启动容器即可，容器内会自行运行server和webapp，即可通过浏览器连接webapp。</p>
<h1 id="Mattermost-Auto-Reply"><a href="#Mattermost-Auto-Reply" class="headerlink" title="Mattermost Auto Reply"></a>Mattermost Auto Reply</h1><p>关于Mattermost自身的其他功能就不介绍了，有他自己的优缺点。聊天功能中，Mattermost自身提供了一个自动回复的功能，在开启自动回复时，将会把在线状态设置为离开。此时收到所有私聊信息后，会触发自动回复。</p>
<p>这个自带功能的鸡肋的地方在于：会强制将状态设置为离线，此时收到新的消息不再有推送提醒，并且无法设置自动回复间隔，每收到的一条新消息都会触发自动回复。<br>而一个理想的自动回复功能应该包含：</p>
<ul>
<li>可自由开关</li>
<li>和自身账户在线状态无关，不会设置在线状态为离开</li>
<li>功能开启后不影响正常使用，收到新消息后能够正常触发消息推送</li>
<li>可设置消息回复的频率</li>
</ul>
<h2 id="Develop-with-Server"><a href="#Develop-with-Server" class="headerlink" title="Develop with Server"></a>Develop with Server</h2><p>对一款开源产品而言，直接修改源代码是实现功能自定义的最直接的方式。</p>
<p>最初的想法就是直接修改原生的自动回复代码，将其中设置在线状态的代码屏蔽，即可在不做大量修改的情况下，将自动回复功能会将状态设置为离线的问题解决。</p>
<p>在看了对应功能的源码后，发现这部分功能是在server中实现的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动回复功能启停（同时设置用户在线状态）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">SetAutoResponderStatus</span><span class="params">(user *model.User, oldNotifyProps model.StringMap)</span></span> &#123;</span><br><span class="line">	active := user.NotifyProps[model.AutoResponderActiveNotifyProp] == <span class="string">&quot;true&quot;</span></span><br><span class="line">	oldActive := oldNotifyProps[model.AutoResponderActiveNotifyProp] == <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line">	autoResponderEnabled := !oldActive &amp;&amp; active</span><br><span class="line">	autoResponderDisabled := oldActive &amp;&amp; !active</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> autoResponderEnabled &#123;</span><br><span class="line">		a.SetStatusOutOfOffice(user.Id)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> autoResponderDisabled &#123;</span><br><span class="line">		a.SetStatusOnline(user.Id, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动回复功能代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">SendAutoResponse</span><span class="params">(c *request.Context, channel *model.Channel, receiver *model.User, post *model.Post)</span> <span class="params">(<span class="keyword">bool</span>, *model.AppError)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> receiver == <span class="literal">nil</span> || receiver.NotifyProps == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	active := receiver.NotifyProps[model.AutoResponderActiveNotifyProp] == <span class="string">&quot;true&quot;</span></span><br><span class="line">	message := receiver.NotifyProps[model.AutoResponderMessageNotifyProp]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !active || message == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rootID := post.Id</span><br><span class="line">	<span class="keyword">if</span> post.RootId != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		rootID = post.RootId</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	autoResponderPost := &amp;model.Post&#123;</span><br><span class="line">		ChannelId: channel.Id,</span><br><span class="line">		Message:   message,</span><br><span class="line">		RootId:    rootID,</span><br><span class="line">		Type:      model.PostTypeAutoResponder,</span><br><span class="line">		UserId:    receiver.Id,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := a.CreatePost(c, autoResponderPost, channel, <span class="literal">false</span>, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这个功能是通过对服务端用户状态进行相应的设置，启用功能后，服务端在消息处理时自动实现的，整个过程客户端只起到了一个状态设置的作用，不参与实际的回复功能实现。</p>
<p>经过上面的代码分析，如果想要通过修改原生代码实现对应功能的话，则需要修改服务端代码，重新编译部署再上线。其劣势主要有：</p>
<ul>
<li>对服务端代码进行修改需要对应的权限：如果没有服务端的管理权限，单独作为用户，是没有办法修改服务端代码的；</li>
<li>重新部署会引起业务中断：更换服务端代码重新部署会引起业务中断。</li>
</ul>
<p>由于大多数使用者都是单纯的用户，并不具备重新部署服务端的条件，所以这个方案作为理论可行且简单的方案，但并未最终选用。</p>
<h2 id="Develop-with-Client"><a href="#Develop-with-Client" class="headerlink" title="Develop with Client"></a>Develop with Client</h2><p>上面分析了对应代码是在服务端中实现的，在功能调研期间，发现修改服务端实现功能的方式不太现实后，曾考虑过修改客户端代码，在客户端重新实现一个自动回复功能。</p>
<p>但经过更细致的分析后发现，mattermost的客户端核心是mattermost-webapp，客户端的具体的消息收发功能都是在mattermost-webapp中实现的，各个平台上的客户端都只是利用平台特性对mattermost-webapp进行了封装，主要应该是为了平台相关的交互功能实现，比如文件上传下载、以及消息推送功能的实现。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/process-diagram.png" width="70%" height="70%" alt="mattermost-desktop Process Diagram">

<p>如<a href="https://developers.mattermost.com/contribute/desktop/">官方文档</a>描述的那样，mattermost-desktop基于Electron开发，分为main进程和renderer进程，main进程由NodeJS实现，包含了通知管理、窗口布局管理、配置、操作系统集成等功能，同时包含了对rederer进程的生命周期管理等功能；rederer进程基本就是Chromium浏览器内核，通过连接webapp实现对应的功能。</p>
<p>main进程和rederer进程之间通过特定的IPC进行交互。</p>
<p>所以尝试修改客户端代码实现功能的方案也告吹，因为客户端的核心mattermost-webapp通常是和mattermost-server运行在一起的，对其进行修改的难度同样较大。</p>
<h2 id="Develop-an-API-Request-Proxy"><a href="#Develop-an-API-Request-Proxy" class="headerlink" title="Develop an API Request Proxy"></a>Develop an API Request Proxy</h2><p>由于消息的收发都是webapp调用和server的API实现的，所以一种理论可行的方案为：获取客户端的cookie等身份认证信息，监控所有客户端的交互请求。通过对交互请求进行分析，收到消息后，依据自动回复配置和策略，调用对应的API，发送预先设定好的自动回复消息。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/API proxy.drawio.png" width="70%" height="70%" alt="API Request Proxy">

<p>这是一种理论可行的方案，但却不是一个现实的、容易实现的方案，有如下几个原因：</p>
<ul>
<li>认证：不论是server API的认证信息的获取，还是HTTPS（假设服务端使用了HTTPS）的认证信息获取，都需要通过已经完成认证的webapp来获取，实际上是很不容易实现的，而这些认证信息，是分析webapp和server的API请求、通过API完成消息发送的前提；</li>
<li>使用难度：需要以请求代理的方式部署，从而能够在webapp和server交互的过程中获取到交互的具体请求。代理的部署形态增加了用户的使用难度。</li>
</ul>
<p>综上，这是一种理论可行的、从实现方式上看较为原生的（raw）方案，但并不现实。</p>
<h2 id="Develop-with-API-Driver-Finally-Choosed"><a href="#Develop-with-API-Driver-Finally-Choosed" class="headerlink" title="Develop with API Driver (Finally Choosed)"></a>Develop with API Driver (Finally Choosed)</h2><p>关于mattermost的API，除了webapp可以直接访问外，如<a href="https://api.mattermost.com/#tag/introduction">官方文档</a>所描述的，有多种语言的Driver可供开发者使用。使用特定的Driver可以连接server，认证完成后可通过定义好的API调用来实现对应的功能，即可通过API完成第三方应用的开发。</p>
<p>最终选择了Python的<a href="https://github.com/Vaelor/python-mattermost-driver">Driver</a>，感谢作者<a href="https://github.com/Vaelor">@Vaelor</a>。</p>
<p>项目地址：<a href="https://github.com/Martzki/Mattermost-Tools">Mattermost-Tools</a>。</p>
<h3 id="Design-Overview"><a href="#Design-Overview" class="headerlink" title="Design Overview"></a>Design Overview</h3><p>为了完成自动回复的功能，有几个子功能需要实现：</p>
<ul>
<li>Connect to Server：API调用、消息获取等功能都需要在连接到server并完成认证的前提下才能实现；</li>
<li>Events Handle：获取server推送的event，处理处理消息类型的event，在满足自动回复的条件后，调用自动回复的功能；</li>
<li>Auto Reply：依据用户配置，对消息进行自动回复，也是核心功能；</li>
<li>Config Update：自动回复相关的用户配置的更新；</li>
<li>GUI：用户友好的配置交互功能，可在运行过程中动态变更用户配置。</li>
</ul>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/overview.drawio.png" width="70%" height="70%" alt="Overview">

<h3 id="Connect-to-Server"><a href="#Connect-to-Server" class="headerlink" title="Connect to Server"></a>Connect to Server</h3><p>首先就是连接到Server，API提供了WebSocket对应的接口，可以通过用户名密码/Token的方式连接server，认证成功后即可通过WebSocket获取服务端推送的消息，以及调用对应的服务端API。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/connect to server.drawio.png" width="70%" height="70%" alt="Connect to Server">

<h3 id="Event-Handle"><a href="#Event-Handle" class="headerlink" title="Event Handle"></a>Event Handle</h3><p>WebSocket连接后，接收server推送的event，再依据具体业务逻辑选择不同的event处理方式。</p>
<p>这套event机制实际上提供了一个方便的功能开发的框架，对应的功能注册对特定event的handler，当event触发后，调用注册的所有handler即可实现不同的功能。不过目前只有一个自动回复的功能，或者说自动回复只是一个特定的post类型的event handler。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/event handle process.drawio.png" width="70%" height="70%" alt="Event Handle">

<h3 id="Auto-Reply"><a href="#Auto-Reply" class="headerlink" title="Auto Reply"></a>Auto Reply</h3><p>对自动回复而言，只需关注post类型的event即可，完整的event类型参考<a href="https://api.mattermost.com/#tag/WebSocket">API文档</a>。通过对post类型的event注册handler，在event触发后调用对应的实现逻辑完成自动回复功能。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/event handler.drawio.png" width="70%" height="70%" alt="Post Event Handle">

<p>目前对自动回复功能的设计，有如下功能：</p>
<ul>
<li>仅限私聊：通过判断post所在channel中的人数来确定当前post是否是一条私聊消息；</li>
<li>自动回复间隔：减少自动回复的频率，记录每一个会话的自动回复历史，在自动回复间隔期间的多次消息接收不会触发多次自动回复；</li>
<li>自动回复间隔调整：在接收到特定消息后，调整下一次自动回复的间隔为一个预设值，用于延长自动回复间隔。</li>
</ul>
<p>于是，在收到私聊消息，且当前时间与上一次自动回复的间隔时间大于用户配置的自动回复间隔后，触发自动回复的条件，通过API将用户预设好的自动回复消息发送到对应的channel。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/auto reply handler.drawio.png" width="70%" height="70%" alt="Auto Reply Handler">

<p><strong>ps.</strong> mattermost中，如果用户在接收到未读post的channel中发送了新的post，将会把之前的未读状态清除，体现在webapp上就是未读提示被清除了。所以自动回复的post发送后，需要将原来的未读post状态重新设置为未读，避免丢失了用户的未读消息提醒。</p>
<h3 id="Config-Update"><a href="#Config-Update" class="headerlink" title="Config Update"></a>Config Update</h3><p>在自动回复功能中，提供了一些可供用户配置的选项。在实际使用的过程中，用户可能会需要动态的调整配置，最常见的就是调整自动回复的内容。为了避免每一次的配置调整都需要重启程序，设计了配置的更新的功能：</p>
<ol>
<li>建立一个缓存用于接收新的用户配置；</li>
<li>每一次自动回复即将触发时检查缓存，是否有新的用户配置下发，如果有，则先更新配置再进行后续的自动回复；</li>
<li>更新配置时只更新合法存在的字段，跳过对非法字段的更新。</li>
</ol>
<p>使用缓存的目的是为了避免锁的使用，配置涉及多个字段，无法做到原子更新。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/config update.drawio.png" width="70%" height="70%" alt="Config Update">

<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><blockquote>
<p>命令行又不是不能用！</p>
</blockquote>
<p>用户肯定都希望应用是简单易用的，并不是所有人都会使用，或者能接受仅支持命令行的工具的，为此需要为用户提供一个GUI用于交互。</p>
<p>对桌面用户而言，提供GUI，最开始想到的是开发一个桌面应用程序。虽然Python确实有对应的开发包，如<a href="">PyQt</a>、<a href="">Tkinter</a>等，但直接开发桌面应用程序总是有一些各种各样的弊端：</p>
<ul>
<li>开发工具的使用：使用这些对应的开发包有着对应的学习成本，根据我的Qt使用经验而言，Qt的安装十分臃肿，PyQt应该也好不到哪去；</li>
<li>丑：没什么好说的；</li>
<li>前后端耦合：这个其实是我个人的原因，开发GUI时，使用对应语言的GUI工具，总是将前后端代码耦合在一块，不利于扩展。</li>
</ul>
<p>所以，虽然后端是Python，前端未必需要直接使用Python开发。换句话说，你的桌面应用程序，又何必一定是一个桌面应用程序呢？mattermost本身就是一个很好的例子，桌面客户端仅仅是web浏览器内核的一个封装，这种前后端分离的好处是后端可以提供相同的接口，前端可以依靠自身特点去实现，避免了耦合。</p>
<p>所以最终的实现上，使用Python实现了一个web服务器，再使用HTML编写了一个页面用于交互，套用了一些CSS模板后，交互效果还不错。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/web console.png" width="70%" height="70%" alt="Web Console">

<p>除了用户登陆、配置更新等交互，还有一点是，用户如何运行web服务器，如果还是直接通过命令行执行Python的方式，多少还是有点捞。为此，使用<a href="https://github.com/pyinstaller/pyinstaller">PyInstaller</a>将脚本、资源文件和解释器封装成一个可执行文件，并为其设置了一个图标，这样一来用户可以通过直接运行可执行文件的方式去运行工具（不过PyInstaller打包时会依赖一些平台特定的动态库，这部分不是很通用，不同的操作系统上可能需要重新打包）。</p>
<p>同时还使用了<a href="https://github.com/moses-palmer/pystray">PyStray</a>为工具创建了一个托盘图标，用户可以通过点击图标的方式打开web页面进行交互，同时可以通过图标来退出程序。</p>
<img src="/images/2022-02-17-Mattermost-auto-reply-tool/tray.png" width="70%" height="70%" alt="Tray Icon">

<h3 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h3><ul>
<li>群聊的自动回复：在群聊收到的post中，依据特定的触发词，如@，触发自动回复；</li>
<li>内存清理：目前为每一个触发过自动回复的channel创建一条记录，每触发一次自动回复将会更新其中的最后一次自动回复的时间。理论上最糟糕的场景是，一直有新的私聊触发自动回复，且触发自动回复后，不再有任何消息。这会导致记录一直增长得不到释放，所以需要有机制去清理理论上可能无限增长的内存记录；</li>
<li>优化自动回复条件：目前使用自动回复间隔来判断是否符合自动回复的条件，但其实可以使用当前channel的历史最后一条post的时间来判断，这样可以减少一定的内存使用，同时将用户自己发出的消息，也加入判断条件中，避免了用户主动发送消息，同时收到回复后，在自动回复间隔满足条件的情况下自动回复的场景（这种主动发起会话，在回复间隔符合条件时也不应该自动回复）；</li>
<li>进程退出的资源回收：目前功能单一，不进行资源回收也没有太大问题，不过合理的代码应该要做好资源回收再退出程序，避免后续因为功能扩展，退出时需要回收资源的时候重新处理；</li>
<li>UI代码优化：精简一些无用的CSS引用。</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>For Fun</tag>
      </tags>
  </entry>
  <entry>
    <title>Travels of Martzki: Travel in Hangzhou in 2021</title>
    <url>/2022/02/07/Travel-in-Hangzhou-in-2021/</url>
    <content><![CDATA[<p>2021年的清明节假期，是我的第一次杭州旅行。一是想体验下杭州的清明时节，欣赏下西湖美景；二是亲身感受下杭州作为一线IT城市的氛围。  </p>
<span id="more"></span>
<h1 id="住"><a href="#住" class="headerlink" title="住"></a>住</h1><p>由于假期比较短，所以选择了住在西湖附近。其实最初想选择湖边的酒店或者民宿，不过由于预订的时间和💰的问题，最后选择了南高峰附近的民宿。<br>事后觉得住在西湖附近的决定是正确的，一是本身假期短，主要游玩的地方也是西湖，距离会近一些；二是节假日的杭州，交通真是太堵了，特别是西湖景区附近，打车非常困难。</p>
<h1 id="行"><a href="#行" class="headerlink" title="行"></a>行</h1><p>出行方式主要是打车和公共交通为主。<br>杭州有地铁，但西湖景区附近没有。西湖景区附近，出行方式的便捷度：步行 &gt; 共享单车 &gt; 公交车 &gt; 打车。<br>从我们在西湖景区附近打车的经验来看，较早或较晚的时候还是可以打到车的，但是白天，特别是午晚餐时间，打车十分困难，这个时间点主要选择步行或共享单车，不过高峰期共享单车也是一车难求。<br>PS 杭州的出租车属于比较老旧的燃油汽车，乘坐体验比较差，电动车的普及率比较低。</p>
<h1 id="玩"><a href="#玩" class="headerlink" title="玩"></a>玩</h1><p>西湖附近的主要游玩景点就是“西湖十景”，虽然通常这些官方推荐的景点质量良莠不齐，但西湖附近的游玩基本离不开这些景点。<br>湖边游览的顺序基本上是断桥出发，一路游览景色走到苏堤。</p>
<h2 id="雷峰塔"><a href="#雷峰塔" class="headerlink" title="雷峰塔"></a>雷峰塔</h2><p>西湖十景之一雷峰夕照中的雷峰，指的就是雷峰塔，同时也是白蛇传中白娘子被镇压的宝塔。<br>但实际上，这是一个我个人不推荐的景点。<br>首先，目前的雷峰塔经历了重建，最初的雷峰塔的断壁残垣，保留在目前的雷峰塔的底层，可供游客远程观赏，不过也就是一些砖块罢了；<br>其次，西湖十景的雷峰夕照，指的是夕阳西下时，阳光照在西湖和雷峰塔附近的景色。雷峰塔本身，塔内景色非常普通，登到最高层，可以眺望西湖，不过景色一般（和在黄鹤楼上眺望长江差不多一个意思）；<br>最后，还是人多😑。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_2048.jpeg" width="70%" height="70%" alt="雷峰塔中的白蛇传木雕"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1502.jpeg" width="70%" height="70%" alt="雷峰塔"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_7644.jpeg" width="70%" height="70%" alt="雷峰塔上眺望的西湖景色"></p>
<h2 id="断桥"><a href="#断桥" class="headerlink" title="断桥"></a>断桥</h2><p>西湖十景之一的断桥残雪中的断桥，是我们的西湖游览行程的起点，同样也是许多人的起点，所以人很多，如果想要拍照的话，可以选择早一点过去。<br>不过清明假期杭州最低气温只有十度左右，清晨的湖边，特别是阴天，还是非常冷的，需要做好一定的御寒准备。<br>此外，白堤连接着锦带桥和断桥，在桥上拍照时如果断桥人多可以考虑在锦带桥代替下🤡。  </p>
<h2 id="西湖自划船"><a href="#西湖自划船" class="headerlink" title="西湖自划船"></a>西湖自划船</h2><p>西湖边有多个划船的停泊点，需要注意的是至少需要两个人，同时受湖中风浪影响，风浪过大时，是不允许划船的。如果一定要划船的话，需要提前做好准备。</p>
<h2 id="三潭映月"><a href="#三潭映月" class="headerlink" title="三潭映月"></a>三潭映月</h2><p>西湖十景之一，1元人民币背面取景地，位于西湖中央的湖中岛。上下岛需要从西湖边坐船，有多个码头，可以从不同的码头上下。<br>虽然节假日的杭州哪里都人多，但湖中岛的人格外的多，因为岛上面积不大，离开岛也需要排队坐船，所以导致离岛的队伍很长，上岛容易离岛难。<br>本身景点主要是岛上的一些建筑和湖中的三个石塔，景点本身差强人意，但人实在是太多，和人群摩肩接踵大大降低了游览的兴致。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6158.jpeg" width="70%" height="70%" alt="三潭映月中的湖中石塔和雷峰塔"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1452.jpeg" width="70%" height="70%" alt="岛内景色（一）"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1295.jpeg" width="70%" height="70%" alt="岛内景色（二）"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1913.jpeg" width="70%" height="70%" alt="岛内景色（三）"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6983.jpeg" width="70%" height="70%" alt="岛上码头排队的游客"></p>
<h2 id="灵隐寺"><a href="#灵隐寺" class="headerlink" title="灵隐寺"></a>灵隐寺</h2><p>灵隐寺是西湖景区的比较有名的寺庙了，寺庙本身不小，依山而建。不过我本人对寺庙相关的宗教文化不感冒，并且由于我们去的时候几乎已经走了一天了，随便看了看我就歇菜了🤡，并没有去到最高的庙宇。<br>如果对宗教文化比较感兴趣，或者喜欢到处打卡的话，可以一去；如果像我一样的话就不建议去了。<br>另外，在灵隐寺可以乘坐索道去北高峰，但是索道开放时间有限制，且北高峰不属于灵隐寺的范围，可根据个人情况选择。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6106.jpeg" width="70%" height="70%" alt="灵隐寺"></p>
<h2 id="杨公堤"><a href="#杨公堤" class="headerlink" title="杨公堤"></a>杨公堤</h2><p>杨公堤说是和苏堤白堤齐名，但实际上游客比热门的那些景点要少多了，我们去的时候甚至没有什么人。这里的树林环境很好，很放松，时间不急的话可以来这里散散步。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_1974.jpeg" width="70%" height="70%" alt="杨公堤湖边"></p>
<h2 id="九溪十八涧"><a href="#九溪十八涧" class="headerlink" title="九溪十八涧"></a>九溪十八涧</h2><p>九溪十八涧是一条漫长的山路，一路上围绕着高耸的树林，时不时的还有一些茶园，路过村落时各家各户也在售卖自家的茶叶。随着交错的溪涧，从龙井一路下山，最终可以直接到达钱塘江边，虽然不在西湖边，不过是一个是一个散步的好地方，游客也不多，同时尽管整个景区有着不计其数的溪涧，得益于景区的工作人员的垃圾打捞，水很干净。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6103.jpeg" width="70%" height="70%" alt="九溪十八涧"></p>
<h2 id="茶叶博物馆"><a href="#茶叶博物馆" class="headerlink" title="茶叶博物馆"></a>茶叶博物馆</h2><p>茶叶博物馆最初是在行程计划之中的，后来由于时间紧迫，原本不打算去了，但我们在乘坐公交车时，错误地提前了一站下车。不过没想到下车以后发现了一大片茶园，仔细一看居然就是之前计划去的茶叶博物馆。<br>我们到达的时候已经是晚饭时间了，整个茶园几乎没什么人，非常适合拍照。关于博物馆内部，由于是节假日，同时也到了晚饭时间，就没有进去游览了。如果对博物馆内部有兴趣，可以提前咨询下开放时间。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_2259.jpeg" width="70%" height="70%" alt="茶叶博物馆的茶园"></p>
<h1 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h1><p>在杭州吃了几顿杭帮菜，通常都有东坡肉、龙井秋葵什么的，最不推荐的就是西湖醋鱼，这玩意应该99%的人都不会觉得好吃。<br>杭州有一些全国连锁的杭帮菜的总店，像绿茶和外婆家，如果喜欢这些餐厅也可以去试试它们的总店。</p>
<h2 id="河坊街"><a href="#河坊街" class="headerlink" title="河坊街"></a>河坊街</h2><p>河坊街没什么说的，就是那种每个旅游城市都会有的那种充斥着义乌小商品、坑一波外地游客就走的商业街，类似武汉的户部巷，极不推荐。</p>
<h2 id="春夏秋冬"><a href="#春夏秋冬" class="headerlink" title="春夏秋冬"></a>春夏秋冬</h2><p>去这家餐厅其实是一个巧合，我们当时在茶叶博物馆游览完成后，准备前往民宿老板推荐的一家杭帮菜馆——茶人村，但到了餐厅发现排队非常夸张，还有很多旅游大巴也带着游客在这里就餐。虽然餐厅装修上有一定的特色，但整个餐厅有一股浓浓的网红风，加上过长的等待时间，我们就换到了隔壁的春夏秋冬。<br>餐厅的环境不错，菜式也比较有特色（照片不知道咋的没了🤡），还有室外餐位，不过当时杭州的天气还是比较凉的，也没有人选择室外就餐。整体的服务质量也还不错，最重要的是不怎么需要排队。</p>
<h2 id="Doux-Amour"><a href="#Doux-Amour" class="headerlink" title="Doux Amour"></a>Doux Amour</h2><p>这家其实不是杭帮菜，而是一家网红的动物泡芙店，<a href="https://www.douxamour.com.au/">总店</a>应该是在澳洲，国内似乎只有杭州有分店。<br>店里的所有泡芙都是小动物造型，非常可爱。但是泡芙本身由于保质期问题，不太适合当作伴手礼，去吃个下午茶拍拍照片还是不错的。<br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6276.jpeg" width="70%" height="70%" alt="Doux Amour的菜单"><br><img src="/images/2022-02-07-Travel-in-Hangzhou-in-2021/IMG_6272.jpeg" width="70%" height="70%" alt="Doux Amour的动物泡芙"></p>
<h2 id="国宾馆紫薇厅"><a href="#国宾馆紫薇厅" class="headerlink" title="国宾馆紫薇厅"></a>国宾馆紫薇厅</h2><p>知乎上看到的推荐，原文中提到知道的人少，去的人不多，不过这些年估计各种安利种草后，看到推荐慕名而去的人也不少了。<br>紫薇厅不接受预订，开放时间应该是下午四点。我们在四点左右到达紫薇厅门口，被告知已经人满了不再接待，不知道是真满了还是被大佬们预定了🤡，有兴趣的话可以试一试。</p>
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtio feature negotiation from QEMU perspective</title>
    <url>/2022/02/06/Virtio-feature-negotiation-from-QEMU-perspective/</url>
    <content><![CDATA[<h1 id="QEMU中的Virtio-features协商流程"><a href="#QEMU中的Virtio-features协商流程" class="headerlink" title="QEMU中的Virtio features协商流程"></a>QEMU中的Virtio features协商流程</h1><p>下面以virtio-net对接vhost-net（kernel）为例，分析整个Virtio features协商的过程。</p>
<h2 id="vhost-net"><a href="#vhost-net" class="headerlink" title="vhost-net"></a>vhost-net</h2><p>vhost_net作为描述后端的数据结构，与真正使用的后端（vhost_user or vhost_net）对应。<br>每个vhost_net包含一个vhost_dev，vhost_net的features实际就是vhost_dev的features，与features相关的成员有：<code>features</code>，<code>acked_features</code>，<code>backend_features</code>和<code>protocol_features</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_net</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> <span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> <span class="title">vqs</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> backend;</span><br><span class="line">    NetClientState *nc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> &#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> features;</span><br><span class="line">    <span class="keyword">uint64_t</span> acked_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> protocol_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="vhost-dev-features"><a href="#vhost-dev-features" class="headerlink" title="vhost_dev::features"></a>vhost_dev::features</h3><p>在<code>vhost_dev_init</code>中，通过后端对应的接口（ioctl or unix socket），从后端获取到的后端支持的features。</p>
<h3 id="vhost-dev-acked-features"><a href="#vhost-dev-acked-features" class="headerlink" title="vhost_dev::acked_features"></a>vhost_dev::acked_features</h3><p>前端依据从后端获取的host features进行协商，协商完成后真正向后端传递的features（过滤了后端不支持的features），即后端真正工作的features。</p>
<h3 id="vhost-dev-backend-features"><a href="#vhost-dev-backend-features" class="headerlink" title="vhost_dev::backend_features"></a>vhost_dev::backend_features</h3><p>从命名看是描述后端的features，但和features字段重复。vhost-net相关的实际代码调用如下：</p>
<ol>
<li>vhost_net_ack_features: 在设置acked_features之前，用backend_features的值为acked_features初始化。这里acked_features为何不初始化为0，从QEMU开发者的邮件讨论看，之前在初始化0时，acked_features在在某些情况下会被初始化为unexpected value（This will result an unexpected value of acked_features which may fail the features setting of vhost.）。不过初始化为backend_features似乎在vdpa的场景下有新的问题，且问题仍然open中；<a href="https://bugs.launchpad.net/qemu/+bug/1924603">^1</a></li>
<li>vhost_net_init: 在后端为vhost-net的条件下，如果后端对应的tap设备不支持vnet_hdr，则backend_features中的<code>VHOST_NET_F_VIRTIO_NET_HDR</code>被置位，否则为0；</li>
<li>vhost_user_backend_init: 在后端为vhost-user的条件下，如果后端支持<code>VHOST_USER_F_PROTOCOL_FEATURES</code>，则backend_features中的<code>VHOST_USER_F_PROTOCOL_FEATURES</code>被置位。</li>
</ol>
<p>此外，内核vhost代码中定义了<code>VHOST_NET_BACKEND_FEATURES</code>，对应的ioctl操作为<code>VHOST_GET_BACKEND_FEATURES</code>和<code>VHOST_SET_BACKEND_FEATURES</code>，不过目前QEMU代码中没有这两个ioctl操作对应的逻辑。</p>
<h3 id="vhost-dev-protocol-features"><a href="#vhost-dev-protocol-features" class="headerlink" title="vhost_dev::protocol_features"></a>vhost_dev::protocol_features</h3><p>协议的扩展features。为了保持向下兼容性，vhost-user协议新增的features使用protocol_features进行描述，由<code>VHOST_USER_F_PROTOCOL_FEATURES</code>进行控制，标识protocol_features是否使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VHOST_USER_F_PROTOCOL_FEATURES 30</span></span><br></pre></td></tr></table></figure>
<p>在vhost-net场景下，protocol_features被设置为0。</p>
<h2 id="virtio-net"><a href="#virtio-net" class="headerlink" title="virtio-net"></a>virtio-net</h2><p>virtio-net作为描述后端的数据结构，与Guest的前端驱动（virtio_net）对应。在QEMU中，用VirtIONet来描述virtio-net，每个VirtIONet结构中包含了其对应的VirtIODevice。其中与features有关的成员有：VirtIONet的<code>host_features</code>，VirtIODevice的<code>guest_features</code>，<code>host_features</code>和<code>backend_features</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtIONet</span> &#123;</span></span><br><span class="line">    VirtIODevice parent_obj;</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> host_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtIODevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> guest_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> host_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="VirtIONet-host-features"><a href="#VirtIONet-host-features" class="headerlink" title="VirtIONet::host_features"></a>VirtIONet::host_features</h3><p>从virtio设备的角度来看，只区分Guest与Host，并不关心Host的具体实现。所以VirtIONet::host_features代表了Host理论可以支持的所有features。</p>
<p>VirtIONet::host_features在<code>virtio_net_class_init</code>中使用QEMU中virtio-net设备的默认属性<code>virtio_net_properties</code>（其中包含了offload相关的features）来初始化，同时在每个virtio-net设备实例化时，依据后端设备（e.g. tap）的配置，对部分features进行设置。</p>
<p>VirtIONet::host_features唯一的调用处在<code>virtio_net_get_features</code>，即响应Guest前端驱动的get_features请求，VirtIONet::host_features作为初始值，在一系列的过滤动作后，向前端返回Host所支持的features（细节见下文）。</p>
<h3 id="VirtIODevice-host-features"><a href="#VirtIODevice-host-features" class="headerlink" title="VirtIODevice::host_features"></a>VirtIODevice::host_features</h3><p>VirtIODevice::host_features在<code>virtio_bus_device_plugged</code>中调用对应virtio设备的get_features进行初始化，保存的是get_features的返回值，即真正返回给前端驱动的features。</p>
<p><code>virtio_net_get_features</code>向前端返回features的逻辑如下：</p>
<ol>
<li>VirtIONet::host_features作为初始features；</li>
<li>如果后端设备（e.g. tap）不支持vnet_hdr，则将features中对应的offload features取消置位；</li>
<li>QEMU内部预定义了后端支持的feature_bits（kernel_feature_bits or user_feature_bits），将feature_bits支持但vhost_dev::features中不支持的bit在features中取消置位；</li>
<li>对<code>VIRTIO_NET_F_MTU</code>进行特殊处理（和<code>mtu_bypass_backend</code>有关，对整体协商流程不重要）；</li>
<li>将上述流程中处理后的features返回给前端驱动。</li>
</ol>
<p>要注意VirtIODevice::host_features和VirtIONet::host_features的区别，VirtIONet::host_features是Host理论可以支持的所有features，而VirtIODevice::host_features是对VirtIONet::host_features中依据后端、设备的设置进行处理后，真正返回给前端驱动的features。</p>
<h3 id="VirtIODevice-guest-features"><a href="#VirtIODevice-guest-features" class="headerlink" title="VirtIODevice::guest_features"></a>VirtIODevice::guest_features</h3><p>Guest前端驱动用自身features和get_features得到的VirtIODevice::host_features进行协商后，传递给QEMU，与VirtIODevice::host_features取交集，保存得到guest_features。即前后端在Guest协商后得到的features。</p>
<h3 id="VirtIODevice-backend-features"><a href="#VirtIODevice-backend-features" class="headerlink" title="VirtIODevice::backend_features"></a>VirtIODevice::backend_features</h3><p>看代码调用是为了特殊处理<code>mtu_bypass_backend</code>保存的，在<code>virtio_net_get_features</code>处理流程中，特殊处理<code>VIRTIO_NET_F_MTU</code>前保存的features，除了<code>VIRTIO_NET_F_MTU</code>和VirtIODevice::host_features有差异外，其他一致。</p>
<h2 id="QEMU正常启动流程中的features协商"><a href="#QEMU正常启动流程中的features协商" class="headerlink" title="QEMU正常启动流程中的features协商"></a>QEMU正常启动流程中的features协商</h2><p>QEMU正常启动流程中，从开始运行到GuestOS启动的RunState的变化：<code>preconfig</code>-&gt;<code>prelaunch</code>-&gt;<code>running</code>。</p>
<p>上述RunState变化过程中，virtio设备的features相关流程如下：</p>
<ol>
<li>preconfig: <code>qemu_init</code>-&gt;<code>net_init_clients</code>-&gt;……-&gt;<code>net_init_tap</code>-&gt;……-&gt;<code>vhost_net_init</code>，初始化tap和vhost_dev。其中vhost_dev初始化时，调用后端对应的接口，获取后端支持的所有features，用来初始化<code>vhost_dev::features</code>，同时依据对端设备（tap）支持的特性，初始化<code>vhost_dev::backend_features</code>，以及初始化<code>vhost_dev::protocol_features</code>为0；</li>
<li>prelaunch: 调用<code>virtio_bus_device_plugged</code>，通过对应设备类型的get_features，初始化<code>VirtIODevice::host_features</code>；</li>
<li>running: <ul>
<li>GuestOS启动，内部virtio_net驱动被加载，调用<code>virtio_dev_probe</code>-&gt;……-&gt;<code>vp_get_features</code>获取设备的features，即QEMU侧的<code>VirtIODevice::host_features</code>，再与自身驱动支持的features进行协商，协商完成后调用<code>virtio_finalize_features</code>-&gt;……-&gt;<code>vp_set_features</code>将协商好的features传给QEMU；</li>
<li>此时发生VM-EXIT，QEMU侧调用<code>virtio_set_features</code>-&gt;……-&gt;<code>virtio_net_set_features</code>-&gt;……-&gt;<code>vhost_ack_features</code>，把前端驱动传递过来的features和后端对应feature_bits共同支持的bit置位，将结果保存在<code>vhost_dev::acked_features</code>；</li>
<li>GuestOS中<code>virtio_finalize_features</code>-&gt;……-&gt;<code>vp_set_features</code>执行完成后，会设置<code>VIRTIO_CONFIG_S_FEATURES_OK</code>，进而触发QEMU侧的对应调用<code>virtio_set_status</code>-&gt;……-&gt;<code>vhost_dev_start</code>。在<code>vhost_dev_start</code>中，调用<code>vhost_dev_set_features</code>，将前端协商好的<code>vhost_dev::acked_features</code>通过后端对应的接口传递到后端。</li>
</ul>
</li>
</ol>
<h2 id="QEMU热迁移流程中的features协商"><a href="#QEMU热迁移流程中的features协商" class="headerlink" title="QEMU热迁移流程中的features协商"></a>QEMU热迁移流程中的features协商</h2><p>QEMU热迁移流程中，源虚拟机从开始运行到迁移结束的RunState变化：<code>running</code>-&gt;<code>finish_migrate</code>-&gt;<code>postmigrate</code>；目的虚拟机从开始运行到GuestOS启动的RunState的变化：<code>preconfig</code>-&gt;<code>inmigrate</code>-&gt;<code>running</code>。</p>
<h3 id="源端virtio-features在热迁移流程中的变化"><a href="#源端virtio-features在热迁移流程中的变化" class="headerlink" title="源端virtio features在热迁移流程中的变化"></a>源端virtio features在热迁移流程中的变化</h3><ol>
<li>running: 正常运行状态，无相关操作；</li>
<li>finish_migrate: <code>virtio_save</code>中保存<code>VirtIODevice::guest_features</code>的低32bit，迁移到目的端。</li>
</ol>
<h3 id="目的端virtio-features在热迁移流程中的变化"><a href="#目的端virtio-features在热迁移流程中的变化" class="headerlink" title="目的端virtio features在热迁移流程中的变化"></a>目的端virtio features在热迁移流程中的变化</h3><ol>
<li>preconfig: 和正常启动流程一致；</li>
<li>inmigrate: <ul>
<li>调用<code>virtio_bus_device_plugged</code>，通过对应设备类型的get_features，初始化<code>VirtIODevice::host_features</code>；</li>
<li><code>virtio_load</code>-&gt;……-&gt;<code>virtio_net_set_features</code>-&gt;……-&gt;<code>vhost_ack_features</code>，在<code>virtio_load</code>中接收源端协商完成的<code>VirtIODevice::guest_features</code>，在<code>vhost_ack_features</code>中将接收到的<code>VirtIODevice::guest_features</code>和后端对应feature_bits共同支持的bit置位，将结果保存在<code>vhost_dev::acked_features</code>；</li>
</ul>
</li>
<li>running: <code>qemu_main_loop</code>-&gt;<code>main_loop_wait</code>-&gt;……-&gt;<code>vm_start</code>-&gt;……-&gt;<code>virtio_set_features</code>，使用inmigrate过程中设置好的<code>vhost_net::acked_features</code>通过后端对应的接口传递到后端。</li>
</ol>
<h2 id="正常启动流程和热迁移流程对比"><a href="#正常启动流程和热迁移流程对比" class="headerlink" title="正常启动流程和热迁移流程对比"></a>正常启动流程和热迁移流程对比</h2><p>硬件设备的初始化流程都一致，除了PCI设备的一些状态也是通过迁移初始化之外，最主要的区别在于热迁移流程中的features协商过程：协商必须的<code>VirtIODevice::guest_features</code>通过热迁移从源端获取，后端直接和QEMU进行协商流程；协商流程控制不再需要前端驱动修改设备status，而是在QEMU热迁移流程中触发。前端驱动不参与、不感知，避免了重新初始化。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
        <tag>Virtio/Vhost</tag>
      </tags>
  </entry>
  <entry>
    <title>Some attempts to connect to VDI</title>
    <url>/2022/02/06/Some-attempts-to-connect-to-VDI/</url>
    <content><![CDATA[<h1 id="Why-do-I-need-to-do-this"><a href="#Why-do-I-need-to-do-this" class="headerlink" title="Why do I need to do this"></a>Why do I need to do this</h1><p>公司提供VDI作为办公环境，远程办公时，需要通过VPN先连接到公司内网，再从内网连接到办公VDI。<br>公司提供了Mac和Windows的VPN客户端用于连接到内网，按理说安装并使用公司提供的客户端连接内网即可，但是之所以没有这么做有两个主要原因：    </p>
<ul>
<li>公司提供的VPN配套的软件太过臃肿；</li>
<li>公司提供的VDI内置了访问控制软件，会记录IM的聊天记录等信息。担心VPN“附赠”的软件或者VPN本身会做类似的操作🙄。</li>
</ul>
<p>这篇博文主要记录下折腾虚拟桌面环境的一些经历。</p>
<span id="more"></span>

<h1 id="What-attempts-did-I-try"><a href="#What-attempts-did-I-try" class="headerlink" title="What attempts did I try"></a>What attempts did I try</h1><p>由于上面说的原因，需要在个人PC环境之外，提供一个桌面环境用于远程连接到VDI。<br>再去配置一套物理桌面环境显然是不现实的，所以主要向虚拟桌面环境考虑：</p>
<ul>
<li>Windows Sandbox</li>
<li>Cloud Virtual Mechine</li>
<li>Reverse Proxy (frp)</li>
<li>MacOS Container</li>
</ul>
<h2 id="Windows-Sandbox"><a href="#Windows-Sandbox" class="headerlink" title="Windows Sandbox"></a>Windows Sandbox</h2><p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-sandbox/windows-sandbox-overview">Windows Sandbox</a>是一个非常好的选择，它是Windows内置的虚拟化技术，在Windows 10的专业/企业版中打开选项后可以直接启动。<br>该技术和通用的虚拟化技术一样，对CPU的虚拟化特性也有一定要求，不过不是太老的CPU应该都能够满足要求。在我个人的移动端4代i7、8G内存的PC上，Windows 10和Windows 11中，Windows Sandbox都有足够好的表现。因为它只是虚拟了一套运行环境（runtime environment），应该是WIndows自己的容器化技术。相比于直接运行一个虚拟机而言，轻量的多，同时它还支持GPU虚拟化，从实际使用体验上来看，Sandbox的启停都足够快，同时图形性能对于基本办公足够使用了。<br>但它有个明显的弊端：所有在Sandbox中所做修改都不会被保存，将会随Sandbox进程的退出一并被销毁（类似于加了<code>--rm</code>参数的docker容器🤨）。这个特性提供了绝对的Sandbox环境，但和我个人的使用场景上并不是完全契合，每次需要连接VDI时都要全新安装一整套的VPN软件，不过总体来说从使用难度和使用体验上来说，还是相对不错的。<br>没有最终使用这个方案的原因主要是因为我的Windows PC坏了😅。</p>
<h2 id="Cloud-Virtual-Mechine"><a href="#Cloud-Virtual-Mechine" class="headerlink" title="Cloud Virtual Mechine"></a>Cloud Virtual Mechine</h2><p>Windows PC坏了以后，开始转战MacOS。虚拟机是一个常见的能够提供虚拟桌面环境的方式，由于MacOS的软件生态（主要是💰的问题），没有选择直接在MacOS上运行虚拟机，转而考虑公有云提供的虚拟机服务，正好看到腾讯云有轻量应用服务器的优惠，且支持Windows系统，遂马上下单。<br>但当真正使用这个虚拟机时发现，公司提供的VPN客户端不支持在Windows Server安装（垃圾🙃），同时这个轻量应用服务器不支持自行上传镜像安装系统，所以没法直接重装成个人版的Windows。<br>但，买都买了，还是折腾下吧。</p>
<h3 id="Nested-Virtualization"><a href="#Nested-Virtualization" class="headerlink" title="Nested Virtualization"></a>Nested Virtualization</h3><p>第一个尝试是虚拟机，没错，是在1核2G的虚拟机上再跑一个Windows虚拟机。<br>基于如此拉胯的硬件配置，Host必不可能选Windows了，所以重装成了CentOS。然后就是supervisor的选择，工作中用的比较多的是QEMU-KVM，相对比较熟悉了，所以尝试换用Virutal Box。<br>虽然<a href="https://www.virtualbox.org/">Virutal Box</a>是Oracle主导的开源项目，但官网就给人一种贫穷的感觉。它主要运行在桌面环境上，虽然提供了命令行工具VBoxManage，但在命令行环境下仍然需要安装一些如QT相关的依赖库。不幸的是在解决了依赖问题，配置好虚拟机后，仍然无法启动，报错是无法启用硬件加速特性（腾讯云的这个虚拟机不支持嵌套虚拟化），在配置里取消了所有硬件加速的选项后，还是无法解决该问题（MacOS上的Virtual Box也是一堆BUG），无奈只能放弃Virtual Box。<br>于是换用QEMU，直接使用yum安装，使用libvirt进行虚拟机配置，由于不支持嵌套虚拟化，同样没法使用QEMU-KVM，只能通过纯模拟的CPU运行GuestOS，虽然能够运行，但是几乎完全无法正常使用，开机需要15min，开机之后所有的操作都是分钟级别的，就是折腾来玩玩罢了。</p>
<h3 id="Dual-Operation-System"><a href="#Dual-Operation-System" class="headerlink" title="Dual Operation System"></a>Dual Operation System</h3><p>这个配置下的嵌套虚拟化也就图一乐，既然官方给的镜像不包含个人版的Windows，同时也不支持自定义上传镜像，那就采用安装双系统的曲线救国的方式。<br>先使用原有分区的空闲空间创建一个新的分区，再将操作系统镜像下载到硬盘上，直接从硬盘运行安装程序，将操作系统安装到新的分区上。<br>为了在1核2G的拉胯配置上尽可能流畅地运行Windows，使用<a href="https://archive.org/details/Tiny7">Tiny7</a>（精简版的Windows 7）作为使用的操作系统，但镜像内不包含Virtio驱动，无法继续安装。下载了几乎所有版本的Virtio驱动在安装时使用，但全都无法奏效，最后无奈换用了<a href="https://archive.org/details/tiny-10_202105">Tiny10</a>（精简版的Windows 10）。使用Tiny10后，在安装时选择硬盘上已有的Virtio驱动，即可完成正常安装。<br>流畅度上来说和自带的Windows Server相比没有明显差距，在远程连接上VDI后，由于自身配置拉胯，流畅度一般。且由于没有显卡，在需要图形渲染的场景下（如窗口切换），卡顿明显。总的来说属于勉强可用的程度，但好处是无需在自己的PC上运行虚拟机。  </p>
<h3 id="Windows-Container"><a href="#Windows-Container" class="headerlink" title="Windows Container"></a>Windows Container</h3><p><a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/">Windows Container</a>是考虑过的另一个折腾方向，Windows官方提供了<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-base-images">镜像</a>，但在Windows Server安装Docker时，始终有问题无法解决，同时Windows容器只能使用和Host相同的kernel，并且无法提供一个基于容器的桌面环境，遂放弃。</p>
<h2 id="Reverse-Proxy-frp"><a href="#Reverse-Proxy-frp" class="headerlink" title="Reverse Proxy (frp)"></a>Reverse Proxy (frp)</h2><p>使用反向代理（如<a href="https://github.com/fatedier/frp">frp</a>）将Windows远程控制服务暴露到公网也是一个可行方案，但细节上没有那么简单。<br>由于办公VDI是和公网隔离的，所以无法直接使用反向代理直接连接到办公VDI。但公司提供了外网VDI用于在办公时访问公网，可以使用反向代理连接到外网VDI，再在外网VDI中安装运行VPN客户端后反向连接到办公VDI内。<br>这种方案下的外网VDI代替了自购的公有云虚拟机，拥有更高的配置，但同样不支持虚拟显卡，图形性能仍然拉胯。按理说可以替代自购的公有云虚拟机了，但由于安全部门审计到frp流量，告知不允许使用此类反向代理，遂放弃。  </p>
<h2 id="MacOS-Container"><a href="#MacOS-Container" class="headerlink" title="MacOS Container"></a>MacOS Container</h2><p>在考虑虚拟化方案时，觉得虚拟机消耗过大后，很容易想到的就是容器技术。如果使用容器技术能够满足需求，那就能够使用一个轻量化的隔离环境。在我只有MacOS的前提下，开始查找是否有MacOS的容器化方案。<br>幸运的是，还真有个项目<a href="https://github.com/sickcodes/Docker-OSX">Docker-OSX</a>，不幸的是，这个项目基于QEMU-KVM，说白了还是虚拟机那一套，所以也就是看了看而已。</p>
<h1 id="What-did-I-chose-finally"><a href="#What-did-I-chose-finally" class="headerlink" title="What did I chose finally"></a>What did I chose finally</h1><p>由于上述种种原因，最终的使用方案是在公有云自购的虚拟机上安装的双系统中，连接到远程VDI。<br>如果有Windows环境的话，还是推荐使用WIndows Sandbox；MacOS环境下，如果能够容忍虚拟机的性能消耗的话，虚拟机应该是一个比较好的选择。<br>相比之下，在公有云上的拉胯虚拟机中连接到远程VDI的方案并不是什么理想方案了。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2022/01/09/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>God, tell us the reason youth is wasted on the young.</p>
</blockquote>
<p>A coder mainly work on network virtualization dataplane development.<br>Email: <a href="mailto:&#109;&#x61;&#x72;&#115;&#49;&#52;&#56;&#53;&#48;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#109;&#x61;&#x72;&#115;&#49;&#52;&#56;&#53;&#48;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p>
<img src="/images/avatar.JPG" width="40%" height="40%">]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
</search>
