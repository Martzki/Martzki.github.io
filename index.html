<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Lost Stars</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/avatar.JPG" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Lost Stars</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['God, tell us the reason', 'Youth is wasted on the young'],
        startDelay: 0,
        typeSpeed: 100,
        loop: false,
        backSpeed: 50,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  

<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Life is tough, update arbitrarily.</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Hello-World"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/31/Hello-World/"
    >Hello World
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/31/Hello-World/" class="article-date">
  <time datetime="2022-01-31T14:45:11.000Z" itemprop="datePublished">2022-01-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Other/">Other</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="About-Hello-World"><a href="#About-Hello-World" class="headerlink" title="About Hello World"></a>About Hello World</h1><ul>
<li>Hello World往往作为很多项目的初始示例程序，我个人把Hello World视为程序员对待“最初”的哲学，所以把它作为这个博客的第一篇博文的标题，用于给这个博客开个头（终于赶在过年前写出来了）。 
      <a class="article-more-link" href="/2022/01/31/Hello-World/"
        >Read more</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/" rel="tag">Other</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Record-of-learning-AF-XDP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/21/Record-of-learning-AF-XDP/"
    >Record of learning AF_XDP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/21/Record-of-learning-AF-XDP/" class="article-date">
  <time datetime="2023-01-21T14:27:20.000Z" itemprop="datePublished">2023-01-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>近年eBPF技术大火，在网络方向上最火的大概就是cilium和XDP了，前者是一个前景非常广阔的CNI，后者是内核里基于eBPF的一个包处理框架。</p>
<p>关于eBPF或XDP，网上有很多介绍文章，这里不会去详细介绍其基础原理，只记录下学习过程中遇到的问题以及对应代码。</p>
<p><code>AF_XDP</code>是内核基于XDP的一层socket封装，和<code>AF_INET</code>、<code>AF_PACKET</code>一样，是一种协议族，可以直接通过socket相关调用去使用。</p>
<p>XDP相关实现的封装层次从低到高为：<code>eBPF</code>-&gt;<code>XDP</code>-&gt;<code>AF_XDP</code>-&gt;<code>libbpf</code>-&gt;<code>APP</code>。</p>
<p><code>AF_XDP</code>相关的代码主要分为三部分：</p>
<ul>
<li>内核：内核代码中的对应实现，对应代码路径为<code>kernel/net/xdp</code>。</li>
<li>libbpf：eBPF接口的封装库，eBPF编程基本都依赖这个库，一些关键特性，如CO-RE都是基于libbpf实现的，对应代码路径为<code>kernel/tools/lib/bpf/xdp.c</code>。</li>
<li>用户态应用代码：使用<code>AF_XDP</code>的用户态应用代码，内核示例为<code>kernel/samples/bpf/xsock_user.c</code>，作为DPDK开发者，我主要关注DPDK代码中的<code>PMD_AF_XDP</code>相关代码，代码路径为<code>dpdk/drivers/net/af_xdp</code>。</li>
</ul>
<p>关于<code>AF_XDP</code>可以参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html">内核文档</a>和<a target="_blank" rel="noopener" href="https://rexrock.github.io/post/af_xdp1/">AF_XDP技术详解</a>。</p>
<p>本文的代码分析基于DPDK 19.11，内核版本4.18以及内核版本对应的libbpf。</p>
<h1 id="PMD-AF-XDP"><a href="#PMD-AF-XDP" class="headerlink" title="PMD_AF_XDP"></a>PMD_AF_XDP</h1><p><code>PMD_AF_XDP</code>也是一种DPDK提供的PMD，主要用途和<code>PMD_AF_PACKET</code>相同，从内核驱动管理的网卡设备获取报文。由于两者都是利用内核socket提供的机制，所以实现上也比较相似，基本就是先创建对应协议族的socket，然后bind到对应的网口上，再通过<code>send</code>/<code>recv</code>等调用去进行报文收发（<code>AF_XDP</code>在收包时不需要调用<code>recv</code>）。</p>
<p><code>PMD_AF_XDP</code>对应的<code>rte_vdev_driver</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_vdev_driver</span> <span class="title">pmd_af_xdp_drv</span> =</span> &#123;</span><br><span class="line">	.probe = rte_pmd_af_xdp_probe,</span><br><span class="line">	.remove = rte_pmd_af_xdp_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h2><p>所有PMD的初始化流程都一样，调用PMD对应的probe函数，这里是<code>rte_pmd_af_xdp_probe</code>。</p>
<p>参数解析、合法性检查等通用流程就直接跳过了，看完整个probe函数，发现基本上就是赋值pmd相关的通用成员，<code>dev_ops</code>、<code>rx_pkt_burst</code>和<code>tx_pkt_burst</code>等。</p>
<p>probe流程中，值得注意的点为收发包队列数据结构初始化完之后，设置了收发包队列互为pair：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queue_cnt; i++) &#123;</span><br><span class="line">	internals-&gt;tx_queues[i].<span class="built_in">pair</span> = &amp;internals-&gt;rx_queues[i];</span><br><span class="line">	internals-&gt;rx_queues[i].<span class="built_in">pair</span> = &amp;internals-&gt;tx_queues[i];</span><br><span class="line">	internals-&gt;rx_queues[i].xsk_queue_idx = start_queue_idx + i;</span><br><span class="line">	internals-&gt;tx_queues[i].xsk_queue_idx = start_queue_idx + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，其他都是通用流程，这里就有一个疑惑：socket在哪创建的？</p>
<p>既然probe流程没有，那就接着看初始化流程，<code>probe</code>完成后，通常就是<code>configure</code>、<code>queue setup</code>，再接着就是<code>start</code>。</p>
<p>然而<code>configure</code>流程和<code>start</code>实现都很简单，不涉及socket创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">eth_dev_start</span><span class="params">(struct rte_eth_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dev-&gt;data-&gt;dev_link.link_status = ETH_LINK_UP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">eth_dev_configure</span><span class="params">(struct rte_eth_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* rx/tx must be paired */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;nb_rx_queues != dev-&gt;data-&gt;nb_tx_queues)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么唯一可能就是在<code>queue setup</code>中。</p>
<h2 id="RX-queue-setup"><a href="#RX-queue-setup" class="headerlink" title="RX queue setup"></a>RX queue setup</h2><p>先看收包队列<code>eth_rx_queue_setup</code>，其中实现很简单，检查了MBUF空间和XDP帧大小是否匹配后调用了<code>xsk_configure</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">xsk_configure</span><span class="params">(struct pmd_internals *internals, struct pkt_rx_queue *rxq,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">int</span> ring_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Init umem. */</span></span><br><span class="line">	rxq-&gt;umem = xdp_umem_configure(internals, rxq);</span><br><span class="line">	<span class="keyword">if</span> (rxq-&gt;umem == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	txq-&gt;umem = rxq-&gt;umem;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Create xsk. */</span></span><br><span class="line">	ret = xsk_socket__create(&amp;rxq-&gt;xsk, internals-&gt;if_name,</span><br><span class="line">			rxq-&gt;xsk_queue_idx, rxq-&gt;umem-&gt;umem, &amp;rxq-&gt;rx,</span><br><span class="line">			&amp;txq-&gt;tx, &amp;cfg);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		AF_XDP_LOG(ERR, <span class="string">&quot;Failed to create xsk socket.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程包含两个部分，初始化<code>umem</code>、创建<code>xsk</code>（AF_XDP socket）。</p>
<h3 id="UMEM"><a href="#UMEM" class="headerlink" title="UMEM"></a>UMEM</h3><p>关于<code>umem</code>官方说明如下：</p>
<blockquote>
<p>UMEM is a region of virtual contiguous memory, divided into equal-sized frames. An UMEM is associated to a netdev and a specific queue id of that netdev. It is created and configured (chunk size, headroom, start address and size) by using the XDP_UMEM_REG setsockopt system call. A UMEM is bound to a netdev and queue id, via the bind() system call.</p>
<p>An AF_XDP is socket linked to a single UMEM, but one UMEM can have multiple AF_XDP sockets. To share an UMEM created via one socket A, the next socket B can do this by setting the XDP_SHARED_UMEM flag in struct sockaddr_xdp member sxdp_flags, and passing the file descriptor of A to struct sockaddr_xdp member sxdp_shared_umem_fd.</p>
<p>The UMEM has two single-producer/single-consumer rings that are used to transfer ownership of UMEM frames between the kernel and the user-space application.</p>
</blockquote>
<p><code>AF_XDP</code>可以通过mmap在用户态和内核态之间传递数据，这块共享内存就是<code>umem</code>。在用户态应用中先初始化好<code>umem</code>，再作为<code>xsk_socket__create</code>的参数传入，在内部完成内核态内存和用户态内存的map。</p>
<p>需要注意的一点是，<code>umem</code>初始化流程中，收发包队列的<code>umem</code>指向的是同样的内存，这样的好处是在收发包队列之间转换时不需要拷贝：</p>
<blockquote>
<p>RX and TX can share the same UMEM so that a packet does not have to be copied between RX and TX. Moreover, if a packet needs to be kept for a while due to a possible retransmit, the descriptor that points to that packet can be changed to point to another and reused right away. This again avoids copying data.</p>
</blockquote>
<p>在<code>PMD_AF_XDP</code>的实现中，每个<code>umem</code>对应了一个<code>buf_ring</code>，用于缓存具体的<code>umem</code>和批量操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct</span></span><br><span class="line"><span class="function">xsk_umem_info *<span class="title">xdp_umem_configure</span><span class="params">(struct pmd_internals *internals,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct pkt_rx_queue *rxq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="built_in">snprintf</span>(ring_name, <span class="keyword">sizeof</span>(ring_name), <span class="string">&quot;af_xdp_ring_%s_%u&quot;</span>,</span><br><span class="line">		       internals-&gt;if_name, rxq-&gt;xsk_queue_idx);</span><br><span class="line">	umem-&gt;buf_ring = rte_ring_create(ring_name,</span><br><span class="line">					 ETH_AF_XDP_NUM_BUFFERS,</span><br><span class="line">					 rte_socket_id(),</span><br><span class="line">					 <span class="number">0x0</span>);</span><br><span class="line">	<span class="keyword">if</span> (umem-&gt;buf_ring == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		AF_XDP_LOG(ERR, <span class="string">&quot;Failed to create rte_ring\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ETH_AF_XDP_NUM_BUFFERS; i++)</span><br><span class="line">		rte_ring_enqueue(umem-&gt;buf_ring,</span><br><span class="line">				 (<span class="keyword">void</span> *)(i * ETH_AF_XDP_FRAME_SIZE));</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>buf_ring</code>的元素个数为<code>ETH_AF_XDP_NUM_BUFFERS</code>，和<code>umem</code>的元素个数是相同的，且初始化为<code>umem</code>元素的偏移，这也是<code>umem</code>的保存形式，需要访问时再通过<code>xsk_umem__get_data</code>获取真正的<code>umem</code>地址。</p>
<h3 id="XSK"><a href="#XSK" class="headerlink" title="XSK"></a>XSK</h3><p><code>umem</code>初始化完成后，就接着调用<code>xsk_socket__create</code>创建<code>xsk</code>，所有<code>xsk_socket__</code>开头的代码，均为<code>libbpf</code>的封装，声明在<code>xsk.h</code>。使用<code>libbpf</code>封装的API大大减少了<code>XDP</code>/<code>eBPF</code>编码的复杂度。</p>
<p>从这个函数可以看出，和<code>AF_PACKET</code>只创建一个socket不同，对<code>AF_XDP</code>而言，每一个收包队列初始化流程中（实际是收发包队列共用）都会创建一个<code>xsk</code>，并且这里需要传入queue id，和<code>AF_PACKET</code>不同，这个queue id对应具体的硬件队列id，这里指定queue id应该就是将具体的<code>XDP</code>/<code>eBPF</code>程序attach到对应队列上的意思。</p>
<p>同时作为参数传入的不仅有rxq，也有rxq，说明收发包队列使用的是同一个xsk，并且同时初始化。</p>
<h2 id="TX-queue-setup"><a href="#TX-queue-setup" class="headerlink" title="TX queue setup"></a>TX queue setup</h2><p>发包队列的初始化非常简单，在上面也说了，收发包队列共用umem和xsk，在收包队列初始化时，已经完成了初始化，所以发包队列的初始化没有任何动作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">eth_tx_queue_setup</span><span class="params">(struct rte_eth_dev *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">uint16_t</span> tx_queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">uint16_t</span> nb_tx_desc __rte_unused,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id __rte_unused,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct rte_eth_txconf *tx_conf __rte_unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pmd_internals</span> *<span class="title">internals</span> =</span> dev-&gt;data-&gt;dev_private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pkt_tx_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line"></span><br><span class="line">	txq = &amp;internals-&gt;tx_queues[tx_queue_id];</span><br><span class="line"></span><br><span class="line">	dev-&gt;data-&gt;tx_queues[tx_queue_id] = txq;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue-change"><a href="#Queue-change" class="headerlink" title="Queue change?"></a>Queue change?</h2><p>从<code>xsk</code>的初始化流程可以看到，每个<code>xsk</code>对应了一个网卡的硬件队列，那么当<code>XDP</code>程序已经attach到对应网卡队列后，再调整网卡队列数，会发生什么呢？</p>
<p>以<code>ethtool</code>调整队列数的代码<code>ethtool_set_channels</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline_for_stack <span class="keyword">int</span> <span class="title">ethtool_set_channels</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">						   <span class="keyword">void</span> __user *useraddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Disabling channels, query zero-copy AF_XDP sockets */</span></span><br><span class="line">	from_channel = channels.combined_count +</span><br><span class="line">		min(channels.rx_count, channels.tx_count);</span><br><span class="line">	to_channel = curr.combined_count + max(curr.rx_count, curr.tx_count);</span><br><span class="line">	<span class="keyword">for</span> (i = from_channel; i &lt; to_channel; i++)</span><br><span class="line">		<span class="keyword">if</span> (xdp_get_umem_from_qid(dev, i))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;ethtool_ops-&gt;set_channels(dev, &amp;channels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到针对待调整的队列，调用了<code>xdp_get_umem_from_qid</code>进行检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct xdp_umem *<span class="title">xdp_get_umem_from_qid</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">				       u16 queue_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue_id &lt; dev-&gt;real_num_rx_queues)</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;_rx[queue_id].umem;</span><br><span class="line">	<span class="keyword">if</span> (queue_id &lt; dev-&gt;real_num_tx_queues)</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;_tx[queue_id].umem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(xdp_get_umem_from_qid);</span><br></pre></td></tr></table></figure>

<p>可以看到上述前置检查中，如果队列上有对应的<code>umem</code>则返回<code>-EINVAL</code>，即如果网卡队列已经attach了<code>XDP</code>程序，则不允许禁用当前队列。</p>
<p><code>AF_XDP</code>的应用场景和<code>AF_PACKET</code>相似，都是在内核驱动正常使用的前提下，在用户态捕获网卡报文的机制，在概念理解的很多时候会进行类比，其中队列这一块就是一个明显差异了，<code>AF_XDP</code>的队列就是网卡的硬件队列，而<code>AF_PACKET</code>的队列是其自身的抽象软件队列，和网卡硬件队列并不是一一对应的关系。</p>
<h2 id="XDP-mode"><a href="#XDP-mode" class="headerlink" title="XDP mode"></a>XDP mode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_SKB_MODE		(1U &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_DRV_MODE		(1U &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_HW_MODE		(1U &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDP_FLAGS_MODES			(XDP_FLAGS_SKB_MODE | \</span></span><br><span class="line"><span class="meta">					 XDP_FLAGS_DRV_MODE | \</span></span><br><span class="line"><span class="meta">					 XDP_FLAGS_HW_MODE)</span></span><br></pre></td></tr></table></figure>

<p><code>XDP</code>支持三种模式，分别对应了不同位置的<code>eBPF</code> hook点，自底向上分别为：<code>XDP_HW</code>、<code>XDP_DRV</code>和<code>XDP_SKB</code>。</p>
<p>在<code>AF_XDP</code>初始化时，通过<code>xsk_socket__create</code>-&gt;<code>xsk_setup_xdp_prog</code>-&gt;<code>xsk_load_xdp_prog</code>-&gt;<code>bpf_set_link_xdp_fd</code>-&gt;<code>rtnl_setlink</code>-&gt;<code>do_setlink</code>-&gt;<code>dev_change_xdp_fd</code>设置<code>XDP mode</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	dev_change_xdp_fd - set or clear a bpf program for a device rx path</span></span><br><span class="line"><span class="comment"> *	@dev: device</span></span><br><span class="line"><span class="comment"> *	@extack: netlink extended ack</span></span><br><span class="line"><span class="comment"> *	@fd: new program fd or negative value to clear</span></span><br><span class="line"><span class="comment"> *	@flags: xdp-related flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Set or clear a bpf program for a device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_change_xdp_fd</span><span class="params">(struct net_device *dev, struct netlink_ext_ack *extack,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">int</span> fd, u32 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">ops</span> =</span> dev-&gt;netdev_ops;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_netdev_command</span> <span class="title">query</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">bpf_op_t</span> bpf_op, bpf_chk;</span><br><span class="line">	<span class="keyword">bool</span> offload;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	ASSERT_RTNL();</span><br><span class="line"></span><br><span class="line">	rh_mark_used_feature(<span class="string">&quot;eBPF/xdp&quot;</span>);</span><br><span class="line"></span><br><span class="line">	offload = flags &amp; XDP_FLAGS_HW_MODE;</span><br><span class="line">	query = offload ? XDP_QUERY_PROG_HW : XDP_QUERY_PROG;</span><br><span class="line"></span><br><span class="line">	bpf_op = bpf_chk = ops-&gt;ndo_bpf;</span><br><span class="line">	<span class="keyword">if</span> (!bpf_op &amp;&amp; (flags &amp; (XDP_FLAGS_DRV_MODE | XDP_FLAGS_HW_MODE))) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;underlying driver does not support XDP in native mode&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!bpf_op || (flags &amp; XDP_FLAGS_SKB_MODE))</span><br><span class="line">		bpf_op = generic_xdp_install;</span><br><span class="line">	<span class="keyword">if</span> (bpf_op == bpf_chk)</span><br><span class="line">		bpf_chk = generic_xdp_install;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!offload &amp;&amp; __dev_xdp_query(dev, bpf_chk, XDP_QUERY_PROG)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;native and generic XDP can&#x27;t be active at the same time&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; XDP_FLAGS_UPDATE_IF_NOEXIST) &amp;&amp;</span><br><span class="line">		    __dev_xdp_query(dev, bpf_op, query)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;XDP program already attached&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		prog = bpf_prog_get_type_dev(fd, BPF_PROG_TYPE_XDP,</span><br><span class="line">					     bpf_op == ops-&gt;ndo_bpf);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prog))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(prog);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!offload &amp;&amp; bpf_prog_is_dev_bound(prog-&gt;aux)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;using device-bound program without HW_MODE flag is not supported&quot;</span>);</span><br><span class="line">			bpf_prog_put(prog);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = dev_xdp_install(dev, bpf_op, extack, flags, prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; prog)</span><br><span class="line">		bpf_prog_put(prog);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用<code>xsk_socket__create</code>时<code>usr_config</code>没有指定<code>xdp_flags</code>的话，默认为<code>0</code>。</p>
<p>可以看到，优先通过<code>dev-&gt;netdev_ops-&gt;ndo_bpf</code>判断对应的设备是否支持<code>XDP_HW</code>或<code>XDP_DRV</code>，对<code>bpf_op</code>赋值后通过<code>dev_xdp_install</code>调用。</p>
<p>所以，对于<code>XDP_SKB</code>模式而言，<code>bpf_op</code>对应的函数为<code>generic_xdp_install</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generic_xdp_install</span><span class="params">(struct net_device *dev, struct netdev_bpf *xdp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">old</span> =</span> rtnl_dereference(dev-&gt;xdp_prog);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">new</span> =</span> xdp-&gt;prog;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (xdp-&gt;command) &#123;</span><br><span class="line">	<span class="keyword">case</span> XDP_SETUP_PROG:</span><br><span class="line">		rcu_assign_pointer(dev-&gt;xdp_prog, <span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (old)</span><br><span class="line">			bpf_prog_put(old);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (old &amp;&amp; !<span class="keyword">new</span>) &#123;</span><br><span class="line">			static_branch_dec(&amp;generic_xdp_needed_key);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span> &amp;&amp; !old) &#123;</span><br><span class="line">			static_branch_inc(&amp;generic_xdp_needed_key);</span><br><span class="line">			dev_disable_lro(dev);</span><br><span class="line">			dev_disable_gro_hw(dev);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> XDP_QUERY_PROG:</span><br><span class="line">		xdp-&gt;prog_id = old ? old-&gt;aux-&gt;id : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到逻辑非常简单，就是设置<code>dev-&gt;xdp_prog</code>，调整<code>generic_xdp_needed_key</code>，如果是初始化的话，再关闭设备的<code>lro</code>和<code>gro</code>。</p>
<p>对<code>PMD_AF_XDP</code>而言，只置位了<code>XDP_FLAGS_UPDATE_IF_NOEXIST</code>，所以和默认行为一样，按照优先顺序使用<code>XDP_HW</code>、<code>XDP_DRV</code>和<code>XDP_SKB</code>。</p>
<h2 id="Where-is-the-XDP-eBPF-program"><a href="#Where-is-the-XDP-eBPF-program" class="headerlink" title="Where is the XDP/eBPF program?"></a>Where is the XDP/eBPF program?</h2><p>至此，<code>PMD_AF_XDP</code>的初始化流程已经结束，上面也分析过了，<code>configure</code>和<code>start</code>中都没有复杂操作，<code>start</code>完成后，PMD就可以正常工作进行收发包了。那么问题来了，<code>XDP</code>/<code>eBPF</code>程序是在哪里被attach上去的呢？这里从<code>xsk_socket__create</code>看起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xsk_socket__create</span><span class="params">(struct xsk_socket **xsk_ptr, <span class="keyword">const</span> <span class="keyword">char</span> *ifname,</span></span></span><br><span class="line"><span class="params"><span class="function">		       __u32 queue_id, struct xsk_umem *umem,</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct xsk_ring_cons *rx, struct xsk_ring_prod *tx,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">const</span> struct xsk_socket_config *usr_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (!(xsk-&gt;config.libbpf_flags &amp; XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD)) &#123;</span><br><span class="line">		err = xsk_setup_xdp_prog(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_mmap_tx;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_setup_xdp_prog</span><span class="params">(struct xsk_socket *xsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (!prog_id) &#123;</span><br><span class="line">		err = xsk_create_bpf_maps(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		err = xsk_load_xdp_prog(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			xsk_delete_bpf_maps(xsk);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		xsk-&gt;prog_fd = bpf_prog_get_fd_by_id(prog_id);</span><br><span class="line">		<span class="keyword">if</span> (xsk-&gt;prog_fd &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -errno;</span><br><span class="line">		err = xsk_lookup_bpf_maps(xsk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			close(xsk-&gt;prog_fd);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_load_xdp_prog</span><span class="params">(struct xsk_socket *xsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> log_buf_size = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">char</span> log_buf[log_buf_size];</span><br><span class="line">	<span class="keyword">int</span> err, prog_fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is the C-program:</span></span><br><span class="line"><span class="comment">	 * SEC(&quot;xdp_sock&quot;) int xdp_sock_prog(struct xdp_md *ctx)</span></span><br><span class="line"><span class="comment">	 * &#123;</span></span><br><span class="line"><span class="comment">	 *     int ret, index = ctx-&gt;rx_queue_index;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *     // A set entry here means that the correspnding queue_id</span></span><br><span class="line"><span class="comment">	 *     // has an active AF_XDP socket bound to it.</span></span><br><span class="line"><span class="comment">	 *     ret = bpf_redirect_map(&amp;xsks_map, index, XDP_PASS);</span></span><br><span class="line"><span class="comment">	 *     if (ret &gt; 0)</span></span><br><span class="line"><span class="comment">	 *         return ret;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *     // Fallback for pre-5.3 kernels, not supporting default</span></span><br><span class="line"><span class="comment">	 *     // action in the flags parameter.</span></span><br><span class="line"><span class="comment">	 *     if (bpf_map_lookup_elem(&amp;xsks_map, &amp;index))</span></span><br><span class="line"><span class="comment">	 *         return bpf_redirect_map(&amp;xsks_map, index, 0);</span></span><br><span class="line"><span class="comment">	 *     return XDP_PASS;</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">		<span class="comment">/* r2 = *(u32 *)(r1 + 16) */</span></span><br><span class="line">		BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1, <span class="number">16</span>),</span><br><span class="line">		<span class="comment">/* *(u32 *)(r10 - 4) = r2 */</span></span><br><span class="line">		BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">		<span class="comment">/* r1 = xskmap[] */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span><br><span class="line">		<span class="comment">/* r3 = XDP_PASS */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_3, <span class="number">2</span>),</span><br><span class="line">		<span class="comment">/* call bpf_redirect_map */</span></span><br><span class="line">		BPF_EMIT_CALL(BPF_FUNC_redirect_map),</span><br><span class="line">		<span class="comment">/* if w0 != 0 goto pc+13 */</span></span><br><span class="line">		BPF_JMP32_IMM(BPF_JSGT, BPF_REG_0, <span class="number">0</span>, <span class="number">13</span>),</span><br><span class="line">		<span class="comment">/* r2 = r10 */</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">		<span class="comment">/* r2 += -4 */</span></span><br><span class="line">		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">		<span class="comment">/* r1 = xskmap[] */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span><br><span class="line">		<span class="comment">/* call bpf_map_lookup_elem */</span></span><br><span class="line">		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),</span><br><span class="line">		<span class="comment">/* r1 = r0 */</span></span><br><span class="line">		BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">		<span class="comment">/* r0 = XDP_PASS */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>),</span><br><span class="line">		<span class="comment">/* if r1 == 0 goto pc+5 */</span></span><br><span class="line">		BPF_JMP_IMM(BPF_JEQ, BPF_REG_1, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">		<span class="comment">/* r2 = *(u32 *)(r10 - 4) */</span></span><br><span class="line">		BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_10, <span class="number">-4</span>),</span><br><span class="line">		<span class="comment">/* r1 = xskmap[] */</span></span><br><span class="line">		BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span><br><span class="line">		<span class="comment">/* r3 = 0 */</span></span><br><span class="line">		BPF_MOV64_IMM(BPF_REG_3, <span class="number">0</span>),</span><br><span class="line">		<span class="comment">/* call bpf_redirect_map */</span></span><br><span class="line">		BPF_EMIT_CALL(BPF_FUNC_redirect_map),</span><br><span class="line">		<span class="comment">/* The jumps are to this instruction */</span></span><br><span class="line">		BPF_EXIT_INSN(),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">size_t</span> insns_cnt = <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(struct bpf_insn);</span><br><span class="line"></span><br><span class="line">	prog_fd = bpf_load_program(BPF_PROG_TYPE_XDP, prog, insns_cnt,</span><br><span class="line">				   <span class="string">&quot;LGPL-2.1 or BSD-2-Clause&quot;</span>, <span class="number">0</span>, log_buf,</span><br><span class="line">				   log_buf_size);</span><br><span class="line">	<span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;BPF log buffer:\n%s&quot;</span>, log_buf);</span><br><span class="line">		<span class="keyword">return</span> prog_fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = bpf_set_link_xdp_fd(xsk-&gt;ifindex, prog_fd, xsk-&gt;config.xdp_flags);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		close(prog_fd);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	xsk-&gt;prog_fd = prog_fd;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是通过调用链<code>xsk_socket__create</code>-&gt;<code>xsk_setup_xdp_prog</code>-&gt;<code>xsk_load_xdp_prog</code>-&gt;<code>bpf_load_program</code>完成的，其中对应的<code>eBPF</code>程序直接硬编码到了<code>xsk_load_xdp_prog</code>中，当然也是由于<code>AF_XDP</code>的功能比较简单，如果是其他功能的<code>XDP</code>/<code>eBPF</code>程序，则会采用其他方式保存源码。</p>
<p>注意<code>xsk_setup_xdp_prog</code>中根据<code>prog_id</code>是否合法，有不同的处理逻辑：</p>
<ul>
<li>当前设备上未attach <code>XDP</code>程序：函数将创建<code>BPF_MAP</code>并进行<code>XDP</code>程序的attach</li>
<li>当前设备上已attach <code>XDP</code>程序：函数查找设备对应的<code>XDP</code>程序id以及对应的<code>BPF_MAP</code>，将其赋值给<code>xsk</code>相应成员</li>
</ul>
<p>由此可见，<code>XDP</code>程序和<code>BPF_MAP</code>是设备级别的，同一个设备只能有一个<code>XDP</code>程序（不支持<code>XDP_ATTACHED_MULTI</code>的场景）和<code>BPF_MAP</code>。这点在<code>net_device</code>的定义中也有体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* RHEL: while xdp_prog is explicitly removed from the kABI</span></span><br><span class="line"><span class="comment">	 * whitelist, one semantics must be preserved: comparison of</span></span><br><span class="line"><span class="comment">	 * xdp_prog to NULL denotes whether a XDP program is loaded or not.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RH_KABI_EXCLUDE(struct bpf_prog __rcu	*xdp_prog)</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xdp_prog</code>只是一个指针，并非一个数组。</p>
<h2 id="RX-amp-TX"><a href="#RX-amp-TX" class="headerlink" title="RX &amp; TX"></a>RX &amp; TX</h2><p>报文收发是PMD的核心功能，接下来看下收发是怎么实现的。之前已经提到了，内核态<code>XDP</code>和用户态应用之间通过<code>umem</code>进行报文收发，那具体是怎么做的呢？</p>
<h3 id="XDP-ring"><a href="#XDP-ring" class="headerlink" title="XDP ring"></a>XDP ring</h3><blockquote>
<p>The UMEM consists of a number of equally sized chunks. A descriptor in one of the rings references a frame by referencing its addr. The addr is simply an offset within the entire UMEM region. The user space allocates memory for this UMEM using whatever means it feels is most appropriate (malloc, mmap, huge pages, etc). This memory area is then registered with the kernel using the new setsockopt XDP_UMEM_REG. The UMEM also has two rings: the FILL ring and the COMPLETION ring. The FILL ring is used by the application to send down addr for the kernel to fill in with RX packet data. References to these frames will then appear in the RX ring once each packet has been received. The COMPLETION ring, on the other hand, contains frame addr that the kernel has transmitted completely and can now be used again by user space, for either TX or RX. Thus, the frame addrs appearing in the COMPLETION ring are addrs that were previously transmitted using the TX ring. In summary, the RX and FILL rings are used for the RX path and the TX and COMPLETION rings are used for the TX path.</p>
</blockquote>
<p>实际上，除了<code>umem</code>外，报文收发还用到了4种不同的数据结构，分别为：</p>
<ul>
<li><code>fill ring</code>：每一个<code>umem</code>只有一个，用于向内核提供<code>umem</code>。</li>
<li><code>completion ring</code>：每一个<code>umem</code>只有一个，用于从内核获取<code>umem</code>。</li>
<li><code>rx ring</code>：用户态应用从<code>rx ring</code>收取报文，每个<code>xsk</code>可以有多个<code>rx ring</code>，应该是对应<code>XDP_SHARED_UMEM </code>的场景。</li>
<li><code>tx ring</code>：用户态应用向<code>tx ring</code>发送报文，每个<code>xsk</code>可以有多个<code>tx ring</code>，应该是对应<code>XDP_SHARED_UMEM </code>的场景。</li>
</ul>
<h3 id="RX-procedure"><a href="#RX-procedure" class="headerlink" title="RX procedure"></a>RX procedure</h3><p>收包流程使用<code>fill ring</code>和<code>rx ring</code>，用户态应用首先需要向内核提供<code>umem</code>用于接收报文，所以先作为producer向<code>fill ring</code>填入<code>umem</code>，内核<code>XDP</code>作为consumer从<code>fill ring</code>获取到可用<code>umem</code>后将报文填入，再作为producer将这部分<code>umem</code>添加到<code>rx ring</code>，最后用户态应用作为consumer从<code>rx ring</code>获取接收到的报文。</p>
<p>在<code>xsk</code>初始化流程中就已经对初始化好的<code>fill ring</code>填入<code>umem</code>了，这样当<code>XDP</code>/<code>eBPF</code>attach完成后就可以立即用这部分<code>umem</code>收包了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_AF_XDP_DFLT_NUM_DESCS	XSK_RING_CONS__DEFAULT_NUM_DESCS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">xsk_configure</span><span class="params">(struct pmd_internals *internals, struct pkt_rx_queue *rxq,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">int</span> ring_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">int</span> reserve_size = ETH_AF_XDP_DFLT_NUM_DESCS / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">	ret = reserve_fill_queue(rxq-&gt;umem, reserve_size, fq_bufs);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		xsk_socket__delete(rxq-&gt;xsk);</span><br><span class="line">		AF_XDP_LOG(ERR, <span class="string">&quot;Failed to reserve fill queue.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里预留的个数实际上是<code>XSK_RING_CONS__DEFAULT_NUM_DESCS / 2</code>，默认情况下<code>ETH_AF_XDP_NUM_BUFFERS = XSK_RING_CONS__DEFAULT_NUM_DESCS * 2 </code>，即这里初始化了<code>umem</code>总量的四分之一，填入了<code>fill ring</code>。</p>
<p>以<code>af_xdp_rx_cp</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">af_xdp_rx_cp</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">queue</span>, struct rte_mbuf **bufs, <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Step 1: Get recv num. */</span></span><br><span class="line">	rcvd = xsk_ring_cons__peek(rx, nb_pkts, &amp;idx_rx);</span><br><span class="line">	<span class="keyword">if</span> (rcvd == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(XDP_USE_NEED_WAKEUP)</span></span><br><span class="line">		<span class="keyword">if</span> (xsk_ring_prod__needs_wakeup(fq))</span><br><span class="line">			(<span class="keyword">void</span>)poll(rxq-&gt;fds, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Reserve some umem to fill ring if necessary. */</span></span><br><span class="line">	<span class="keyword">if</span> (xsk_prod_nb_free(fq, free_thresh) &gt;= free_thresh)</span><br><span class="line">		(<span class="keyword">void</span>)reserve_fill_queue(umem, ETH_AF_XDP_RX_BATCH_SIZE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rcvd; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdp_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">		<span class="keyword">uint64_t</span> addr;</span><br><span class="line">		<span class="keyword">uint32_t</span> len;</span><br><span class="line">		<span class="keyword">void</span> *pkt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 3: Recieve every packets from rx ring. */</span></span><br><span class="line">		desc = xsk_ring_cons__rx_desc(rx, idx_rx++);</span><br><span class="line">		addr = desc-&gt;addr;</span><br><span class="line">		len = desc-&gt;len;</span><br><span class="line">		pkt = xsk_umem__get_data(rxq-&gt;umem-&gt;mz-&gt;addr, addr);</span><br><span class="line"></span><br><span class="line">		rte_memcpy(rte_pktmbuf_mtod(mbufs[i], <span class="keyword">void</span> *), pkt, len);</span><br><span class="line">        <span class="comment">/* Step 4: Enqueue addr to buf_ring after packet recieved. */</span></span><br><span class="line">		rte_ring_enqueue(umem-&gt;buf_ring, (<span class="keyword">void</span> *)addr);</span><br><span class="line">		rte_pktmbuf_pkt_len(mbufs[i]) = len;</span><br><span class="line">		rte_pktmbuf_data_len(mbufs[i]) = len;</span><br><span class="line">		rx_bytes += len;</span><br><span class="line">		bufs[i] = mbufs[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: Update rx ring consumer index. */</span></span><br><span class="line">	xsk_ring_cons__release(rx, rcvd);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收包流程中各步骤如下：</p>
<ul>
<li>Step 1：依据<code>rx ring</code>的producer和consumer差值，获取当前可收取的报文数量。</li>
<li>Step 2：如果<code>fill ring</code>中剩余<code>umem</code>小于阈值的话，则添加一部分进去。</li>
<li>Step 3：从<code>rx ring</code>获取报文对应的<code>umem</code>并拷贝到<code>mbuf</code>完成每个报文的收取。</li>
<li>Step 4：每个<code>umem</code>处理完后入队<code>buf_ring</code>供下次收包/发包使用。</li>
<li>Step 5：更新<code>rx ring</code>中的consumer。</li>
</ul>
<h3 id="TX-procedure"><a href="#TX-procedure" class="headerlink" title="TX procedure"></a>TX procedure</h3><p>看完收包流程后，我原以为以为内核<code>XDP</code>要相对地提前初始化一部分<code>umem</code>，然后用户态向对应<code>umem</code>填入报文完成发包，但事实上不是这样的。</p>
<p>发包流程中，使用<code>completion ring</code>和<code>tx ring</code>，用户态应用首先将报文填入<code>umem</code>，并作为producer将<code>umem</code>填入<code>tx ring</code>，内核<code>XDP</code>作为consumer从<code>tx ring</code>获取报文并发送。发送完成后，作为producer将发送完成的<code>umem</code>填入<code>completion ring</code>，用户态应用再作为consumer从<code>completion ring</code>中回收已经发送完毕的<code>umem</code>供下一次发包/收包使用。</p>
<p>以<code>af_xdp_tx_cp</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">af_xdp_tx_cp</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">queue</span>, struct rte_mbuf **bufs, <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="comment">/* Step 1: Get free umem in completion ring and enqueue to buf_ring. */</span></span><br><span class="line">	pull_umem_cq(umem, nb_pkts);</span><br><span class="line"></span><br><span class="line">	nb_pkts = rte_ring_dequeue_bulk(umem-&gt;buf_ring, addrs,</span><br><span class="line">					nb_pkts, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (nb_pkts == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Reserve tx ring. */</span></span><br><span class="line">	<span class="keyword">if</span> (xsk_ring_prod__reserve(&amp;txq-&gt;tx, nb_pkts, &amp;idx_tx) != nb_pkts) &#123;</span><br><span class="line">		kick_tx(txq);</span><br><span class="line">		rte_ring_enqueue_bulk(umem-&gt;buf_ring, addrs, nb_pkts, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_pkts; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">xdp_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">		<span class="keyword">void</span> *pkt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 3: Send every packet to umem from tx ring. */</span></span><br><span class="line">		desc = xsk_ring_prod__tx_desc(&amp;txq-&gt;tx, idx_tx + i);</span><br><span class="line">		mbuf = bufs[i];</span><br><span class="line">		desc-&gt;len = mbuf-&gt;pkt_len;</span><br><span class="line"></span><br><span class="line">		desc-&gt;addr = (<span class="keyword">uint64_t</span>)addrs[i];</span><br><span class="line">		pkt = xsk_umem__get_data(umem-&gt;mz-&gt;addr,</span><br><span class="line">					 desc-&gt;addr);</span><br><span class="line">		rte_memcpy(pkt, rte_pktmbuf_mtod(mbuf, <span class="keyword">void</span> *), desc-&gt;len);</span><br><span class="line">		tx_bytes += mbuf-&gt;pkt_len;</span><br><span class="line">		rte_pktmbuf_free(mbuf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Update tx ring producer index. */</span></span><br><span class="line">	xsk_ring_prod__submit(&amp;txq-&gt;tx, nb_pkts);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/* Step 5: Kick XDP. */</span></span><br><span class="line">	kick_tx(txq);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发包流程中各步骤如下：</p>
<ul>
<li>Step 1：从<code>completion ring</code>中检查是否有已经发包完毕的<code>umem</code>，如果有，则将其入队<code>buf_ring</code>，以供下一次发包/收包使用。</li>
<li>Step 2：检查<code>tx ring</code>空闲元素数量是否满足本次发包，如果不足的话，通过<code>kick_tx</code>的方式让内核<code>XDP</code>再发包，以释放一些可用<code>tx ring</code>，同时将上一步出队的<code>buf_ring</code>中的<code>umem</code>再入队。</li>
<li>Step 3：将<code>mbuf</code>拷贝到<code>tx ring</code>中对应的<code>umem</code>完成发包。</li>
<li>Step 4：更新<code>tx ring</code>的producer。</li>
<li>Step 5：调用<code>kick_tx</code>通知内核<code>XDP</code>有报文待发送。之前提到了<code>AF_XDP</code>的发包过程还是有<code>send</code>调用的，原因就在这里，更新了<code>tx ring</code>后通过<code>send</code>通知内核。收包流程没有<code>recv</code>调用，因为收包流程是轮询的，不需要收到来自内核<code>XDP</code>的通知。</li>
</ul>
<p>这里的<code>kick_tx</code>实际上就是调用<code>xsk</code>对应的<code>sendmsg</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kick_tx</span><span class="params">(struct pkt_tx_queue *txq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xsk_umem_info</span> *<span class="title">umem</span> =</span> txq-&gt;umem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(XDP_USE_NEED_WAKEUP)</span></span><br><span class="line">	<span class="keyword">if</span> (xsk_ring_prod__needs_wakeup(&amp;txq-&gt;tx))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">while</span> (send(xsk_socket__fd(txq-&gt;<span class="built_in">pair</span>-&gt;xsk), <span class="literal">NULL</span>,</span><br><span class="line">			    <span class="number">0</span>, MSG_DONTWAIT) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* some thing unexpected */</span></span><br><span class="line">			<span class="keyword">if</span> (errno != EBUSY &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* pull from completion queue to leave more space */</span></span><br><span class="line">			<span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">				pull_umem_cq(umem, ETH_AF_XDP_TX_BATCH_SIZE);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XDP_UMEM_UNALIGNED_CHUNK_FLAG</span></span><br><span class="line">	pull_umem_cq(umem, ETH_AF_XDP_TX_BATCH_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>xsk</code>的代码中，以<code>xsk_generic_xmit</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_generic_xmit</span><span class="params">(struct sock *sk, struct msghdr *m,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">size_t</span> total_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">		skb = sock_alloc_send_skb(sk, len, <span class="number">1</span>, &amp;err);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb)) &#123;</span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skb_put(skb, len);</span><br><span class="line">		addr = desc.addr;</span><br><span class="line">		buffer = xdp_umem_get_data(xs-&gt;umem, addr);</span><br><span class="line">		err = skb_store_bits(skb, <span class="number">0</span>, buffer, len);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(err) || xskq_reserve_addr(xs-&gt;umem-&gt;cq)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skb-&gt;dev = xs-&gt;dev;</span><br><span class="line">		skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">		skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line">		skb_shinfo(skb)-&gt;destructor_arg = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)addr;</span><br><span class="line">		skb-&gt;destructor = xsk_destruct_skb;</span><br><span class="line"></span><br><span class="line">		err = dev_direct_xmit(skb, xs-&gt;queue_id);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其逻辑就是从<code>tx_ring</code>中获取报文，构造<code>skb</code>，再调用<code>dev_direct_xmit</code>最终通过网卡驱动的发包函数发送出去。</p>
<p>可以看到整个发包流程，是和<code>XDP</code>程序毫无关系的，这也是为什么很多地方会说<code>XDP</code>只工作于收包路径。<code>AF_XDP</code>的发包能力是利用了<code>umem</code>实现的，<code>AF_XDP</code>将收发包功能封装整合，最终向上层提供了一种协议族。</p>
<h3 id="Comparison-with-virtio-ring"><a href="#Comparison-with-virtio-ring" class="headerlink" title="Comparison with virtio ring"></a>Comparison with virtio ring</h3><p>ring这块的话和<code>virtio</code>还是有一定的相似性的，相同的地方在于前后端都是各通过一个ring来通知对端本端的处理进度，以及通过相对的ring来获取对端的处理进度，ring中都是存放了真实描述符（<code>umem</code>/<code>desc ring</code>）的索引。不同的地方在于<code>virtio</code>对于收发包队列，各有一个<code>desc ring</code>用来存储<code>desc</code>。<code>desc ring</code>对应到<code>XDP</code>就是<code>umem</code>，然而所有的收发包队列使用同一个<code>umem</code>。</p>
<h2 id="eBPF-map-in-AF-XDP"><a href="#eBPF-map-in-AF-XDP" class="headerlink" title="eBPF map in AF_XDP"></a>eBPF map in AF_XDP</h2><p><code>eBPF</code>程序可以通过<code>BPF_MAP</code>和用户态程序进行运行时的数据交换。<code>BPF_MAP</code>支持的类型定义在枚举类型<code>bpf_map_type</code>中。对<code>XDP</code>而言，每一个<code>xsk</code>创建时，都会创建一个<code>BPF_MAP_TYPE_XSKMAP</code>类型的<code>BPF_MAP</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xsk_create_bpf_maps</span><span class="params">(struct xsk_socket *xsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max_queues;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">	max_queues = xsk_get_max_queues(xsk);</span><br><span class="line">	<span class="keyword">if</span> (max_queues &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> max_queues;</span><br><span class="line"></span><br><span class="line">	fd = bpf_create_map_name(BPF_MAP_TYPE_XSKMAP, <span class="string">&quot;xsks_map&quot;</span>,</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), max_queues, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">	xsk-&gt;xsks_map_fd = fd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的<code>BPF_MAP</code>名称都固定为<code>xsks_map</code>，<code>key_size</code>和<code>value_size</code>都为<code>sizeof(int)</code>，因为这里实际逻辑上的key为<code>queue_id</code>，而value为<code>xsk-&gt;fd</code>，其数据大小都是<code>int</code>。该<code>BPF_MAP</code>的意义在于指导<code>XDP</code>程序，在key对应的queue上收到报文后，将报文重定向到value对应的<code>xsk</code>。</p>
<p>这里要稍微说一下<code>BPF_MAP</code>的创建，<code>libbpf</code>封装的接口<code>bpf_create_map_name</code>最终使用<code>BPF_MAP_CREATE</code>系统调用来创建对应的<code>BPF_MAP</code>，从上述传参可以看到，并没有设备或<code>xsk</code>的相关信息传入，可以想到，所有的<code>BPF_MAP</code>都属于一个统一的namespace，创建使用都依据最终返回的fd进行，只要能够获取fd，就可以访问。所以<code>BPF_MAP</code>本身不和设备、<code>xsk</code>或特定资源绑定，而是由创建<code>BPF_MAP</code>的调用者保存创建后的fd以便于后续的访问和管理。对<code>AF_XDP</code>而言，保存在了<code>xsk-&gt;xsks_map_fd</code>。</p>
<p>注意这里所有的<code>xsk</code>对应的<code>BPF_MAP</code>的名字都相同，但是每一个<code>xsk</code>唯一对应一个<code>xsks_map_fd</code>、<code>xsk-&gt;fd</code>和<code>prog_fd</code>，并且都保存在<code>xsk</code>结构体中。这里要和<code>XDP</code>程序attach的流程结合起来看，一个设备对应一个<code>XDP</code>程序和<code>BPF_MAP</code>，但一个<code>XDP</code>程序和<code>BPF_MAP</code>可能对应多个<code>xsk</code>。当对同一个设备的不同队列创建多个<code>xsk</code>时，实际上是通过在<code>BPF_MAP</code>中增加<code>queue_id</code>和<code>xsk-&gt;fd</code>的映射。</p>
<p>对<code>AF_XDP</code>而言，在后续收包流程中执行<code>XDP</code>程序时，从<code>BPF_MAP</code>中查找到对应的<code>xsk</code>，并将报文拷贝到<code>xsk</code>对应的<code>umem</code>中。所以<code>AF_XDP</code>的<code>BPF_MAP</code>实现了<code>queue_id</code>和<code>xsk-&gt;fd</code>的映射，用于指导<code>XDP</code>程序进行重定向，而实现内核态与用户态之间进行数据交互的机制是<code>umem</code>。</p>
<h2 id="Does-XDP-support-offload"><a href="#Does-XDP-support-offload" class="headerlink" title="Does XDP support offload?"></a>Does XDP support offload?</h2><p>内核协议栈实现了很多卸载功能，如<code>GRO</code>/<code>GSO</code>，在分片场景能极大提升性能，那<code>XDP</code>是否支持这些卸载能力呢？</p>
<h3 id="GRO-LRO-with-XDP"><a href="#GRO-LRO-with-XDP" class="headerlink" title="GRO/LRO with XDP?"></a>GRO/LRO with XDP?</h3><p>首先看<code>GRO</code>，也就是接收方向，以hook点最晚的<code>SKB MODE</code>来说，其调用路径为：<code>napi_gro_complete</code>-&gt;<code>netif_receive_skb_internal</code>-&gt;<code>__netif_receive_skb</code>-&gt;<code>__netif_receive_skb_core</code>-&gt;<code>do_xdp_generic</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;generic_xdp_needed_key)) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret2;</span><br><span class="line"></span><br><span class="line">		preempt_disable();</span><br><span class="line">		ret2 = do_xdp_generic(rcu_dereference(skb-&gt;dev-&gt;xdp_prog), skb);</span><br><span class="line">		preempt_enable();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret2 != XDP_PASS)</span><br><span class="line">			<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">		skb_reset_mac_len(skb);</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从调用路径可以知道，在<code>skb</code>接收的早期，<code>GRO</code>完成之前就已经执行<code>XDP</code>程序了。所以，除非<code>XDP</code>程序不对该报文进行处理，也就是<code>XDP</code>程序返回了<code>XDP_PASS</code>，报文才可能接着进入<code>GRO</code>处理流程。也就是说，<code>XDP</code>处理的报文，是未经<code>GRO</code>处理的，对<code>AF_XDP</code>而言，就意味着不支持<code>GRO</code>。</p>
<p>那有没有可能支持<code>LRO</code>呢？毕竟<code>LRO</code>不需要进入协议栈就可以完成。假设支持<code>LRO</code>，则<code>xsk</code>就需要处理可能出现的巨帧。从上面收发包流程可以知道，报文是由<code>umem</code>承载的，而<code>umem</code>最大支持<code>PAGE_SIZE</code>的帧大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xdp_umem_reg</span><span class="params">(struct xdp_umem *umem, struct xdp_umem_reg *mr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (chunk_size &lt; XDP_UMEM_MIN_CHUNK_SIZE || chunk_size &gt; PAGE_SIZE) &#123;</span><br><span class="line">		<span class="comment">/* Strictly speaking we could support this, if:</span></span><br><span class="line"><span class="comment">		 * - huge pages, or*</span></span><br><span class="line"><span class="comment">		 * - using an IOMMU, or</span></span><br><span class="line"><span class="comment">		 * - making sure the memory area is consecutive</span></span><br><span class="line"><span class="comment">		 * but for now, we simply say &quot;computer says no&quot;.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而普通页大小在X86架构下通常为4K，也就是通常<code>XDP</code>只支持最大4K的帧大小，这个大小不足以用于<code>LRO</code>。</p>
<p>关于<code>LRO</code>，也可以参考下<code>virtio_net</code>中的<code>virtnet_xdp_set</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">virtnet_xdp_set</span><span class="params">(struct net_device *dev, struct bpf_prog *prog,</span></span></span><br><span class="line"><span class="params"><span class="function">			   struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (!virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS)</span><br><span class="line">	    &amp;&amp; (virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_TSO4) ||</span><br><span class="line">	        virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_TSO6) ||</span><br><span class="line">	        virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_ECN) ||</span><br><span class="line">		virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_GUEST_UFO))) &#123;</span><br><span class="line">		NL_SET_ERR_MSG_MOD(extack, <span class="string">&quot;Can&#x27;t set XDP while host is implementing LRO, disable LRO first&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>virtio_net</code>开启了<code>LRO</code>时，也是不支持attach的，原因也是上面提的，目前<code>XDP</code>尚不支持<code>LRO</code>，后续理论上可以支持。</p>
<h3 id="GSO-TSO-with-XDP"><a href="#GSO-TSO-with-XDP" class="headerlink" title="GSO/TSO with XDP?"></a>GSO/TSO with XDP?</h3><p>再看发包方向<code>GSO</code>，在上面发包流程的分析中已经描述了<code>AF_XDP</code>的发包原理：直接将从<code>umem</code>获取到的原始报文，调用<code>dev_direct_xmit</code>直接通过网卡驱动的发包函数发出，所以很明显，<code>XDP</code>也不支持<code>GSO</code>。</p>
<p>那是否支持<code>TSO</code>呢？发包流程中调用驱动的发包函数，报文是由<code>skb</code>承载的，而构造<code>skb</code>的流程中，并没有设置<code>skb-&gt;gso_size</code>等卸载相关的字段（参考<code>xsk_generic_xmit</code>），所以<code>XDP</code>目前尚不支持<code>TSO</code>，后续理论上可以支持。</p>
<h1 id="libxdp-amp-libbpf"><a href="#libxdp-amp-libbpf" class="headerlink" title="libxdp &amp; libbpf"></a>libxdp &amp; libbpf</h1><p>上面已经介绍过<code>PMD_AF_XDP</code>使用了<code>libbpf</code><a target="_blank" rel="noopener" href="https://github.com/libbpf/libbpf">^1</a>提供的<code>xsk</code>相关接口了，但上述代码基于4.18版本的内核，在这之后<code>libbpf</code>进行了很多改动，其中包括使用一个新的库<code>libxdp</code><a target="_blank" rel="noopener" href="https://github.com/xdp-project/xdp-tools">^2</a>来维护<code>XDP</code>相关的接口。</p>
<p><code>XDP</code>应用对不同版本的<code>libbpf</code>可以参考<code>PMD_AF_XDP</code>的处理，根据不同版本引用不同的头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTE_NET_AF_XDP_LIBXDP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdp/xsk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/xsk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/" rel="tag">Other</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Linux-kernel-checksum-calculation-and-skb-ip-summed"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/21/Linux-kernel-checksum-calculation-and-skb-ip-summed/"
    >Linux kernel checksum calculation and skb-&gt;ip_summed</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/21/Linux-kernel-checksum-calculation-and-skb-ip-summed/" class="article-date">
  <time datetime="2023-01-21T14:25:40.000Z" itemprop="datePublished">2023-01-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>最近在看内核相关的checksum代码，起因是往虚拟机virtio-net发包时，想通过<code>VIRTIO_NET_HDR_F_DATA_VALID</code>这个flag减少GuestOS的校验和计算开销。关于这个flag，以及<code>virtio_net_hdr</code>这个结构体相关的内容，值得单独说明，所以在这里只是简单提一下。</p>
<p>最初的疑问是<code>VIRTIO_NET_HDR_F_DATA_VALID</code>到底对应几层校验和？</p>
<p>从其定义（DPDK 19.11）可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the first element of the scatter-gather list.  If you don&#x27;t</span></span><br><span class="line"><span class="comment"> * specify GSO or CSUM features, you can simply ignore the header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_hdr</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_F_NEEDS_CSUM 1    <span class="comment">/**&lt; Use csum_start,csum_offset*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_F_DATA_VALID 2    <span class="comment">/**&lt; Checksum is valid */</span></span></span><br><span class="line">	<span class="keyword">uint8_t</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_NONE     0    <span class="comment">/**&lt; Not a GSO frame */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_TCPV4    1    <span class="comment">/**&lt; GSO frame, IPv4 TCP (TSO) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_UDP      3    <span class="comment">/**&lt; GSO frame, IPv4 UDP (UFO) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_TCPV6    4    <span class="comment">/**&lt; GSO frame, IPv6 TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIRTIO_NET_HDR_GSO_ECN      0x80 <span class="comment">/**&lt; TCP has ECN set */</span></span></span><br><span class="line">	<span class="keyword">uint8_t</span> gso_type;</span><br><span class="line">	<span class="keyword">uint16_t</span> hdr_len;     <span class="comment">/**&lt; Ethernet + IP + tcp/udp hdrs */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> gso_size;    <span class="comment">/**&lt; Bytes to append to hdr_len per frame */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> csum_start;  <span class="comment">/**&lt; Position to start checksumming from */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> csum_offset; <span class="comment">/**&lt; Offset after that to place checksum */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>virtio_net_hdr</code>包含了报文的<code>csum_start</code>和<code>csum_offset</code>，且包含了gso相关字段，从这里可以猜测，它就是描述L4的卸载相关属性的。</p>
<p>为此再接着看<code>VIRTIO_NET_HDR_F_DATA_VALID</code>相关的处理逻辑。</p>
<p>首先看内核（4.18）相关实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">virtio_net_hdr_from_skb</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">					  struct virtio_net_hdr *hdr,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> little_endian,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> has_data_valid,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">int</span> vlan_hlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL) &#123;</span><br><span class="line">		hdr-&gt;flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;</span><br><span class="line">		hdr-&gt;csum_start = __cpu_to_virtio16(little_endian,</span><br><span class="line">			skb_checksum_start_offset(skb) + vlan_hlen);</span><br><span class="line">		hdr-&gt;csum_offset = __cpu_to_virtio16(little_endian,</span><br><span class="line">				skb-&gt;csum_offset);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_data_valid &amp;&amp;</span><br><span class="line">		   skb-&gt;ip_summed == CHECKSUM_UNNECESSARY) &#123;</span><br><span class="line">		hdr-&gt;flags = VIRTIO_NET_HDR_F_DATA_VALID;</span><br><span class="line">	&#125; <span class="comment">/* else everything is zero */</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive_buf</span><span class="params">(struct virtnet_info *vi, struct receive_queue *rq,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">void</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> len, <span class="keyword">void</span> **ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">int</span> *xdp_xmit, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (hdr-&gt;hdr.flags &amp; VIRTIO_NET_HDR_F_DATA_VALID)</span><br><span class="line">		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看DPDK pmd_virtio中的相关实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Optionally fill offload information in structure */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">virtio_rx_offload</span><span class="params">(struct rte_mbuf *m, struct virtio_net_hdr *hdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;flags &amp; VIRTIO_NET_HDR_F_DATA_VALID &amp;&amp; l4_supported) &#123;</span><br><span class="line">		m-&gt;ol_flags |= PKT_RX_L4_CKSUM_GOOD;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从DPDK的代码中可以直观地确认，当PMD收到有<code>VIRTIO_NET_HDR_F_DATA_VALID</code>置位的报文时，为mbuf置上<code>PKT_RX_L4_CKSUM_GOOD</code>以标识L4校验和正确；内核对应的情况是<code>skb-&gt;ip_summed == CHECKSUM_UNNECESSARY</code>。</p>
<p>这里就是比较疑惑的地方了：既然从结构体本身成员，以及DPDK代码中大致确认，<code>VIRTIO_NET_HDR_F_DATA_VALID</code>是描述的L4校验和状态，为何内核中的代码对应的是<code>skb-&gt;ip_summed</code>这个成员呢？从其命名上看应该描述的是L3/IP的校验和才对呀？</p>
<h1 id="skb-gt-ip-summed"><a href="#skb-gt-ip-summed" class="headerlink" title="skb-&gt;ip_summed"></a>skb-&gt;ip_summed</h1><p>首先关注这个令人疑惑的成员，在<code>skbuff.h</code>中，有大段的注释对其进行了详细的描述。</p>
<p>下面对接收方向进行说明，<code>skb-&gt;ip_summed</code>可能的取值有<code>CHECKSUM_NONE</code>、<code>CHECKSUM_UNNECESSARY</code>、<code>CHECKSUM_COMPLETE</code>和<code>CHECKSUM_PARTIAL</code>。</p>
<h2 id="CHECKSUM-NONE"><a href="#CHECKSUM-NONE" class="headerlink" title="CHECKSUM_NONE"></a>CHECKSUM_NONE</h2><p>这种情况很好理解，注释上解释的也比较清楚，当硬件没有对报文进行校验（如硬件不支持校验特性）时，会将<code>skb-&gt;ip_summed</code>置为<code>CHECKSUM_NONE</code>，并且此时的<code>skb-&gt;csum</code>也是无意义的。软件针对此种场景需要完整计算校验和。</p>
<h2 id="CHECKSUM-COMPLETE"><a href="#CHECKSUM-COMPLETE" class="headerlink" title="CHECKSUM_COMPLETE"></a>CHECKSUM_COMPLETE</h2><p>这是最通用的一种场景，硬件计算了报文从L4头部开始的数据的1的补码和并且保存到了<code>skb-&gt;csum</code>。</p>
<p>需要注意的是，硬件不需要对L3/L4进行协议解析即可做到这一点。因为整个IP协议族（IPv4、TCP、UDP等）的校验和计算方式都是一样的，即1的反码和的16bit 1的补码，所以这种情况下硬件只需从L4头部开始计算剩余的1的补码和即可。</p>
<p>在软件计算特定的L4校验和时，可以通过硬件计算的完整结果<code>skb-&gt;csum</code>，进行进一步计算获得最终结果。如：TCP通过<code>skb-&gt;csum</code>加上伪校验和来计算TCP校验和。</p>
<h2 id="CHECKSUM-UNNECESSARY"><a href="#CHECKSUM-UNNECESSARY" class="headerlink" title="CHECKSUM_UNNECESSARY"></a>CHECKSUM_UNNECESSARY</h2><p>这种场景下，硬件已经确认了特定类型（TCP、UDP、GRE、SCP和FCoE）的L4协议的校验和正确，软件无需再进行校验和的验证。</p>
<p>需要注意的是，尽管已经确定了特定类型的L4校验和正确，<code>skb-&gt;csum</code>还是未定义的，且后续流程也不应该修改<code>skb-&gt;csum</code>。</p>
<h2 id="CHECKSUM-PARTIAL"><a href="#CHECKSUM-PARTIAL" class="headerlink" title="CHECKSUM_PARTIAL"></a>CHECKSUM_PARTIAL</h2><p>这种场景硬件计算从<code>skb-&gt;csum_start</code>开始的数据的校验和，并保存到<code>skb-&gt;csum_start + skb-&gt;csum_offset</code>的位置上。</p>
<h2 id="Why-is-it-named-as-ip-summed"><a href="#Why-is-it-named-as-ip-summed" class="headerlink" title="Why is it named as ip_summed?"></a>Why is it named as ip_summed?</h2><p>从上面的取值场景可以发现，<code>skb-&gt;ip_summed</code>描述的是L4的校验和状态，这和对DPDK代码，以及<code>virtio_net_hdr</code>的分析的结论是一致的，但是为什么用了一个这么令人费解的命名呢？</p>
<p>为此我向Linux netdev的mailing list发送了一封邮件询问这件事，有幸得到了大佬的解答，大意是：<strong>虽然命名确实很令人费解，但<code>skb-&gt;ip_summed</code>描述的是L4的校验和状态。</strong>主要原因是整个IP协议族的校验和计算方式都是一样的，所以命名里的ip不是专指IP协议，而是指IP协议族使用的校验和计算方式。其实不仅仅是<code>ip_summed</code>，内核里应该也有一些地方的ip并不是特指IPv4协议，如<code>ip_compute_csum </code>。</p>
<p>同时关于L3/IP校验和，由于L3/IP校验和只需要计算首部，计算量不大，并且在报文接收，解析报文首部时，首部的内容已经被缓存到cache中去了，所以软件计算的开销会很小，由内核进行L3/IP的校验和计算。</p>
<p>完整邮件见：<a target="_blank" rel="noopener" href="https://www.spinics.net/lists/netdev/msg854092.html">Confused about ip_summed member in sk_buff</a>。</p>
<h1 id="How-does-kernel-calculate-the-checksum"><a href="#How-does-kernel-calculate-the-checksum" class="headerlink" title="How does kernel calculate the checksum?"></a>How does kernel calculate the checksum?</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Header Checksum:  16 bits</span><br><span class="line"></span><br><span class="line">  A checksum on the header only.  Since some header fields change</span><br><span class="line">  (e.g., time to live), this is recomputed and verified at each point</span><br><span class="line">  that the internet header is processed.</span><br><span class="line"></span><br><span class="line">  The checksum algorithm is:</span><br><span class="line"></span><br><span class="line">    The checksum field is the 16 bit one&#x27;s complement of the one&#x27;s</span><br><span class="line">    complement sum of all 16 bit words in the header.  For purposes of</span><br><span class="line">    computing the checksum, the value of the checksum field is zero.</span><br><span class="line">														——RFC791</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从IPv4校验和的定义可以知道，它的值就是首部所有16bit字的1的补码和的1的补码，计算时，校验和字段以0计算。</p>
<p>以如下报文为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">16:31:34.953256 00:50:56:97:d1:f3 &gt; a8:0c:ca:5f:8c:5c, ethertype IPv4 (0x0800), length 32174: (tos 0x0, ttl 64, id 5604, offset 0, flags [DF], proto TCP (6), length 32160)</span><br><span class="line">    10.103.240.223.22 &gt; 172.23.9.13.12036: Flags [.], cksum 0x2dfe (incorrect -&gt; 0x18ca), seq 74390940:74423060, ack 4837, win 64512, length 32120</span><br><span class="line">        0x0000:  a80c ca5f 8c5c 0050 5697 d1f3 0800 4500  ..._.\.PV.....E.</span><br><span class="line">        0x0010:  7da0 15e4 4000 4006 f708 0a67 f0df ac17  &#125;...@.@....g....</span><br><span class="line">        0x0020:  090d 0016 2f04 fb22 4704 23c3 2b20 5010  ..../..&quot;G.#.+.P.</span><br><span class="line">        0x0030:  fc00 2dfe 0000 33cd 52ed 85f9 888f b0aa  ..-...3.R.......</span><br><span class="line">        0x0040:  7d4e 3cd0 db58 27eb bb87 a09e ea81 c61a  &#125;N&lt;..X&#x27;.........</span><br><span class="line">        0x0050:  9119 23bd 0fa0 dd44 cae2 e84f 4c31 0241  ..#....D...OL1.A</span><br><span class="line">        0x0060:  54ee 860e 3feb 6d4e 1bd1 2ef5 faeb e2e4  T...?.mN........</span><br><span class="line">        0x0070:  6421 7c4d 3ec6 1e5f 0bd9 88ea 4776 3a5d  d!|M&gt;.._....Gv:]</span><br><span class="line">        0x0080:  0a05 abf7 fbd4 69f6 c1d9 74c9 fefc 2fc7  ......i...t.../.</span><br><span class="line">        0x0090:  c8b0 b447 ccb9 6148 9480 d78a c3e9 8e95  ...G..aH........</span><br><span class="line">        0x00a0:  1d04 c8fd 66ab 993e ecf3 7ceb 5443 adfb  ....f..&gt;..|.TC..</span><br><span class="line">        0x00b0:  a6e9 1e55 49d2 b86e 238d bac6 24aa 1b27  ...UI..n#...$..&#x27;</span><br></pre></td></tr></table></figure>

<p>IPv4首部为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4500 7da0 15e4 4000 4006 f708 0a67 f0df ac17 090d</span><br></pre></td></tr></table></figure>

<p>其中校验和为：<code>f708</code>。</p>
<p>下面来实际算一遍。根据校验和定义，先将校验和字段置零，所以IPv4首部在未计算校验和时为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4500 7da0 15e4 4000 4006 0000 0a67 f0df ac17 090d</span><br></pre></td></tr></table></figure>

<p>先将首部所有16bit字相加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(32bit integer) = 0x4500 + 0x7da0 + 0x15e4 + 0x4000 + 0x4006 + 0x0000 + 0x0a67 + 0xf0df + 0xac17 + 0x090d</span><br><span class="line">sum(32bit integer) = 0x308f4</span><br></pre></td></tr></table></figure>

<p>再根据1的补码的加法原则，将进位加回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(one&#x27;s complement) = 0x08f4 + 0x3 (sum + carry)</span><br><span class="line">sum(one&#x27;s complement) = 0x08f7</span><br></pre></td></tr></table></figure>

<p>再对和求16bit 1的补码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csum = 16bit one’s complement(0x08f7) = 0xf708</span><br></pre></td></tr></table></figure>

<p>可以看到，计算出的结果正好就和报文内原始的值相同，证明报文内的校验和字段是正确的。</p>
<p>当然还有另一种验证方式，在计算16bit 1的补码和时，将校验和的值也加入计算，然后判断最终值是否为0xffff（16bit 1的补码中的-0）。</p>
<p>再看看内核中通用的、非内联汇编版本的IPv4校验和实现<code>ip_fast_csum</code>，调用路径为<code>ip_rcv</code>-&gt;<code>ip_fast_csum</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __sum16 <span class="title">ip_fast_csum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *iph, <span class="keyword">unsigned</span> <span class="keyword">int</span> ihl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *word = iph;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *stop = word + ihl;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> csum;</span><br><span class="line">	<span class="keyword">int</span> carry;</span><br><span class="line"></span><br><span class="line">	csum = word[<span class="number">0</span>];</span><br><span class="line">	csum += word[<span class="number">1</span>];</span><br><span class="line">	carry = (csum &lt; word[<span class="number">1</span>]);</span><br><span class="line">	csum += carry;</span><br><span class="line"></span><br><span class="line">	csum += word[<span class="number">2</span>];</span><br><span class="line">	carry = (csum &lt; word[<span class="number">2</span>]);</span><br><span class="line">	csum += carry;</span><br><span class="line"></span><br><span class="line">	csum += word[<span class="number">3</span>];</span><br><span class="line">	carry = (csum &lt; word[<span class="number">3</span>]);</span><br><span class="line">	csum += carry;</span><br><span class="line"></span><br><span class="line">	word += <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		csum += *word;</span><br><span class="line">		carry = (csum &lt; *word);</span><br><span class="line">		csum += carry;</span><br><span class="line">		word++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (word != stop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> csum_fold(csum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这个函数内，单次计算数据单位为32bit，并没有完全按照RFC的定义进行16bit累加，原因是32bit累加性能更好。</p>
<p>可以很容易想到，16bit累加的结果在32bit累加中是等效的，当低16bit累加发生进位后，会加到高16bit上去，高16bit再发生进位的话，再加回低16bit。这里可以看到代码里通过累加和与加数之间的大小比较，来确定是否发生了进位，如果进位加回累加和。</p>
<p>还有一点需要注意的是，IPv4协议首部是可变长度，最短20字节，为什么这个版本的实现中，先计算了前16字节，而不是20字节呢？这一点我个人的理解是16字节是2的幂，考虑指令、cache等因素下，应该性能会更好。</p>
<p>累加和计算完成后，调用<code>csum_fold</code>对结果进行折叠取反：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __sum16 <span class="title">csum_fold</span><span class="params">(__wsum csum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 sum = (__force u32)csum;</span><br><span class="line">	sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> (__force __sum16)~sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为前面计算的累加和是32bit的，根据1的补码加法定义，高低16bit需要再加在一起，才是最后的结果。从形式上看，就像对累加和进行了折叠（fold）一样。折叠完了以后，就是完整了1的补码和了，再对结果求16bit 1的补码（取反），就得到了最终的校验和。这也是为什么很多地方把校验和计算的过程描述成“累加取反”，但光从这个描述很难和原始定义对应上。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Checksum:  16 bits</span><br><span class="line"></span><br><span class="line">  The checksum field is the 16 bit one&#x27;s complement of the one&#x27;s</span><br><span class="line">  complement sum of all 16 bit words in the header and text.  If a</span><br><span class="line">  segment contains an odd number of header and text octets to be</span><br><span class="line">  checksummed, the last octet is padded on the right with zeros to</span><br><span class="line">  form a 16 bit word for checksum purposes.  The pad is not</span><br><span class="line">  transmitted as part of the segment.  While computing the checksum,</span><br><span class="line">  the checksum field itself is replaced with zeros.</span><br><span class="line"></span><br><span class="line">  The checksum also covers a 96 bit pseudo header conceptually </span><br><span class="line">  prefixed to the TCP header.  This pseudo header contains the Source</span><br><span class="line">  Address, the Destination Address, the Protocol, and TCP length.</span><br><span class="line">  This gives the TCP protection against misrouted segments.  This</span><br><span class="line">  information is carried in the Internet Protocol and is transferred</span><br><span class="line">  across the TCP/Network interface in the arguments or results of</span><br><span class="line">  calls by the TCP on the IP.</span><br><span class="line"></span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line">                   |           Source Address          |</span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line">                   |         Destination Address       |</span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line">                   |  zero  |  PTCL  |    TCP Length   |</span><br><span class="line">                   +--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">    The TCP Length is the TCP header length plus the data length in</span><br><span class="line">    octets (this is not an explicitly transmitted quantity, but is</span><br><span class="line">    computed), and it does not count the 12 octets of the pseudo</span><br><span class="line">    header.</span><br><span class="line">                                                           --RFC793</span><br></pre></td></tr></table></figure>
</blockquote>
<p>和IPv4相比，TCP校验和除了还要计算payload（text）以外，还加上了伪头部（pseudo header），用于验证IPv4的信息是否匹配。伪头部是一个抽象的头部，只是为了在四层头部额外保存三层信息，一定程度上用于确认三层正确性，并不存在于实际报文中。同时，计算校验和时如果总数据不能整除16bit，则在末尾补0计算，这部分0同样只用来计算，也不存在于实际报文中。</p>
<p>以如下报文为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">14:12:51.140861 a8:0c:ca:5f:8c:5c &gt; 00:50:56:97:d1:f3, ethertype IPv4 (0x0800), length 106: (tos 0x0, ttl 125, id 4094, offset 0, flags [DF], proto TCP (6), length 92)</span><br><span class="line">    172.23.9.13.2774 &gt; 10.103.240.223.22: Flags [P.], cksum 0xccb7 (correct), seq 0:52, ack 46045, win 32544, length 52</span><br><span class="line">        0x0000:  0050 5697 d1f3 a80c ca5f 8c5c 0800 4500  .PV......_.\..E.</span><br><span class="line">        0x0010:  005c 0ffe 4000 7d06 3d33 ac17 090d 0a67  .\..@.&#125;.=3.....g</span><br><span class="line">        0x0020:  f0df 0ad6 0016 6749 d568 1ba4 a329 5018  ......gI.h...)P.</span><br><span class="line">        0x0030:  7f20 ccb7 0000 0000 0010 f43e bdd1 e11e  ...........&gt;....</span><br><span class="line">        0x0040:  e612 f35a d406 61c9 6ed5 5f47 a7e5 5d56  ...Z..a.n._G..]V</span><br><span class="line">        0x0050:  9906 ce6e 15ac af67 e2a6 ffc8 8724 cdff  ...n...g.....$..</span><br><span class="line">        0x0060:  3d3f b304 5838 1883 71f6                 =?..X8..q.</span><br></pre></td></tr></table></figure>

<p>伪头部（src addr + dst addr + zero + protocol + l4 length）为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac17 090d 0a67 f0df 0000 0006 0000 0048</span><br></pre></td></tr></table></figure>

<p>TCP首部为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0ad6 0016 6749 d568 1ba4 a329 5018 7f20 ccb7 0000</span><br></pre></td></tr></table></figure>

<p>其中校验和为：<code>ccb7</code>，计算校验和时将其置0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0ad6 0016 6749 d568 1ba4 a329 5018 7f20 0000 0000</span><br></pre></td></tr></table></figure>

<p>payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0010 f43e bdd1 e11e e612 f35a d406 61c9 6ed5 5f47 a7e5 5d56 9906 ce6e 15ac af67 e2a6 ffc8 8724 cdff 3d3f b304 5838 1883 71f6</span><br></pre></td></tr></table></figure>

<p>将所有16bit字相加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(32bit integer) = 0xac17 + 0x090d + 0x0a67 + 0xf0df + 0x0000 + 0x0006 + 0x0000 + 0x0048 + 0x0ad6 + 0x0016 + 0x6749 + 0xd568 + 0x1ba4 + 0xa329 + 0x5018 + 0x7f20 + 0x0000 + 0x0000 + 0x0000 + 0x0010 + 0xf43e + 0xbdd1 + 0xe11e + 0xe612 + 0xf35a + 0xd406 + 0x61c9 + 0x6ed5 + 0x5f47 + 0xa7e5 + 0x5d56 + 0x9906 + 0xce6e + 0x15ac + 0xaf67 + 0xe2a6 + 0xffc8 + 0x8724 + 0xcdff + 0x3d3f + 0xb304 + 0x5838 + 0x1883 + 0x71f6</span><br><span class="line">sum(32bit integer) = 0x133335</span><br></pre></td></tr></table></figure>

<p>再根据1的补码的加法原则，将进位加回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(one&#x27;s complement) = 0x3335 + 0x13 (sum + carry)</span><br><span class="line">sum(one&#x27;s complement) = 0x3348</span><br></pre></td></tr></table></figure>

<p>再对和求16bit 1的补码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csum = 16bit one’s complement(0x3348) = 0xccb7</span><br></pre></td></tr></table></figure>

<p>可以看到，计算出的结果正好就和TCP首部的值相同。</p>
<p>内核中使用<code>csum_tcpudp_nofold</code>计算TCP的伪头部和，调用路径：<code>tcp_v4_rcv</code>-&gt;<code>skb_checksum_init</code>-&gt;<code>__skb_checksum_validate</code>-&gt;<code>inet_compute_pseudo</code>-&gt;<code>csum_tcpudp_nofold</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">from64to32</span><span class="params">(u64 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* add up 32-bit and 32-bit for 32+c bit */</span></span><br><span class="line">	x = (x &amp; <span class="number">0xffffffff</span>) + (x &gt;&gt; <span class="number">32</span>);</span><br><span class="line">	<span class="comment">/* add up carry.. */</span></span><br><span class="line">	x = (x &amp; <span class="number">0xffffffff</span>) + (x &gt;&gt; <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">return</span> (u32)x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__wsum <span class="title">csum_tcpudp_nofold</span><span class="params">(__be32 saddr, __be32 daddr,</span></span></span><br><span class="line"><span class="params"><span class="function">			  __u32 len, __u8 proto, __wsum sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> s = (__force u32)sum;</span><br><span class="line"></span><br><span class="line">	s += (__force u32)saddr;</span><br><span class="line">	s += (__force u32)daddr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BIG_ENDIAN</span></span><br><span class="line">	s += proto + len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	s += (proto + len) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> (__force __wsum)from64to32(s);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(csum_tcpudp_nofold);</span><br></pre></td></tr></table></figure>

<p>可以看到除了也是用32bit相加的方式以外，整体流程符合伪头部和计算的定义。还需要注意的一点是，上述调用链中，<code>csum_tcpudp_nofold</code>的参数中<code>len</code>的值为<code>skb-&gt;len</code>，<code>skb-&gt;len</code>代表当前协议层次的数据长度，当前为TCP协议处理流程，所以对应了TCP首部加TCP payload的总长；<code>sum</code>的值为0。</p>
<p>再看<code>skb_checksum_init</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform checksum validate (init). Note that this is a macro since we only</span></span><br><span class="line"><span class="comment"> * want to calculate the pseudo header which is an input function if necessary.</span></span><br><span class="line"><span class="comment"> * First we try to validate without any computation (checksum unnecessary) and</span></span><br><span class="line"><span class="comment"> * then calculate based on checksum complete calling the function to compute</span></span><br><span class="line"><span class="comment"> * pseudo header.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *   0: checksum is validated or try to in skb_checksum_complete</span></span><br><span class="line"><span class="comment"> *   non-zero: value of invalid checksum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __skb_checksum_validate(skb, proto, complete,			\</span></span><br><span class="line"><span class="meta">				zero_okay, check, compute_pseudo)	\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">	__sum16 __ret = 0;						\</span></span><br><span class="line"><span class="meta">	skb-&gt;csum_valid = 0;						\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> (__skb_checksum_validate_needed(skb, zero_okay, check))	\</span></span><br><span class="line"><span class="meta">		__ret = __skb_checksum_validate_complete(skb,		\</span></span><br><span class="line"><span class="meta">				complete, compute_pseudo(skb, proto));	\</span></span><br><span class="line"><span class="meta">	__ret;								\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> skb_checksum_init(skb, proto, compute_pseudo)			\</span></span><br><span class="line"><span class="meta">	__skb_checksum_validate(skb, proto, false, false, 0, compute_pseudo)</span></span><br></pre></td></tr></table></figure>

<p><code>skb_checksum_init</code>直接调用了<code>__skb_checksum_validate</code>，可以看到里面逻辑先将<code>skb-&gt;csum_valid</code>初始化，再调用<code>__skb_checksum_validate_needed</code>判断是否需要计算校验和，如果需要的话，再调用<code>__skb_checksum_validate_complete</code>进行具体计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">skb_csum_unnecessary</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((skb-&gt;ip_summed == CHECKSUM_UNNECESSARY) ||</span><br><span class="line">		skb-&gt;csum_valid ||</span><br><span class="line">		(skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">		 skb_checksum_start_offset(skb) &gt;= <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we need to perform checksum complete validation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true if checksum complete is needed, false otherwise</span></span><br><span class="line"><span class="comment"> * (either checksum is unnecessary or zero checksum is allowed).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> __skb_checksum_validate_needed(struct sk_buff *skb,</span><br><span class="line">						  <span class="keyword">bool</span> zero_okay,</span><br><span class="line">						  __sum16 check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb_csum_unnecessary(skb) || (zero_okay &amp;&amp; !check)) &#123;</span><br><span class="line">		skb-&gt;csum_valid = <span class="number">1</span>;</span><br><span class="line">		__skb_decr_checksum_unnecessary(skb);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__skb_checksum_validate_needed</code>中逻辑较为简单，当<code>skb_csum_unnecessary</code>返回<code>true</code>或当前校验和<code>check</code>为<code>0</code>并且为0的校验和是合法值时，将<code>skb-&gt;csum_valid</code>置1，并且调整skb中<code>CHECKSUM_UNNECESSARY</code>相关成员的值，返回<code>false</code>，否则返回<code>true</code>。</p>
<p><code>skb_csum_unnecessary</code>中则是根据<code>skb-&gt;ip_summed</code>以及其他skb的信息判断是否有必要计算校验和：</p>
<ul>
<li><code>skb-&gt;ip_summed == CHECKSUM_UNNECESSARY</code>：无需计算，和上面对<code>CHECKSUM_UNNECESSARY</code>的分析一致，这种情况下硬件已经确认校验和正确，协议栈不需要任何计算。</li>
<li><code>skb-&gt;csum_valid == 1</code>：无需计算，当前协议层次的校验和已被确认为合法值。</li>
<li><code>skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp; skb_checksum_start_offset(skb) &gt;= 0</code>：无需计算，<code>CHECKSUM_PARTIAL</code>代表部分校验和已被硬件计算，<code>skb_checksum_start_offset(skb)</code>代表<code>skb-&gt;csum_start</code>合法，即已被计算的那部分校验和是合法的。</li>
<li>其他情况：需要计算。</li>
</ul>
<p>需要计算校验和的场景，调用<code>__skb_checksum_validate_complete</code>进行计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Validate (init) checksum based on checksum complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *   0: checksum is validated or try to in skb_checksum_complete. In the latter</span></span><br><span class="line"><span class="comment"> *	case the ip_summed will not be CHECKSUM_UNNECESSARY and the pseudo</span></span><br><span class="line"><span class="comment"> *	checksum is stored in skb-&gt;csum for use in __skb_checksum_complete</span></span><br><span class="line"><span class="comment"> *   non-zero: value of invalid checksum</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __sum16 __skb_checksum_validate_complete(struct sk_buff *skb,</span><br><span class="line">						       <span class="keyword">bool</span> complete,</span><br><span class="line">						       __wsum psum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_COMPLETE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!csum_fold(csum_add(psum, skb-&gt;csum))) &#123;</span><br><span class="line">			skb-&gt;csum_valid = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skb-&gt;csum = psum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (complete || skb-&gt;len &lt;= CHECKSUM_BREAK) &#123;</span><br><span class="line">		__sum16 csum;</span><br><span class="line"></span><br><span class="line">		csum = __skb_checksum_complete(skb);</span><br><span class="line">		skb-&gt;csum_valid = !csum;</span><br><span class="line">		<span class="keyword">return</span> csum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准确来说，<code>__skb_checksum_validate_complete</code>只处理<code>CHECKSUM_COMPLETE</code>相关的场景。</p>
<p>特别地，当<code>skb-&gt;ip_summed == CHECKSUM_COMPLETE</code>时，根据前面对<code>CHECKSUM_COMPLETE</code>场景的分析，此时<code>skb-&gt;csum</code>保存的是L4开始的1的补码和，直接将<code>skb-&gt;csum</code>和<code>psum</code>累加取反即可得到TCP校验和。</p>
<p>对于特殊场景，如下面的分支中，会直接调用<code>__skb_checksum_complete</code>进行完整计算，否则只保存伪头部和，在后续流程中（如<code>tcp_v4_rcv</code>-&gt;<code>tcp_v4_do_rcv</code>-&gt;<code>tcp_checksum_complete</code>）再进行完整计算。</p>
<p><code>tcp_checksum_complete</code>最终也是调用<code>__skb_checksum_complete</code>进行计算，其中逻辑大概也是求补码和，然后取反。求补码和的地方相对比较复杂，涉及skb链的场景，就不细说了。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Checksum is the 16-bit one&#x27;s complement of the one&#x27;s complement sum of a</span><br><span class="line">pseudo header of information from the IP header, the UDP header, and the</span><br><span class="line">data,  padded  with zero octets  at the end (if  necessary)  to  make  a</span><br><span class="line">multiple of two octets.</span><br><span class="line">                                                               --RFC 768</span><br></pre></td></tr></table></figure>
</blockquote>
<p>UDP首部校验和与TCP校验和的计算方式基本一致，也需要计算伪头部，但不需要计算payload，具体流程就不展开细说了。</p>
<p>一个典型的调用链：<code>udp_rcv</code>-&gt;<code>__udp4_lib_rcv</code>-&gt;<code>udp4_csum_init</code>-&gt;<code>skb_checksum_init_zero_check</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/" rel="tag">Other</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Record-of-using-kprobe"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/21/Record-of-using-kprobe/"
    >Record of using kprobe</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/21/Record-of-using-kprobe/" class="article-date">
  <time datetime="2023-01-21T14:19:02.000Z" itemprop="datePublished">2023-01-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>之前在生产环境排查了一个TCP的ACK无法被正确接收，导致发送端一直重传，最终接收端keepalive超时后关闭连接的问题（<a target="_blank" rel="noopener" href="https://patchwork.ozlabs.org/project/netfilter-devel/patch/20220818224231.11583-1-fw@strlen.de/">[nf] netfilter: conntrack: work around exceeded receive window</a>）。排查过程中主要用到了kprobe这个动态调试手段去分析内核代码执行的情况，这里简单记录下。</p>
<h1 id="Kprobe"><a href="#Kprobe" class="headerlink" title="Kprobe"></a>Kprobe</h1><p>kprobe是一种内核的动态调试机制，可以在几乎所有内核代码上进行插桩，当执行到对应的代码时，先执行插桩函数，执行完毕后，在继续运行后续逻辑。它的实现逻辑基本上就是指令替换，将运行指令跳转到用户定义好的kprobe handler。</p>
<p>上面说了是几乎所有内核代码，有几种场景无法正常kprobe：</p>
<ul>
<li>kprobe自身相关的代码：没法嵌套kprobe自身</li>
<li>内联函数：内联函数在编译时会被展开到所有的调用处，kprobe实际上是根据符号对应的地址进行的，不能确认所有内联函数展开后的地址，这种情况需要计算内联函数的调用地址来进行kprobe</li>
<li>一些被优化后的静态函数</li>
</ul>
<p>同时kprobe有两种实现形式：</p>
<ul>
<li>基于debugfs/ftrace的简易实现：对于一些简单场景，如获取函数参数，或者函数返回值的场景，可以直接使用</li>
<li>基于内核模块的实现：可以实现一些复杂功能和逻辑，适用于复杂的场景</li>
</ul>
<h2 id="kprobe-based-on-ftrace"><a href="#kprobe-based-on-ftrace" class="headerlink" title="kprobe based on ftrace"></a>kprobe based on ftrace</h2><p>用户可以直接通过<code>/sys/kernel/debug/tracing/kprobe_events</code>添加kprobe，语法如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> p[:[GRP/][EVENT]] [MOD:]SYM[+offs]|MEMADDR [FETCHARGS]        : Set a probe</span><br><span class="line"> r[MAXACTIVE][:[GRP/][EVENT]] [MOD:]SYM[+0] [FETCHARGS]        : Set a return probe</span><br><span class="line"> p[:[GRP/][EVENT]] [MOD:]SYM[+0]%return [FETCHARGS]    : Set a return probe</span><br><span class="line"> -:[GRP/][EVENT]                                               : Clear a probe</span><br><span class="line"></span><br><span class="line">GRP            : Group name. If omitted, use &quot;kprobes&quot; for it.</span><br><span class="line">EVENT          : Event name. If omitted, the event name is generated</span><br><span class="line">                 based on SYM+offs or MEMADDR.</span><br><span class="line">MOD            : Module name which has given SYM.</span><br><span class="line">SYM[+offs]     : Symbol+offset where the probe is inserted.</span><br><span class="line">SYM%return     : Return address of the symbol</span><br><span class="line">MEMADDR        : Address where the probe is inserted.</span><br><span class="line">MAXACTIVE      : Maximum number of instances of the specified function that</span><br><span class="line">                 can be probed simultaneously, or 0 for the default value</span><br><span class="line">                 as defined in Documentation/trace/kprobes.rst section 1.3.1.</span><br><span class="line"></span><br><span class="line">FETCHARGS      : Arguments. Each probe can have up to 128 args.</span><br><span class="line"> %REG          : Fetch register REG</span><br><span class="line"> @ADDR         : Fetch memory at ADDR (ADDR should be in kernel)</span><br><span class="line"> @SYM[+|-offs] : Fetch memory at SYM +|- offs (SYM should be a data symbol)</span><br><span class="line"> $stackN       : Fetch Nth entry of stack (N &gt;= 0)</span><br><span class="line"> $stack        : Fetch stack address.</span><br><span class="line"> $argN         : Fetch the Nth function argument. (N &gt;= 1) (\*1)</span><br><span class="line"> $retval       : Fetch return value.(\*2)</span><br><span class="line"> $comm         : Fetch current task comm.</span><br><span class="line"> +|-[u]OFFS(FETCHARG) : Fetch memory at FETCHARG +|- OFFS address.(\*3)(\*4)</span><br><span class="line"> \IMM          : Store an immediate value to the argument.</span><br><span class="line"> NAME=FETCHARG : Set NAME as the argument name of FETCHARG.</span><br><span class="line"> FETCHARG:TYPE : Set TYPE as the type of FETCHARG. Currently, basic types</span><br><span class="line">                 (u8/u16/u32/u64/s8/s16/s32/s64), hexadecimal types</span><br><span class="line">                 (x8/x16/x32/x64), &quot;string&quot;, &quot;ustring&quot; and bitfield</span><br><span class="line">                 are supported.</span><br><span class="line"></span><br><span class="line"> (\*1) only for the probe on function entry (offs == 0).</span><br><span class="line"> (\*2) only for return probe.</span><br><span class="line"> (\*3) this is useful for fetching a field of data structures.</span><br><span class="line"> (\*4) &quot;u&quot; means user-space dereference. See :ref:`user_mem_access`.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当kprobe添加完成后，会生成对应的kprobe目录：<code>/sys/kernel/debug/tracing/events/kprobes/&lt;EVENT&gt;</code>，可以通过<code>/sys/kernel/debug/tracing/events/kprobes/&lt;EVENT&gt;/enable</code>去控制对应kprobe的启用禁用。</p>
<p>官方示例（应该是32位的x86），对<code>do_sys_open</code>，可通过如下kprobe获取其参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)&#x27;</span> &gt; /sys/kernel/debug/tracing/kprobe_events</span><br></pre></td></tr></table></figure>

<p>各个参数含义如下：</p>
<ul>
<li><code>p</code>：kprobe类型为kprobe</li>
<li><code>myprobe</code>：event名称</li>
<li><code>do_sys_open</code>：进行kprobe的函数名</li>
<li><code>dfd=%ax filename=%dx flags=%cx mode=+4($stack)</code>：获取参数并输出，<code>%ax</code>、<code>%dx</code>、<code>%cx</code>和<code>+4($stack)</code>分别为寄存器名字和栈上偏移</li>
</ul>
<p>可通过如下kprobe获取返回值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r:myretprobe do_sys_open $retval&#x27;</span> &gt;&gt; /sys/kernel/debug/tracing/kprobe_events</span><br></pre></td></tr></table></figure>

<p>各个参数含义如下：</p>
<ul>
<li><code>r</code>：kprobe类型为kretprobe</li>
<li><code>myretprobe</code>：event名称</li>
<li><code>do_sys_open</code>：进行kprobe的函数名</li>
<li><code>$retval</code>：获取返回值并输出</li>
</ul>
<p>启用这两个kprobe：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myprobe/<span class="built_in">enable</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myretprobe/<span class="built_in">enable</span></span><br></pre></td></tr></table></figure>

<p>开启ftrace：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure>

<p>查看结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace</span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286875: myprobe: (do_sys_open+0x0/0xd6) dfd=3 filename=7fffd1ec4440 flags=8000 mode=0</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286878: myretprobe: (sys_openat+0xc/0xe &lt;- do_sys_open) <span class="variable">$retval</span>=fffffffffffffffe</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286885: myprobe: (do_sys_open+0x0/0xd6) dfd=ffffff9c filename=40413c flags=8000 mode=1b6</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286915: myretprobe: (sys_open+0x1b/0x1d &lt;- do_sys_open) <span class="variable">$retval</span>=3</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286969: myprobe: (do_sys_open+0x0/0xd6) dfd=ffffff9c filename=4041c6 flags=98800 mode=10</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286976: myretprobe: (sys_open+0x1b/0x1d &lt;- do_sys_open) <span class="variable">$retval</span>=3</span><br></pre></td></tr></table></figure>

<p>详细使用方式可以参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/trace/kprobetrace.html">Kprobe-based Event Tracing</a></p>
<p>上面为直接在debugfs下操作，操作比较繁琐，也有一些现成的工具<a target="_blank" rel="noopener" href="https://github.com/iovisor/bpftrace">bpftrace</a>和<a target="_blank" rel="noopener" href="https://github.com/brendangregg/perf-tools/blob/master/kernel/kprobe">perf-tools</a>对debugfs下的操作进行了封装，可以简化操作步骤。</p>
<h2 id="kprobe-module"><a href="#kprobe-module" class="headerlink" title="kprobe module"></a>kprobe module</h2><p>kprobe最原始的使用方式是编译一个内核模块，在模块内部进行kprobe的注册handler，在handler实现所需要的逻辑。</p>
<p>这种方式提供了很强大的自由度，缺点就是使用难度较高，在一些需要复杂一点的逻辑的地方可以使用，<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/kprobes.txt">内核文档</a>对这种方式进行了详细说明。</p>
<p>以上述排查ACK是否有被正常接收的问题为例，通过看代码可以确认，对应ACK处理函数为<code>tcp_ack</code>，参数中包含了<code>skb</code>，基于ftrace的kprobe可以获取到<code>skb</code>，甚至可以通过偏移获取到<code>skb</code>的成员，但问题在于，在一个正常的Linux环境，每秒处理的ACK太多了，这种kprobe没法精确过滤所需内容，所以需要自行编写过滤逻辑，并输出期望的内容。</p>
<p>排查过程中用到的部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre_tcp_ack</span><span class="params">(struct kprobe *p, struct pt_regs *regs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> <span class="title">kp_tcp_ack</span> =</span> &#123;</span><br><span class="line">	.symbol_name = <span class="string">&quot;tcp_ack&quot;</span>,</span><br><span class="line">	.pre_handler = pre_tcp_ack,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre_tcp_ack</span><span class="params">(struct kprobe *p, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">	skb = (struct sk_buff *)regs-&gt;si;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_hdr(skb)-&gt;source != htons(<span class="number">7001</span>) &amp;&amp; tcp_hdr(skb)-&gt;dest != htons(<span class="number">7001</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flag = (<span class="keyword">int</span>)regs-&gt;dx;</span><br><span class="line">	printk(<span class="string">&quot;Get ACK: %u(%x) in tcp_ack(flag: %d).\n&quot;</span>, TCP_SKB_CB(skb)-&gt;ack_seq, TCP_SKB_CB(skb)-&gt;ack_seq, flag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (register_kprobe(&amp;kp_tcp_ack)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;trace-ack loaded.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fini</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unregister_kprobe(&amp;kp_tcp_ack);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;trace-ack unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init);</span><br><span class="line">module_exit(fini);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到整体逻辑非常简单，在<code>module_init</code>中通过<code>register_kprobe</code>注册kprobe，在<code>module_exit</code>中通过<code>unregister_kprobe</code>取消kprobe的注册。</p>
<p><code>struct kprobe</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* list of kprobes for multi-handler support */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*count the number of times this probe was temporarily disarmed */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nmissed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* location of the probe point */</span></span><br><span class="line">	<span class="keyword">kprobe_opcode_t</span> *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow user to indicate symbol name of the probe point */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *symbol_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Offset into the symbol */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called before addr is executed. */</span></span><br><span class="line">	<span class="keyword">kprobe_pre_handler_t</span> pre_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called after addr is executed, unless... */</span></span><br><span class="line">	<span class="keyword">kprobe_post_handler_t</span> post_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ... called if executing addr causes a fault (eg. page fault).</span></span><br><span class="line"><span class="comment">	 * Return 1 if it handled fault, otherwise kernel will see it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">kprobe_fault_handler_t</span> fault_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ... called if breakpoint trap occurs in probe handler.</span></span><br><span class="line"><span class="comment">	 * Return 1 if it handled break, otherwise kernel will see it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">kprobe_break_handler_t</span> break_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Saved opcode (which has been replaced with breakpoint) */</span></span><br><span class="line">	<span class="keyword">kprobe_opcode_t</span> opcode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy of the original instruction */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_specific_insn</span> <span class="title">ainsn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Indicates various status flags.</span></span><br><span class="line"><span class="comment">	 * Protected by kprobe_mutex after this kprobe is registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员很多，通常只需关注<code>handler</code>和<code>symbol</code>：</p>
<ul>
<li>handler：对应事件发生时，所执行的函数</li>
<li>symbol：需要probe的符号名，即函数名</li>
</ul>
<p>根据<code>symbol</code>在完成对应类型的<code>handler</code>编写，最后将kprobe注册到内核，即可正常工作。</p>
<p>可以看到上面的例子中的<code>pre_handler</code>为<code>pre_tcp_ack</code>，在其内部先是获取到了<code>skb</code>，再根据端口号过滤掉不需要的<code>skb</code>，再输出TCP的<code>seq</code>和<code>ack</code>。</p>
<p>使用<code>symbol</code>注册的kprobe只能在特定函数的入口/出口执行，<code>struct kprobe</code>还有成员<code>addr</code>和<code>offset</code>，可以用于精确指定probe的地址，但这种使用方式难度很大，获取所需参数时需要通过汇编代码确认对应的寄存器，再获取。而在函数入口的kprobe可以根据对应架构的传参规范通过对应寄存器直接获取，关于通过寄存器获取函数参数的方式，也可以参考<code>bpf_tracing.h</code>中的<code>PT_REGS_PARAM1</code>类似宏。</p>
<h1 id="Systemtap"><a href="#Systemtap" class="headerlink" title="Systemtap"></a>Systemtap</h1><p><a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/index.html">systemtap</a>是一个基于kprobe开发的动态调试工具，功能非常强大，有自己的脚本语言（完整语法规范参考<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/langref.pdf">SystemTap Language Reference</a>），可以通过编写systemtap脚本的方式，由systemtap生成对应的kprobe代码并加载到内核运行。这样用户的开发难度就大大降低了，不再需要懂内核编程，也不需要有内核编译环境。</p>
<p>systemtap的安装使用在大多数的Linux发行版上都比较容易，直接通过对应的包管理工具安装即可，需要注意的是同时需要安装对应内核debuginfo，因为systemtap是通过vmlinux和debuginfo去确定probe点的。</p>
<h2 id="无debuginfo使用systemtap"><a href="#无debuginfo使用systemtap" class="headerlink" title="无debuginfo使用systemtap"></a>无debuginfo使用systemtap</h2><p>对于没有debuginfo的生产环境是否可以使用systemtap呢？答案是可以的，但是要有目标环境对应的内核编译环境。</p>
<p>因为systemtap的工作原理就是先生成内核模块再加载执行，我们可以把这两步分开，在编译环境上生成对应的内核模块，在目标环境上加载模块进行调试。</p>
<p>以内核模块<code>xt_state</code>中的函数<code>state_mt</code>为例，首先查看对应的probe点，以及局部变量，注意使用<code>-r</code>指定内核代码路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8/ -L &#x27;module(&quot;xt_state&quot;).function(&quot;state_mt@net/netfilter/xt_state.c&quot;)&#x27;</span></span><br><span class="line">module(<span class="string">&quot;xt_state&quot;</span>).<span class="keyword">function</span>(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:24&quot;</span>) <span class="variable">$skb</span>:struct sk_buff const* <span class="variable">$par</span>:struct xt_action_param* <span class="variable">$sinfo</span>:struct xt_state_info const*</span><br></pre></td></tr></table></figure>

<p>可以将<code>function</code>换成<code>statement</code>，以将probe点指定到具体行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#sed -n &#x27;23, 39p&#x27; /home/kernel.rh8/net/netfilter/xt_state.c</span></span><br><span class="line">static bool</span><br><span class="line">state_mt(const struct sk_buff *skb, struct xt_action_param *par)</span><br><span class="line">&#123;</span><br><span class="line">        const struct xt_state_info *sinfo = par-&gt;matchinfo;</span><br><span class="line">        enum ip_conntrack_info ctinfo;</span><br><span class="line">        unsigned int statebit;</span><br><span class="line">        struct nf_conn *ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ct) /* line 31 */</span><br><span class="line">                statebit = XT_STATE_BIT(ctinfo);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctinfo == IP_CT_UNTRACKED)</span><br><span class="line">                statebit = XT_STATE_UNTRACKED;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                statebit = XT_STATE_INVALID;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> (sinfo-&gt;statemask &amp; statebit);</span><br><span class="line">&#125;</span><br><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8/ -L &#x27;module(&quot;xt_state&quot;).statement(&quot;*@net/netfilter/xt_state.c:31&quot;)&#x27;</span></span><br><span class="line">module(<span class="string">&quot;xt_state&quot;</span>).statement(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:31&quot;</span>) <span class="variable">$skb</span>:struct sk_buff const* <span class="variable">$par</span>:struct xt_action_param* <span class="variable">$sinfo</span>:struct xt_state_info const* <span class="variable">$ctinfo</span>:enum ip_conntrack_info</span><br><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8/ -L &#x27;module(&quot;xt_state&quot;).statement(&quot;*@net/netfilter/xt_state.c:38&quot;)&#x27;</span></span><br><span class="line">module(<span class="string">&quot;xt_state&quot;</span>).statement(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:38&quot;</span>) <span class="variable">$skb</span>:struct sk_buff const* <span class="variable">$par</span>:struct xt_action_param* <span class="variable">$sinfo</span>:struct xt_state_info const* <span class="variable">$statebit</span>:unsigned int</span><br></pre></td></tr></table></figure>

<p>可以看到在不同的probe点，可以访问的局部变量也是不一样的，但是关于局部变量还有一点疑惑：以31行为例，其实应该是还能访问<code>statebit</code>和<code>ct</code>这两个变量的，但probe显示出来的变量并不包含这两个，可能是对变量做了一些优化，一些还没赋值的变量（<code>statebit</code>）和一些变量可以间接通过其他变量获取（<code>ct</code>）被优化掉了。</p>
<p>编写如下systemtap脚本用于在<code>state_mt</code>内部输出<code>ctinfo</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Part 1: Global embedded C include */</span></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/x_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/xt_state.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netfilter/nf_conntrack_core.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">/* Part 1 end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Part2: Embedded C function */</span></span><br><span class="line"><span class="function">function <span class="title">print_ctinfo</span> <span class="params">(skb, ctinfo)</span></span></span><br><span class="line"><span class="function">%</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ip_conntrack_info</span> <span class="title">ctinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	skb = (struct sk_buff *)STAP_ARG_skb;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;protocol != htons(ETH_P_IP)) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	<span class="keyword">if</span> (!iph) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	th = tcp_hdr(skb);</span><br><span class="line">	<span class="keyword">if</span> (!th) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;dest != htons(<span class="number">22</span>)) &#123;</span><br><span class="line">		STAP_RETURN();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctinfo = STAP_ARG_ctinfo;</span><br><span class="line">	<span class="keyword">if</span> (printk_ratelimit()) &#123;</span><br><span class="line">		printk(<span class="string">&quot;[%s] Capture TCP packet: %hu.%hu.%hu.%hu:%hu-&gt;%hu.%hu.%hu.%hu:%hu with ctinfo: %d.\n&quot;</span>,</span><br><span class="line">			   __func__,</span><br><span class="line">			   iph-&gt;saddr &amp; <span class="number">0xff</span>, (iph-&gt;saddr &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, (iph-&gt;saddr &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, (iph-&gt;saddr &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>,</span><br><span class="line">			   ntohs(th-&gt;source),</span><br><span class="line">			   iph-&gt;daddr &amp; <span class="number">0xff</span>, (iph-&gt;daddr &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, (iph-&gt;daddr &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, (iph-&gt;daddr &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>,</span><br><span class="line">			   ntohs(th-&gt;dest),</span><br><span class="line">			   ctinfo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	STAP_RETURN();</span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">/* Part 2 end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Part 3: Probes */</span></span><br><span class="line"><span class="function">probe <span class="title">module</span><span class="params">(<span class="string">&quot;xt_state&quot;</span>)</span>.<span class="title">statement</span><span class="params">(<span class="string">&quot;state_mt@net/netfilter/xt_state.c:31&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	print_ctinfo($skb, $ctinfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">&quot;probe start.\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">probe end</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">&quot;probe end.\n&quot;</span>)</span><br><span class="line">	<span class="built_in">exit</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Part3 end */</span></span><br></pre></td></tr></table></figure>

<p>脚本分为3部分：</p>
<ul>
<li>Part 1：嵌入的C代码的全局include，因为后续嵌入的C函数需要一些头文件，所以在开头定义好。</li>
<li>Part 2：功能函数<code>print_ctinfo</code>，接受两个参数<code>skb</code>和<code>ctinfo</code>。</li>
<li>Part 3：声明探测点probe</li>
</ul>
<p>Part 1和Part 2使用了嵌入C代码，关于嵌入C代码，有如下几个特点：</p>
<ul>
<li>最外层使用<code>%&#123;...%&#125;</code>这样的括号</li>
<li>获取函数参数通过<code>STAP_ARG_</code>前缀加上参数名获取，如<code>STAP_ARG_skb</code></li>
<li>函数内部使用<code>STAP_RETURN()</code>进行返回，参数不为空时可以为字符串或整数，和函数定义时的返回类型相同。</li>
<li>函数内部使用<code>STAP_RETVALUE</code>作为返回值，可以为整数或字符串，字符串返回时需使用<code>snprintf</code>类似的函数为其赋值。</li>
</ul>
<p>Part 2中<code>print_ctinfo</code>内部通过参数获取到<code>skb</code>和<code>ctinfo</code>，并进行合法性检查，通过合法性检查后，直接通过<code>printk</code>输出<code>skb</code>和<code>ctinfo</code>相关的信息。</p>
<p>Part 3中定义了3个probe，分别为<code>xt_state.c</code>第31行对应地址的probe，以及两个内建probe start 和end，分别在运行的开始和结束处调用。</p>
<p>systemtap脚本编写完成后，即可使用<code>stap</code>命令编译对应的模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8 -DSTP_NO_OVERLOAD -DSTP_NO_VERREL_CHECK  -DSTP_NO_BUILDID_CHECK -v -p4 -m print_ctinfo.ko -g print_ctinfo.stp </span></span><br><span class="line">Truncating module name to <span class="string">&#x27;print_ctinfo&#x27;</span></span><br><span class="line">Pass 1: parsed user script and 484 library scripts using 155264virt/96900res/2956shr/93944data kb, <span class="keyword">in</span> 290usr/50sys/337real ms.</span><br><span class="line">Pass 2: analyzed script: 3 probes, 4 <span class="built_in">functions</span>, 1 embed, 0 globals using 157656virt/100236res/3944shr/96336data kb, <span class="keyword">in</span> 50usr/380sys/431real ms.</span><br><span class="line">Pass 3: translated to C into <span class="string">&quot;/tmp/stap7rcpFZ/print_ctinfo_src.c&quot;</span> using 157920virt/100756res/4216shr/96600data kb, <span class="keyword">in</span> 30usr/380sys/414real ms.</span><br><span class="line">print_ctinfo.ko</span><br><span class="line">Pass 4: compiled C into <span class="string">&quot;print_ctinfo.ko&quot;</span> <span class="keyword">in</span> 2270usr/760sys/2612real ms.</span><br><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#file print_ctinfo.ko </span></span><br><span class="line">print_ctinfo.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=0xd1741342db5acb8c31f82e5684273aae24125c82, not stripped</span><br></pre></td></tr></table></figure>

<p><code>stap</code>的执行一共有5个阶段，分别为：<code>parse</code>、<code>elaborate</code>、<code>translate</code>、<code>compile</code>和<code>run</code>，可以通过<code>-p</code>指定执行阶段。上述指定了<code>-p4</code>的命令最终编译出了可用的内核模块<code>print_ctinfo.ko</code>。</p>
<p>在运行环境上，则可以直接通过<code>staprun</code>命令进行probe，该命令会自动加载模块，命令执行完成后，会自动卸载模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./staprun print_ctinfo.ko</span></span><br><span class="line">probe start.</span><br></pre></td></tr></table></figure>

<p>此时观察内核日志，可以找到期望的输出，可以看到成功过滤了经过<code>state_mt</code>的SSH报文并且输出了相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2022-12-08 17:37:07.614013 warning [kernel:] [171938.274058] [function___global_print_ctinfo__overload_0] Capture TCP packet: 172.23.9.13:7037-&gt;10.103.240.223:22 with ctinfo: 0.</span><br><span class="line">2022-12-08 17:37:07.623029 warning [kernel:] [171938.283066] [function___global_print_ctinfo__overload_0] Capture TCP packet: 10.103.241.85:51515-&gt;10.103.240.223:22 with ctinfo: 0.</span><br><span class="line">2022-12-08 17:37:07.623997 warning [kernel:] [171938.284053] [function___global_print_ctinfo__overload_0] Capture TCP packet: 172.23.9.13:7037-&gt;10.103.240.223:22 with ctinfo: 0.</span><br></pre></td></tr></table></figure>

<p><code>stap</code>在运行过程中，会将生成的C代码放在临时目录，可以通过<code>-k</code>选项保留临时目录，然后查看对应的C代码。上述自定义函数<code>print_ctinfo</code>生成的目标C代码部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function___global_print_ctinfo__overload_0</span> <span class="params">(struct context* __restrict__ c)</span> </span>&#123;</span><br><span class="line">  __label__ deref_fault;</span><br><span class="line">  __label__ out;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">function___global_print_ctinfo__overload_0_locals</span> *  __<span class="title">restrict__</span> <span class="title">l</span> =</span> &amp; c-&gt;locals[c-&gt;nesting+<span class="number">1</span>].function___global_print_ctinfo__overload_0;</span><br><span class="line">  (<span class="keyword">void</span>) l;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> CONTEXT c</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> THIS l</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_ARG_skb THIS-&gt;l_skb</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_ARG_ctinfo THIS-&gt;l_ctinfo</span></span><br><span class="line">  c-&gt;last_stmt = <span class="string">&quot;identifier &#x27;print_ctinfo&#x27; at print_ctinfo.stp:8:10&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (unlikely (c-&gt;nesting+<span class="number">1</span> &gt;= MAXNESTING)) &#123;</span><br><span class="line">    c-&gt;last_error = <span class="string">&quot;MAXNESTING exceeded&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c-&gt;nesting ++;</span><br><span class="line">  &#125;</span><br><span class="line">  c-&gt;next = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_NEXT do &#123; c-&gt;next = 1; goto out; &#125; while(0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_RETURN() do &#123; goto out; &#125; while(0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_PRINTF(fmt, ...) do &#123; _stp_printf(fmt, ##__VA_ARGS__); &#125; while (0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STAP_ERROR(...) do &#123; snprintf(CONTEXT-&gt;error_buffer, MAXSTRINGLEN, __VA_ARGS__); CONTEXT-&gt;last_error = CONTEXT-&gt;error_buffer; goto out; &#125; while (0)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> return goto out</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;actionremaining &lt; <span class="number">0</span>) &#123; c-&gt;last_error = <span class="string">&quot;MAXACTION exceeded&quot;</span>;<span class="keyword">goto</span> out; &#125;</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">ip_conntrack_info</span> <span class="title">ctinfo</span>;</span></span><br><span class="line"></span><br><span class="line">        skb = (struct sk_buff *)STAP_ARG_skb;</span><br><span class="line">        <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">                STAP_RETURN();</span><br></pre></td></tr></table></figure>

<p>可以看到一些在函数体内部使用的宏，如<code>STAP_RETURN</code>，在函数开头都有定义，生成的函数名<code>function___global_print_ctinfo__overload_0</code>也和内核日志中一致。</p>
<p>除了内核函数的probe，systemtap还支持许多其他类型的probe，可通过<code>stap --dump-probe-types</code>查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@docker &lt;bca7e9fa6017&gt; /home ]<span class="comment">#stap -r /home/kernel.rh8 --dump-probe-types</span></span><br><span class="line">......</span><br><span class="line">netfilter.hook(string).pf(string)</span><br><span class="line">netfilter.hook(string).pf(string).priority(string)</span><br><span class="line">netfilter.pf(string).hook(string)</span><br><span class="line">netfilter.pf(string).hook(string).priority(string)</span><br><span class="line">......</span><br><span class="line">process(string).begin</span><br><span class="line">process(string).end</span><br><span class="line">......</span><br><span class="line">procfs(string).<span class="built_in">read</span></span><br><span class="line">procfs(string).read.maxsize(number)</span><br><span class="line">......</span><br><span class="line">python2.module(string).<span class="keyword">function</span>(string)</span><br><span class="line">python2.module(string).<span class="keyword">function</span>(string).call</span><br><span class="line">python2.module(string).<span class="keyword">function</span>(string).<span class="built_in">return</span></span><br><span class="line">python3.module(string).<span class="keyword">function</span>(string)</span><br><span class="line">python3.module(string).<span class="keyword">function</span>(string).call</span><br><span class="line">python3.module(string).<span class="keyword">function</span>(string).<span class="built_in">return</span></span><br><span class="line">......</span><br><span class="line">timer.hz(number)</span><br><span class="line">timer.jiffies(number)</span><br><span class="line">timer.jiffies(number).randomize(number)</span><br></pre></td></tr></table></figure>

<p>包含了许多针对特定场景的probe，包括对用户态的进程、python模块等。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/" rel="tag">Other</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-A-multiplication-overflow-problem"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/21/A-multiplication-overflow-problem/"
    >A multiplication overflow problem</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/21/A-multiplication-overflow-problem/" class="article-date">
  <time datetime="2023-01-21T14:08:18.000Z" itemprop="datePublished">2023-01-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>我司产品从内核ct抄了一份ip解析的代码在应用层使用，在客户跑业务的时候coredump掉了，从堆栈分析看是做乘法过程中整数溢出abort了，在这里简单记录下。</p>
<h1 id="in4-pton"><a href="#in4-pton" class="headerlink" title="in4_pton"></a>in4_pton</h1><p>问题函数为<code>in4_pton</code>，用于将字符串ip转换成二进制ip，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * in4_pton - convert an IPv4 address from literal to binary representation</span></span><br><span class="line"><span class="comment"> * @src: the start of the IPv4 address string</span></span><br><span class="line"><span class="comment"> * @srclen: the length of the string, -1 means strlen(src)</span></span><br><span class="line"><span class="comment"> * @dst: the binary (u8[4] array) representation of the IPv4 address</span></span><br><span class="line"><span class="comment"> * @delim: the delimiter of the IPv4 address in @src, -1 means no delimiter</span></span><br><span class="line"><span class="comment"> * @end: A pointer to the end of the parsed string will be placed here</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return one on success, return zero when any error occurs</span></span><br><span class="line"><span class="comment"> * and @end will point to the end of the parsed string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in4_pton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">int</span> srclen,</span></span></span><br><span class="line"><span class="params"><span class="function">	     u8 *dst,</span></span></span><br><span class="line"><span class="params"><span class="function">	     <span class="keyword">int</span> delim, <span class="keyword">const</span> <span class="keyword">char</span> **end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line">	u8 *d;</span><br><span class="line">	u8 dbuf[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (srclen &lt; <span class="number">0</span>)</span><br><span class="line">		srclen = <span class="built_in">strlen</span>(src);</span><br><span class="line">	s = src;</span><br><span class="line">	d = dbuf;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> c;</span><br><span class="line">		c = xdigit2bin(srclen &gt; <span class="number">0</span> ? *s : <span class="string">&#x27;\0&#x27;</span>, delim);</span><br><span class="line">		<span class="keyword">if</span> (!(c &amp; (IN6PTON_DIGIT | IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK))) &#123;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c &amp; (IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (w == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			*d++ = w &amp; <span class="number">0xff</span>;</span><br><span class="line">			w = <span class="number">0</span>;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (c &amp; (IN6PTON_DELIM | IN6PTON_COLON_MASK)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">4</span>)</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> cont;</span><br><span class="line">		&#125;</span><br><span class="line">		w = (w * <span class="number">10</span>) + c; <span class="comment">/* Coredump here. */</span></span><br><span class="line">		<span class="keyword">if</span> ((w &amp; <span class="number">0xffff</span>) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">cont:</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		s++;</span><br><span class="line">		srclen--;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, dbuf, <span class="keyword">sizeof</span>(dbuf));</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (end)</span><br><span class="line">		*end = s;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(in4_pton);</span><br></pre></td></tr></table></figure>

<p>导致coredump的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = (w * <span class="number">10</span>) + c;</span><br></pre></td></tr></table></figure>

<p>coredump堆栈为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#0  0x00007f9563a35428 in raise () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">#1  0x00007f9563a3702a in abort () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">#2  0x000056378c35c332 in __mulvsi3 ()</span><br><span class="line">#3  0x000056378bdcec16 in in4_pton (delim=-1, end=&lt;synthetic pointer&gt;, dst=0x7f95355e9a44 &quot;&quot;, srclen=566, </span><br><span class="line">    src=0x50005e1169ba &lt;error: Cannot access memory at address 0x50005e1169ba&gt;)</span><br></pre></td></tr></table></figure>

<p>这里<code>src</code>是<code>mbuf</code>的L4数据起始地址，由于环境上没有打开大页内存的coredump，导致<code>src</code>的内容无法获取，提高了一点分析难度，不过影响也不是很大。</p>
<p>接着分析下整体函数流程，从<code>src</code>的起始地址<code>s</code>开始读取每个字符并作相应转换，保存到<code>c</code>中，然后累加到<code>w</code>中去，等于逐位读取十进制整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">		<span class="keyword">int</span> c;</span><br><span class="line">		c = xdigit2bin(srclen &gt; <span class="number">0</span> ? *s : <span class="string">&#x27;\0&#x27;</span>, delim);</span><br><span class="line">......</span><br><span class="line">		w = (w * <span class="number">10</span>) + c; <span class="comment">/* Coredump here. */</span></span><br><span class="line">		<span class="keyword">if</span> ((w &amp; <span class="number">0xffff</span>) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>很明显，这一段是为了将字符形式的点分十进制的IP的数字部分转换成十进制数字并保存，这里通过累计值是否大于255判断数值是否溢出/格式是否正确。</p>
<p>这里要注意的一点是，从<code>xdigit2bin</code>定义中可以发现，<code>c</code>的高16bit代表了<code>c</code>字符的类型，低16bit代表了对应的数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_XDIGIT		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_DIGIT		0x00020000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_MASK	0x00700000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_1		0x00100000	<span class="comment">/* single : requested */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_2		0x00200000	<span class="comment">/* second : requested */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_COLON_1_2	0x00400000	<span class="comment">/* :: requested */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_DOT		0x00800000	<span class="comment">/* . */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_DELIM		0x10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_NULL		0x20000000	<span class="comment">/* first/tail */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6PTON_UNKNOWN		0x40000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">xdigit2bin</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> delim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (c == delim || c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_DELIM;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_COLON_MASK;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_DOT;</span><br><span class="line"></span><br><span class="line">	val = hex_to_bin(c);</span><br><span class="line">	<span class="keyword">if</span> (val &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> val | IN6PTON_XDIGIT | (val &lt; <span class="number">10</span> ? IN6PTON_DIGIT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (delim == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> IN6PTON_DELIM;</span><br><span class="line">	<span class="keyword">return</span> IN6PTON_UNKNOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也正是这一点导致了最终的溢出：如果<code>c</code>只表示数值的话，通过和<code>255</code>比较可以确保不溢出，但每个数字的高16bit都有置位，当起始字符串的以若干<code>0</code>开头时，高16bit一直被累加，而低16bit的值一直是<code>0</code>，始终小于<code>255</code>，最终整体超过了<code>int</code>的上界，结果溢出。</p>
<h1 id="How-about-kernel"><a href="#How-about-kernel" class="headerlink" title="How about kernel?"></a>How about kernel?</h1><p>单单看溢出原因好像已经很明确了，但这段代码是从内核抄出来的，为什么内核正常运行安稳无恙呢？</p>
<p>所以在内核上构造一下对应场景验证，函数调用顺序为：<code>nf_nat_sip</code>-&gt;<code>ct_sip_parse_request</code>-&gt;<code>skp_epaddr_len</code>-&gt;<code>epaddr_len</code>-&gt;<code>sip_parse_addr</code>-&gt;<code>in4_pton</code>。</p>
<p>顶层调用入口<code>nf_nat_sip</code>位于内核模块<code>nf_nat_sip</code>，在模块初始化的时候被注册到<code>netfilter</code>的<code>NAT</code>模块中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_sip_hooks</span> <span class="title">sip_hooks</span> =</span> &#123;</span><br><span class="line">	.msg		= nf_nat_sip,</span><br><span class="line">	.seq_adjust	= nf_nat_sip_seq_adjust,</span><br><span class="line">	.expect		= nf_nat_sip_expect,</span><br><span class="line">	.sdp_addr	= nf_nat_sdp_addr,</span><br><span class="line">	.sdp_port	= nf_nat_sdp_port,</span><br><span class="line">	.sdp_session	= nf_nat_sdp_session,</span><br><span class="line">	.sdp_media	= nf_nat_sdp_media,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nf_nat_sip_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BUG_ON(nf_nat_sip_hooks != <span class="literal">NULL</span>);</span><br><span class="line">	nf_nat_helper_register(&amp;nat_helper_sip);</span><br><span class="line">	RCU_INIT_POINTER(nf_nat_sip_hooks, &amp;sip_hooks);</span><br><span class="line">	nf_ct_helper_expectfn_register(&amp;sip_nat);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以要进入这个函数，首先添加一条DNAT规则，用户态直接通过iptables操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -A PREROUTING -p udp -s 10.103.240.222 --dport 5060 -j DNAT --to-destination 1.2.3.4</span></span><br></pre></td></tr></table></figure>

<p><code>iptable</code>指定<code>-t nat</code>选项查看添加完成后的NAT规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -nvL -t nat</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 18234 packets, 3134K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 DNAT       udp  --  *      *       10.103.240.222       0.0.0.0/0            udp dpt:5060 to:1.2.3.4</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 16998 packets, 2947K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 269 packets, 109K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 277 packets, 110K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>

<p>加载<code>nf_nat_sip</code>模块，打开内核报文转发以及<code>netfilter</code>对应的<code>helper</code>功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe nf_nat_sip</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_helper</span></span><br></pre></td></tr></table></figure>

<p>使用<code>scapy</code>构造异常报文发送：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = <span class="string">&#x27;425945207369703a736572766963654030303937302e312e312e313a35303630205349502f322e300d0a5669613a205349502f322e302f5544502031302e3130332e3234302e3233323a353036303b6272616e63683d7a39684734624b2d313032373537382d313835392d390d0a46726f6d3a2073697070203c7369703a736970704031302e3130332e3234302e3233323a353036303e3b7461673d313835390d0a546f3a20737574203c7369703a736572766963654030303937302e312e312e313a353036303e3b7461673d3132393736534950705461673031313835390d0a43616c6c2d49443a20313835392d313032373537384031302e3130332e3234302e3233320d0a435365713a2032204259450d0a436f6e746163743a207369703a736970704031302e3130332e3234302e3233323a353036300d0a4d61782d466f7277617264733a2037300d0a5375626a6563743a20506572666f726d616e636520546573740d0a436f6e74656e742d4c656e6774683a20300d0a0d0a&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>send(IP(dst=<span class="string">&quot;10.103.241.233&quot;</span>)/UDP(sport=<span class="number">5060</span>,dport=<span class="number">5060</span>)/payload)</span><br><span class="line">.</span><br><span class="line">Sent <span class="number">1</span> packets.</span><br></pre></td></tr></table></figure>

<p>再通过<code>kprobe</code>输出<code>in4_pton</code>的参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./kprobe &#x27;p:in4_pton src=+0(%di):string&#x27;</span></span><br><span class="line">				&lt;idle&gt;-0     [002] ..s. 858059.345971: in4_pton: (in4_pton+0x0/0x170) src=<span class="string">&quot;00970.1.1.1:5060 SIP/2.0</span></span><br><span class="line"><span class="string">Via: SIP/2.0/UDP 10.103.240.232:5060;branch=z9hG4bK-1027578-1859-9</span></span><br><span class="line"><span class="string">From: sipp &lt;sip:sipp@10.103.240.232:5060&gt;;tag=1859</span></span><br><span class="line"><span class="string">To: sut &lt;sip:service@00970.1.1.1:5060&gt;;tag=12976SIPpTag011859</span></span><br><span class="line"><span class="string">Call-ID: 1859-1027578@10.103.240.232</span></span><br><span class="line"><span class="string">CSeq: 2 BYE</span></span><br><span class="line"><span class="string">Contact: sip:sipp@10.103.240.232:5060</span></span><br><span class="line"><span class="string">Max-Forwards: 70</span></span><br><span class="line"><span class="string">Subject: Performance Test</span></span><br><span class="line"><span class="string">Content-Length: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>从<code>kprobe</code>输出中可以看到，内核<code>in4_pton</code>的参数<code>src</code>也是若干<code>0</code>开头的字符串，按照对代码的分析会溢出，但为啥内核还是好好的？是不是内核溢出不会导致coredump？</p>
<p>据此，编写一个溢出的内核模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, w, c;</span><br><span class="line"></span><br><span class="line">        printk(<span class="string">&quot;mo loaded.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">        c = <span class="number">0x30000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                w = w * <span class="number">10</span> + c;</span><br><span class="line">                printk(<span class="string">&quot;w = 0x%08x\n&quot;</span>, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fini</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;mo unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init);</span><br><span class="line">module_exit(fini);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载模块后观察日志输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346619</span> warning [kernel:] [<span class="number">195343.614466</span>] mo loaded.</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346629</span> warning [kernel:] [<span class="number">195343.614467</span>] w = <span class="number">0x00030000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346630</span> warning [kernel:] [<span class="number">195343.614468</span>] w = <span class="number">0x00210000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346631</span> warning [kernel:] [<span class="number">195343.614468</span>] w = <span class="number">0x014d0000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346631</span> warning [kernel:] [<span class="number">195343.614468</span>] w = <span class="number">0x0d050000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346631</span> warning [kernel:] [<span class="number">195343.614469</span>] w = <span class="number">0x82350000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346632</span> warning [kernel:] [<span class="number">195343.614469</span>] w = <span class="number">0x16150000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346632</span> warning [kernel:] [<span class="number">195343.614469</span>] w = <span class="number">0xdcd50000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346639</span> warning [kernel:] [<span class="number">195343.614470</span>] w = <span class="number">0xa0550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346639</span> warning [kernel:] [<span class="number">195343.614470</span>] w = <span class="number">0x43550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346639</span> warning [kernel:] [<span class="number">195343.614470</span>] w = <span class="number">0xa1550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346640</span> warning [kernel:] [<span class="number">195343.614471</span>] w = <span class="number">0x4d550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346640</span> warning [kernel:] [<span class="number">195343.614471</span>] w = <span class="number">0x05550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346640</span> warning [kernel:] [<span class="number">195343.614471</span>] w = <span class="number">0x35550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346641</span> warning [kernel:] [<span class="number">195343.614472</span>] w = <span class="number">0x15550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346641</span> warning [kernel:] [<span class="number">195343.614472</span>] w = <span class="number">0xd5550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346642</span> warning [kernel:] [<span class="number">195343.614472</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346642</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346643</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346643</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346643</span> warning [kernel:] [<span class="number">195343.614473</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346644</span> warning [kernel:] [<span class="number">195343.614474</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346644</span> warning [kernel:] [<span class="number">195343.614474</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346645</span> warning [kernel:] [<span class="number">195343.614474</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346645</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346646</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346646</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346647</span> warning [kernel:] [<span class="number">195343.614475</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346647</span> warning [kernel:] [<span class="number">195343.614476</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346648</span> warning [kernel:] [<span class="number">195343.614476</span>] w = <span class="number">0x55550000</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">18.346648</span> warning [kernel:] [<span class="number">195343.614476</span>] w = <span class="number">0x55550000</span></span><br></pre></td></tr></table></figure>

<p>结果看上去确实溢出了，但没有造成coredump。</p>
<h1 id="mulvsi3"><a href="#mulvsi3" class="headerlink" title="__mulvsi3"></a>__mulvsi3</h1><p>回过头看最初造成coredump的函数<code>__mulvsi3</code>，该函数是GCC内置函数，对应的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00000000004005f0 &lt;__mulvsi3&gt;:</span><br><span class="line">  4005f0:       48 63 c7                movslq %edi,%rax</span><br><span class="line">  4005f3:       48 63 f6                movslq %esi,%rsi</span><br><span class="line">  4005f6:       48 0f af c6             imul   %rsi,%rax /* rax = rax * rsi */</span><br><span class="line">  4005fa:       48 89 c2                mov    %rax,%rdx</span><br><span class="line">  4005fd:       89 c1                   mov    %eax,%ecx</span><br><span class="line">  4005ff:       48 c1 fa 20             sar    $0x20,%rdx</span><br><span class="line">  400603:       c1 f9 1f                sar    $0x1f,%ecx</span><br><span class="line">  400606:       39 d1                   cmp    %edx,%ecx /* rdx &gt;&gt; 0x20 == ecx &gt;&gt; 0x1f */</span><br><span class="line">  400608:       75 02                   jne    40060c &lt;__mulvsi3+0x1c&gt;</span><br><span class="line">  40060a:       f3 c3                   repz retq </span><br><span class="line">  40060c:       50                      push   %rax</span><br><span class="line">  40060d:       e8 1e fe ff ff          callq  400430 &lt;abort@plt&gt;</span><br><span class="line">  400612:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  400619:       00 00 00 </span><br><span class="line">  40061c:       0f 1f 40 00             nopl   0x0(%rax)</span><br></pre></td></tr></table></figure>

<p>可以看到在计算完乘积后，通过最高位的进位和次高位的进位情况进行溢出判断（双高位判断法，原理没搞懂），如果发生溢出则跳转，并且最终执行<code>abort</code>。</p>
<p>为什么内核没有发生coredump，大概因为内核的乘法对应的实现没有做溢出检测。应用层也是同理，如果对应的乘法实现没有溢出检测的话也不会出现coredump。</p>
<p>通常来说，整数溢出的问题主要可能影响一些条件判断，进而造成死循环等问题，这种导致coredump的比较少，但总的来说还是应该尽量避免。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Other/" rel="tag">Other</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-How-does-QEMU-notify-Guest-the-nic-link-status-changed"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/22/How-does-QEMU-notify-Guest-the-nic-link-status-changed/"
    >How does QEMU notify Guest the nic link status changed</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/22/How-does-QEMU-notify-Guest-the-nic-link-status-changed/" class="article-date">
  <time datetime="2022-05-22T05:27:46.000Z" itemprop="datePublished">2022-05-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>事情的起因是同事问到，Guest内部virtio网卡的链路状态是如何改变的，于是从virtio网卡入手，梳理了一下QEMU的网卡链路状态的相关代码。</p> 
      <a class="article-more-link" href="/2022/05/22/How-does-QEMU-notify-Guest-the-nic-link-status-changed/"
        >Read more</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtio-Vhost/" rel="tag">Virtio&#x2F;Vhost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/" rel="tag">Virtualization</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Travel-in-Gansu-and-Qinghai-in-2020"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/06/Travel-in-Gansu-and-Qinghai-in-2020/"
    >Travels of Martzki: Travel in Gansu and Qinghai in 2020</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/06/Travel-in-Gansu-and-Qinghai-in-2020/" class="article-date">
  <time datetime="2022-03-06T05:08:57.000Z" itemprop="datePublished">2022-03-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Travel/">Travel</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在2020年的9月，我参加了公司组织的旅行团，目的地是青海和甘肃，开启了第一次的西北之旅。</p>
<p>首先说下旅行本身，由于是跟团游，甚至是跟公司的团，所以行程上面没有什么可自由安排的余地，也没法把青甘大环线上的所有景点都游览一遍。虽然目的地是青海甘肃，但实际上6天行程，最后只有2天在青海，加上一路的奔波，其实体验上来说还是非常辛苦的。</p> 
      <a class="article-more-link" href="/2022/03/06/Travel-in-Gansu-and-Qinghai-in-2020/"
        >Read more</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travel/" rel="tag">Travel</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Mattermost-auto-reply-tool"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/17/Mattermost-auto-reply-tool/"
    >Mattermost Auto Reply Tool</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/17/Mattermost-auto-reply-tool/" class="article-date">
  <time datetime="2022-02-17T14:48:32.000Z" itemprop="datePublished">2022-02-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p><a target="_blank" rel="noopener" href="https://mattermost.org/">Mattermost</a>是一款开源的IM工具，作为Slack的替代产品。</p>
<h2 id="Mattermost-Source-Code"><a href="#Mattermost-Source-Code" class="headerlink" title="Mattermost Source Code"></a>Mattermost Source Code</h2><p>mattermost的github主页上主要有这几个项目：</p>
<ul>
<li>mattermost-server: 用Go开发的服务端代码，也是整体的核心代码；</li>
<li>mattermost-webapp: 基于Web的客户端代码，所有其他类型的客户端，均是基于webapp实现；</li>
<li>desktop: 基于Electron的Windows客户端代码，通过Chromium浏览器内核连接webapp，完成客户端的功能；</li>
<li>mattermost-mobile: iOS和Android的客户端代码，应该也是通过浏览器内核连接webapp进而实现的的客户端功能。</li>
</ul> 
      <a class="article-more-link" href="/2022/02/17/Mattermost-auto-reply-tool/"
        >Read more</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/For-Fun/" rel="tag">For Fun</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Travel-in-Hangzhou-in-2021"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/07/Travel-in-Hangzhou-in-2021/"
    >Travels of Martzki: Travel in Hangzhou in 2021</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/07/Travel-in-Hangzhou-in-2021/" class="article-date">
  <time datetime="2022-02-07T12:46:05.000Z" itemprop="datePublished">2022-02-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Travel/">Travel</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>2021年的清明节假期，是我的第一次杭州旅行。一是想体验下杭州的清明时节，欣赏下西湖美景；二是亲身感受下杭州作为一线IT城市的氛围。  </p> 
      <a class="article-more-link" href="/2022/02/07/Travel-in-Hangzhou-in-2021/"
        >Read more</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travel/" rel="tag">Travel</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Virtio-feature-negotiation-from-QEMU-perspective"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/06/Virtio-feature-negotiation-from-QEMU-perspective/"
    >Virtio feature negotiation from QEMU perspective</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/06/Virtio-feature-negotiation-from-QEMU-perspective/" class="article-date">
  <time datetime="2022-02-06T15:22:34.000Z" itemprop="datePublished">2022-02-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Technology/">Technology</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="QEMU中的Virtio-features协商流程"><a href="#QEMU中的Virtio-features协商流程" class="headerlink" title="QEMU中的Virtio features协商流程"></a>QEMU中的Virtio features协商流程</h1><p>下面以virtio-net对接vhost-net（kernel）为例，分析整个Virtio features协商的过程。</p>
<h2 id="vhost-net"><a href="#vhost-net" class="headerlink" title="vhost-net"></a>vhost-net</h2><p>vhost_net作为描述后端的数据结构，与真正使用的后端（vhost_user or vhost_net）对应。<br>每个vhost_net包含一个vhost_dev，vhost_net的features实际就是vhost_dev的features，与features相关的成员有：<code>features</code>，<code>acked_features</code>，<code>backend_features</code>和<code>protocol_features</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_net</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> <span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> <span class="title">vqs</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> backend;</span><br><span class="line">    NetClientState *nc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_dev</span> &#123;</span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">uint64_t</span> features;</span><br><span class="line">    <span class="keyword">uint64_t</span> acked_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> backend_features;</span><br><span class="line">    <span class="keyword">uint64_t</span> protocol_features;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <a class="article-more-link" href="/2022/02/06/Virtio-feature-negotiation-from-QEMU-perspective/"
        >Read more</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtio-Vhost/" rel="tag">Virtio&#x2F;Vhost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/" rel="tag">Virtualization</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> Martzki
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.JPG" alt="Lost Stars"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Travel/">Travel</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/01/09/About-Me/">About Me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>